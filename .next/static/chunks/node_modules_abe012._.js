(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_abe012._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
            } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else validateChildKeys(children, type);
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>defaultAttributes)
});
var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
;
 //# sourceMappingURL=defaultAttributes.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "mergeClasses": (()=>mergeClasses),
    "toKebabCase": (()=>toKebabCase)
});
const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes)=>classes.filter((className, index, array)=>{
        return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
;
 //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/Icon.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Icon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)");
;
;
;
const Icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("svg", {
        ref,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeClasses"])("lucide", className),
        ...rest
    }, [
        ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
        ...Array.isArray(children) ? children : [
            children
        ]
    ]);
});
;
 //# sourceMappingURL=Icon.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>createLucideIcon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/Icon.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)");
;
;
;
const createLucideIcon = (iconName, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(({ className, ...props }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], {
            ref,
            iconNode,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeClasses"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toKebabCase"])(iconName)}`, className),
            ...props
        }));
    Component.displayName = `${iconName}`;
    return Component;
};
;
 //# sourceMappingURL=createLucideIcon.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>House)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const House = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("House", [
    [
        "path",
        {
            d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",
            key: "5wwlr5"
        }
    ],
    [
        "path",
        {
            d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
            key: "1d0kgt"
        }
    ]
]);
;
 //# sourceMappingURL=house.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-client] (ecmascript) <export default as Home>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Home": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$house$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$house$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/shopping-cart.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>ShoppingCart)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ShoppingCart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ShoppingCart", [
    [
        "circle",
        {
            cx: "8",
            cy: "21",
            r: "1",
            key: "jimo8o"
        }
    ],
    [
        "circle",
        {
            cx: "19",
            cy: "21",
            r: "1",
            key: "13723u"
        }
    ],
    [
        "path",
        {
            d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
            key: "9zh506"
        }
    ]
]);
;
 //# sourceMappingURL=shopping-cart.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/shopping-cart.js [app-client] (ecmascript) <export default as ShoppingCart>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ShoppingCart": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$shopping$2d$cart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$shopping$2d$cart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/shopping-cart.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/package.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Package)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Package = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Package", [
    [
        "path",
        {
            d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
            key: "1a0edw"
        }
    ],
    [
        "path",
        {
            d: "M12 22V12",
            key: "d0xqtd"
        }
    ],
    [
        "path",
        {
            d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7",
            key: "yx3hmr"
        }
    ],
    [
        "path",
        {
            d: "m7.5 4.27 9 5.15",
            key: "1c824w"
        }
    ]
]);
;
 //# sourceMappingURL=package.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/package.js [app-client] (ecmascript) <export default as Package>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Package": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$package$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$package$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/package.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/user-check.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>UserCheck)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const UserCheck = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("UserCheck", [
    [
        "path",
        {
            d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
            key: "1yyitq"
        }
    ],
    [
        "circle",
        {
            cx: "9",
            cy: "7",
            r: "4",
            key: "nufk8"
        }
    ],
    [
        "polyline",
        {
            points: "16 11 18 13 22 9",
            key: "1pwet4"
        }
    ]
]);
;
 //# sourceMappingURL=user-check.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/user-check.js [app-client] (ecmascript) <export default as UserCheck>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "UserCheck": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$user$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$user$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/user-check.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chart-no-axes-column-increasing.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>ChartNoAxesColumnIncreasing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ChartNoAxesColumnIncreasing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChartNoAxesColumnIncreasing", [
    [
        "line",
        {
            x1: "12",
            x2: "12",
            y1: "20",
            y2: "10",
            key: "1vz5eb"
        }
    ],
    [
        "line",
        {
            x1: "18",
            x2: "18",
            y1: "20",
            y2: "4",
            key: "cun8e5"
        }
    ],
    [
        "line",
        {
            x1: "6",
            x2: "6",
            y1: "20",
            y2: "16",
            key: "hq0ia6"
        }
    ]
]);
;
 //# sourceMappingURL=chart-no-axes-column-increasing.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chart-no-axes-column-increasing.js [app-client] (ecmascript) <export default as BarChart>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BarChart": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chart$2d$no$2d$axes$2d$column$2d$increasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chart$2d$no$2d$axes$2d$column$2d$increasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/chart-no-axes-column-increasing.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Layers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Layers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Layers", [
    [
        "path",
        {
            d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
            key: "zw3jo"
        }
    ],
    [
        "path",
        {
            d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
            key: "1wduqc"
        }
    ],
    [
        "path",
        {
            d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
            key: "kqbvx6"
        }
    ]
]);
;
 //# sourceMappingURL=layers.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-client] (ecmascript) <export default as Layers>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Layers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$layers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$layers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/layers.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/tag.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Tag)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Tag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Tag", [
    [
        "path",
        {
            d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
            key: "vktsd0"
        }
    ],
    [
        "circle",
        {
            cx: "7.5",
            cy: "7.5",
            r: ".5",
            fill: "currentColor",
            key: "kqv944"
        }
    ]
]);
;
 //# sourceMappingURL=tag.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/tag.js [app-client] (ecmascript) <export default as Tag>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Tag": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$tag$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$tag$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/tag.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/truck.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Truck)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Truck = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Truck", [
    [
        "path",
        {
            d: "M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2",
            key: "wrbu53"
        }
    ],
    [
        "path",
        {
            d: "M15 18H9",
            key: "1lyqi6"
        }
    ],
    [
        "path",
        {
            d: "M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14",
            key: "lysw3i"
        }
    ],
    [
        "circle",
        {
            cx: "17",
            cy: "18",
            r: "2",
            key: "332jqn"
        }
    ],
    [
        "circle",
        {
            cx: "7",
            cy: "18",
            r: "2",
            key: "19iecd"
        }
    ]
]);
;
 //# sourceMappingURL=truck.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/truck.js [app-client] (ecmascript) <export default as Truck>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Truck": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$truck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$truck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/truck.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/credit-card.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>CreditCard)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const CreditCard = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("CreditCard", [
    [
        "rect",
        {
            width: "20",
            height: "14",
            x: "2",
            y: "5",
            rx: "2",
            key: "ynyp8z"
        }
    ],
    [
        "line",
        {
            x1: "2",
            x2: "22",
            y1: "10",
            y2: "10",
            key: "1b3vmo"
        }
    ]
]);
;
 //# sourceMappingURL=credit-card.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/credit-card.js [app-client] (ecmascript) <export default as CreditCard>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CreditCard": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$credit$2d$card$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$credit$2d$card$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/credit-card.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/settings.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Settings)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Settings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Settings", [
    [
        "path",
        {
            d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
            key: "1qme2f"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "3",
            key: "1v7zrd"
        }
    ]
]);
;
 //# sourceMappingURL=settings.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/settings.js [app-client] (ecmascript) <export default as Settings>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Settings": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$settings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$settings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/settings.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/palette.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Palette)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Palette = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Palette", [
    [
        "circle",
        {
            cx: "13.5",
            cy: "6.5",
            r: ".5",
            fill: "currentColor",
            key: "1okk4w"
        }
    ],
    [
        "circle",
        {
            cx: "17.5",
            cy: "10.5",
            r: ".5",
            fill: "currentColor",
            key: "f64h9f"
        }
    ],
    [
        "circle",
        {
            cx: "8.5",
            cy: "7.5",
            r: ".5",
            fill: "currentColor",
            key: "fotxhn"
        }
    ],
    [
        "circle",
        {
            cx: "6.5",
            cy: "12.5",
            r: ".5",
            fill: "currentColor",
            key: "qy21gx"
        }
    ],
    [
        "path",
        {
            d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
            key: "12rzf8"
        }
    ]
]);
;
 //# sourceMappingURL=palette.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/palette.js [app-client] (ecmascript) <export default as Palette>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Palette": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$palette$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$palette$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/palette.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/user.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>User)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const User = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("User", [
    [
        "path",
        {
            d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
            key: "975kel"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "7",
            r: "4",
            key: "17ys0d"
        }
    ]
]);
;
 //# sourceMappingURL=user.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/user.js [app-client] (ecmascript) <export default as User>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "User": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$user$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$user$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/user.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/bell.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>Bell)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Bell = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Bell", [
    [
        "path",
        {
            d: "M10.268 21a2 2 0 0 0 3.464 0",
            key: "vwvbt9"
        }
    ],
    [
        "path",
        {
            d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326",
            key: "11g9vi"
        }
    ]
]);
;
 //# sourceMappingURL=bell.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/bell.js [app-client] (ecmascript) <export default as Bell>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Bell": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$bell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$bell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/bell.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/circle-help.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>CircleHelp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const CircleHelp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("CircleHelp", [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "10",
            key: "1mglay"
        }
    ],
    [
        "path",
        {
            d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3",
            key: "1u773s"
        }
    ],
    [
        "path",
        {
            d: "M12 17h.01",
            key: "p32p05"
        }
    ]
]);
;
 //# sourceMappingURL=circle-help.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/circle-help.js [app-client] (ecmascript) <export default as HelpCircle>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HelpCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$circle$2d$help$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$circle$2d$help$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/circle-help.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/log-out.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>LogOut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const LogOut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("LogOut", [
    [
        "path",
        {
            d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
            key: "1uf3rs"
        }
    ],
    [
        "polyline",
        {
            points: "16 17 21 12 16 7",
            key: "1gabdz"
        }
    ],
    [
        "line",
        {
            x1: "21",
            x2: "9",
            y1: "12",
            y2: "12",
            key: "1uyos4"
        }
    ]
]);
;
 //# sourceMappingURL=log-out.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/log-out.js [app-client] (ecmascript) <export default as LogOut>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LogOut": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$log$2d$out$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$log$2d$out$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/log-out.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>ChevronRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ChevronRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChevronRight", [
    [
        "path",
        {
            d: "m9 18 6-6-6-6",
            key: "mthhwq"
        }
    ]
]);
;
 //# sourceMappingURL=chevron-right.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript) <export default as ChevronRight>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ChevronRight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license lucide-react v0.469.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_esm__({
    "default": (()=>ChevronDown)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ChevronDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChevronDown", [
    [
        "path",
        {
            d: "m6 9 6 6 6-6",
            key: "qrunsl"
        }
    ]
]);
;
 //# sourceMappingURL=chevron-down.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript) <export default as ChevronDown>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ChevronDown": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ __turbopack_esm__({
    "isPlainObject": (()=>isPlainObject)
});
function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (ctor === undefined) return true;
    // If has modified prototype
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }
    // Most likely a plain Object
    return true;
}
;
}}),
"[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/utils/env.ts
__turbopack_esm__({
    "Immer": (()=>Immer2),
    "applyPatches": (()=>applyPatches),
    "castDraft": (()=>castDraft),
    "castImmutable": (()=>castImmutable),
    "createDraft": (()=>createDraft),
    "current": (()=>current),
    "enableMapSet": (()=>enableMapSet),
    "enablePatches": (()=>enablePatches),
    "finishDraft": (()=>finishDraft),
    "freeze": (()=>freeze),
    "immerable": (()=>DRAFTABLE),
    "isDraft": (()=>isDraft),
    "isDraftable": (()=>isDraftable),
    "nothing": (()=>NOTHING),
    "original": (()=>original),
    "produce": (()=>produce),
    "produceWithPatches": (()=>produceWithPatches),
    "setAutoFreeze": (()=>setAutoFreeze),
    "setUseStrictShallowCopy": (()=>setUseStrictShallowCopy)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
// src/utils/errors.ts
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return `'original' expects a draft, got: ${thing}`;
    }
] : ("TURBOPACK unreachable", undefined);
function die(error, ...args) {
    if ("TURBOPACK compile-time truthy", 1) {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    if (!value) return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
    if (!value || typeof value !== "object") return false;
    const proto = getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
    if (getArchtype(obj) === 0 /* Object */ ) {
        Reflect.ownKeys(obj).forEach((key)=>{
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach((entry, index)=>iter(index, entry, obj));
    }
}
function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (t === 3 /* Set */ ) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function isMap(target) {
    return target instanceof Map;
}
function isSet(target) {
    return target instanceof Set;
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    const isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const desc = descriptors[key];
            if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
            }
            if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
    } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return {
                ...base
            };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
    }
}
function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep) Object.entries(obj).forEach(([key, value])=>freeze(value, true));
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
function isFrozen(obj) {
    return Object.isFrozen(obj);
}
// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) {
            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
    } else {
        result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    if (!state) {
        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path));
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3 /* Set */ ) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (("TURBOPACK compile-time value", "development") !== "production" && childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
            rootScope.canAutoFreeze_ = false;
        } else return;
    } else if (targetIsSet) {
        targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
            return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get (state, prop) {
        if (prop === DRAFT_STATE) return state;
        const source = latest(state);
        if (!has(source, prop)) {
            return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has (state, prop) {
        return prop in latest(state);
    },
    ownKeys (state) {
        return Reflect.ownKeys(latest(state));
    },
    set (state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            const current2 = peek(latest(state), prop);
            const currentState = current2?.[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty (state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else {
            delete state.assigned_[prop];
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor (state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 /* Array */  || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty () {
        die(11);
    },
    getPrototypeOf (state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf () {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, (key, fn)=>{
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    let proto = getPrototypeOf(source);
    while(proto){
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
// src/core/immerClass.ts
var Immer2 = class {
    constructor(config){
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = (base, recipe, patchListener)=>{
            if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            let result;
            if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    const p = [];
                    const ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = (base, recipe)=>{
            if (typeof base === "function") {
                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));
            }
            let patches, inversePatches;
            const result = this.produce(base, recipe, (p, ip)=>{
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof config?.autoFreeze === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    }
    createDraft(base) {
        if (!isDraftable(base)) die(8);
        if (isDraft(base)) base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
    }
    finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_) die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
    }
    /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ setAutoFreeze(value) {
        this.autoFreeze_ = value;
    }
    /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
        let i;
        for(i = patches.length - 1; i >= 0; i--){
            const patch = patches[i];
            if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
            }
        }
        if (i > -1) {
            patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
            return applyPatchesImpl(base, patches);
        }
        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));
    }
};
function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    let copy;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, (key, childValue)=>{
        set(copy, key, currentImpl(childValue));
    });
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    const errorOffset = 16;
    if ("TURBOPACK compile-time truthy", 1) {
        errors.push('Sets cannot have "replace" patches.', function(op) {
            return "Unsupported patch operation: " + op;
        }, function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
        }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    }
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches, inversePatches);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches, inversePatches);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
            ;
            [base_, copy_] = [
                copy_,
                base_
            ];
            [patches, inversePatches] = [
                inversePatches,
                patches
            ];
        }
        for(let i = 0; i < base_.length; i++){
            if (assigned_[i] && copy_[i] !== base_[i]) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REPLACE,
                    path,
                    // Need to maybe clone it, as it can in fact be the original value
                    // due to the base/copy inversion at the start of this function
                    value: clonePatchValueIfNeeded(copy_[i])
                });
                inversePatches.push({
                    op: REPLACE,
                    path,
                    value: clonePatchValueIfNeeded(base_[i])
                });
            }
        }
        for(let i = base_.length; i < copy_.length; i++){
            const path = basePath.concat([
                i
            ]);
            patches.push({
                op: ADD,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
            });
        }
        for(let i = copy_.length - 1; base_.length <= i; --i){
            const path = basePath.concat([
                i
            ]);
            inversePatches.push({
                op: REMOVE,
                path
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue)=>{
            const origValue = get(base_, key);
            const value = get(copy_, key);
            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            const path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op,
                path
            } : {
                op,
                path,
                value
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path
            } : op === REMOVE ? {
                op: ADD,
                path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value)=>{
            if (!copy_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: ADD,
                    path,
                    value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach((value)=>{
            if (!base_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path,
                    value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach((patch)=>{
            const { path, op } = patch;
            let base = draft;
            for(let i = 0; i < path.length - 1; i++){
                const parentType = getArchtype(base);
                let p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                    p = "" + p;
                }
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get(base, p);
                if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
            }
            const type = getArchtype(base);
            const value = deepClonePatchValue(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base.delete(key);
                        case 3 /* Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[
                k,
                deepClonePatchValue(v)
            ]));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
            return deepClonePatchValue(obj);
        } else return obj;
    }
    loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    class DraftMap extends Map {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: this,
                isManual_: false,
                revoked_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(key) {
            return latest(this[DRAFT_STATE]).has(key);
        }
        set(key, value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!latest(state).has(key) || latest(state).get(key) !== value) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_.set(key, true);
                state.copy_.set(key, value);
                state.assigned_.set(key, true);
            }
            return this;
        }
        delete(key) {
            if (!this.has(key)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareMapCopy(state);
            markChanged(state);
            if (state.base_.has(key)) {
                state.assigned_.set(key, false);
            } else {
                state.assigned_.delete(key);
            }
            state.copy_.delete(key);
            return true;
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_ = /* @__PURE__ */ new Map();
                each(state.base_, (key)=>{
                    state.assigned_.set(key, false);
                });
                state.copy_.clear();
            }
        }
        forEach(cb, thisArg) {
            const state = this[DRAFT_STATE];
            latest(state).forEach((_value, key, _map)=>{
                cb.call(thisArg, this.get(key), key, this);
            });
        }
        get(key) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            const value = latest(state).get(key);
            if (state.finalized_ || !isDraftable(value)) {
                return value;
            }
            if (value !== state.base_.get(key)) {
                return value;
            }
            const draft = createProxy(value, state);
            prepareMapCopy(state);
            state.copy_.set(key, draft);
            return draft;
        }
        keys() {
            return latest(this[DRAFT_STATE]).keys();
        }
        values() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.values(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value
                    };
                }
            };
        }
        entries() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.entries(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value: [
                            r.value,
                            value
                        ]
                    };
                }
            };
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.entries();
        }
    }
    function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    class DraftSet extends Set {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!state.copy_) {
                return state.base_.has(value);
            }
            if (state.copy_.has(value)) return true;
            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
            return false;
        }
        add(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!this.has(value)) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.add(value);
            }
            return this;
        }
        delete(value) {
            if (!this.has(value)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            markChanged(state);
            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.clear();
            }
        }
        values() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.values();
        }
        entries() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.entries();
        }
        keys() {
            return this.values();
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.values();
        }
        forEach(cb, thisArg) {
            const iterator = this.values();
            let result = iterator.next();
            while(!result.done){
                cb.call(thisArg, result.value, result.value, this);
                result = iterator.next();
            }
        }
    }
    function proxySet_(target, parent) {
        return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach((value)=>{
                if (isDraftable(value)) {
                    const draft = createProxy(value, state);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else {
                    state.copy_.add(value);
                }
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
    return value;
}
function castImmutable(value) {
    return value;
}
;
 //# sourceMappingURL=immer.mjs.map
}}),
"[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Editor": (()=>Editor),
    "Element": (()=>Element),
    "Location": (()=>Location),
    "Node": (()=>Node),
    "Operation": (()=>Operation),
    "Path": (()=>Path),
    "PathRef": (()=>PathRef),
    "Point": (()=>Point),
    "PointRef": (()=>PointRef),
    "Range": (()=>Range),
    "RangeRef": (()=>RangeRef),
    "Scrubber": (()=>Scrubber),
    "Span": (()=>Span),
    "Text": (()=>Text),
    "Transforms": (()=>Transforms),
    "above": (()=>above),
    "addMark": (()=>addMark),
    "after": (()=>after),
    "apply": (()=>apply),
    "before": (()=>before),
    "collapse": (()=>collapse),
    "createEditor": (()=>createEditor),
    "deleteBackward": (()=>deleteBackward),
    "deleteForward": (()=>deleteForward),
    "deleteFragment": (()=>deleteFragment),
    "deleteText": (()=>deleteText),
    "deselect": (()=>deselect),
    "edges": (()=>edges),
    "elementReadOnly": (()=>elementReadOnly),
    "end": (()=>end),
    "first": (()=>first),
    "fragment": (()=>fragment),
    "getDirtyPaths": (()=>getDirtyPaths),
    "getFragment": (()=>getFragment),
    "getVoid": (()=>getVoid),
    "hasBlocks": (()=>hasBlocks),
    "hasInlines": (()=>hasInlines),
    "hasPath": (()=>hasPath),
    "hasTexts": (()=>hasTexts),
    "insertBreak": (()=>insertBreak),
    "insertFragment": (()=>insertFragment),
    "insertNode": (()=>insertNode),
    "insertNodes": (()=>insertNodes),
    "insertSoftBreak": (()=>insertSoftBreak),
    "insertText": (()=>insertText),
    "isBlock": (()=>isBlock),
    "isEdge": (()=>isEdge),
    "isEditor": (()=>isEditor),
    "isEmpty": (()=>isEmpty),
    "isEnd": (()=>isEnd),
    "isNormalizing": (()=>isNormalizing),
    "isStart": (()=>isStart),
    "last": (()=>last),
    "leaf": (()=>leaf),
    "levels": (()=>levels),
    "liftNodes": (()=>liftNodes),
    "marks": (()=>marks),
    "mergeNodes": (()=>mergeNodes),
    "move": (()=>move),
    "moveNodes": (()=>moveNodes),
    "next": (()=>next),
    "node": (()=>node),
    "nodes": (()=>nodes),
    "normalize": (()=>normalize),
    "normalizeNode": (()=>normalizeNode),
    "parent": (()=>parent),
    "path": (()=>path),
    "pathRef": (()=>pathRef),
    "pathRefs": (()=>pathRefs),
    "point": (()=>point),
    "pointRef": (()=>pointRef),
    "pointRefs": (()=>pointRefs),
    "positions": (()=>positions),
    "previous": (()=>previous),
    "range": (()=>range),
    "rangeRef": (()=>rangeRef),
    "rangeRefs": (()=>rangeRefs),
    "removeMark": (()=>removeMark),
    "removeNodes": (()=>removeNodes),
    "select": (()=>select),
    "setNodes": (()=>setNodes),
    "setNormalizing": (()=>setNormalizing),
    "setPoint": (()=>setPoint),
    "setSelection": (()=>setSelection),
    "shouldMergeNodesRemovePrevNode": (()=>shouldMergeNodesRemovePrevNode),
    "shouldNormalize": (()=>shouldNormalize),
    "splitNodes": (()=>splitNodes),
    "start": (()=>start),
    "string": (()=>string),
    "unhangRange": (()=>unhangRange),
    "unsetNodes": (()=>unsetNodes),
    "unwrapNodes": (()=>unwrapNodes),
    "withoutNormalizing": (()=>withoutNormalizing),
    "wrapNodes": (()=>wrapNodes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
;
;
// eslint-disable-next-line no-redeclare
var PathRef = {
    transform (ref, op) {
        var { current, affinity } = ref;
        if (current == null) {
            return;
        }
        var path = Path.transform(current, op, {
            affinity
        });
        ref.current = path;
        if (path == null) {
            ref.unref();
        }
    }
};
// eslint-disable-next-line no-redeclare
var PointRef = {
    transform (ref, op) {
        var { current, affinity } = ref;
        if (current == null) {
            return;
        }
        var point = Point.transform(current, op, {
            affinity
        });
        ref.current = point;
        if (point == null) {
            ref.unref();
        }
    }
};
// eslint-disable-next-line no-redeclare
var RangeRef = {
    transform (ref, op) {
        var { current, affinity } = ref;
        if (current == null) {
            return;
        }
        var path = Range.transform(current, op, {
            affinity
        });
        ref.current = path;
        if (path == null) {
            ref.unref();
        }
    }
};
var DIRTY_PATHS = new WeakMap();
var DIRTY_PATH_KEYS = new WeakMap();
var FLUSHING = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();
// eslint-disable-next-line no-redeclare
var Path = {
    ancestors (path) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var { reverse = false } = options;
        var paths = Path.levels(path, options);
        if (reverse) {
            paths = paths.slice(1);
        } else {
            paths = paths.slice(0, -1);
        }
        return paths;
    },
    common (path, another) {
        var common = [];
        for(var i = 0; i < path.length && i < another.length; i++){
            var av = path[i];
            var bv = another[i];
            if (av !== bv) {
                break;
            }
            common.push(av);
        }
        return common;
    },
    compare (path, another) {
        var min = Math.min(path.length, another.length);
        for(var i = 0; i < min; i++){
            if (path[i] < another[i]) return -1;
            if (path[i] > another[i]) return 1;
        }
        return 0;
    },
    endsAfter (path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av > bv;
    },
    endsAt (path, another) {
        var i = path.length;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        return Path.equals(as, bs);
    },
    endsBefore (path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av < bv;
    },
    equals (path, another) {
        return path.length === another.length && path.every((n, i)=>n === another[i]);
    },
    hasPrevious (path) {
        return path[path.length - 1] > 0;
    },
    isAfter (path, another) {
        return Path.compare(path, another) === 1;
    },
    isAncestor (path, another) {
        return path.length < another.length && Path.compare(path, another) === 0;
    },
    isBefore (path, another) {
        return Path.compare(path, another) === -1;
    },
    isChild (path, another) {
        return path.length === another.length + 1 && Path.compare(path, another) === 0;
    },
    isCommon (path, another) {
        return path.length <= another.length && Path.compare(path, another) === 0;
    },
    isDescendant (path, another) {
        return path.length > another.length && Path.compare(path, another) === 0;
    },
    isParent (path, another) {
        return path.length + 1 === another.length && Path.compare(path, another) === 0;
    },
    isPath (value) {
        return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');
    },
    isSibling (path, another) {
        if (path.length !== another.length) {
            return false;
        }
        var as = path.slice(0, -1);
        var bs = another.slice(0, -1);
        var al = path[path.length - 1];
        var bl = another[another.length - 1];
        return al !== bl && Path.equals(as, bs);
    },
    levels (path) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var { reverse = false } = options;
        var list = [];
        for(var i = 0; i <= path.length; i++){
            list.push(path.slice(0, i));
        }
        if (reverse) {
            list.reverse();
        }
        return list;
    },
    next (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
        }
        var last = path[path.length - 1];
        return path.slice(0, -1).concat(last + 1);
    },
    operationCanTransformPath (operation) {
        switch(operation.type){
            case 'insert_node':
            case 'remove_node':
            case 'merge_node':
            case 'split_node':
            case 'move_node':
                return true;
            default:
                return false;
        }
    },
    parent (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
        }
        return path.slice(0, -1);
    },
    previous (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
        }
        var last = path[path.length - 1];
        if (last <= 0) {
            throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
        }
        return path.slice(0, -1).concat(last - 1);
    },
    relative (path, ancestor) {
        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
            throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
        }
        return path.slice(ancestor.length);
    },
    transform (path, operation) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (!path) return null;
        // PERF: use destructing instead of immer
        var p = [
            ...path
        ];
        var { affinity = 'forward' } = options;
        // PERF: Exit early if the operation is guaranteed not to have an effect.
        if (path.length === 0) {
            return p;
        }
        switch(operation.type){
            case 'insert_node':
                {
                    var { path: op } = operation;
                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
                        p[op.length - 1] += 1;
                    }
                    break;
                }
            case 'remove_node':
                {
                    var { path: _op } = operation;
                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
                        return null;
                    } else if (Path.endsBefore(_op, p)) {
                        p[_op.length - 1] -= 1;
                    }
                    break;
                }
            case 'merge_node':
                {
                    var { path: _op2, position } = operation;
                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                    } else if (Path.isAncestor(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                        p[_op2.length] += position;
                    }
                    break;
                }
            case 'split_node':
                {
                    var { path: _op3, position: _position } = operation;
                    if (Path.equals(_op3, p)) {
                        if (affinity === 'forward') {
                            p[p.length - 1] += 1;
                        } else if (affinity === 'backward') ;
                        else {
                            return null;
                        }
                    } else if (Path.endsBefore(_op3, p)) {
                        p[_op3.length - 1] += 1;
                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
                        p[_op3.length - 1] += 1;
                        p[_op3.length] -= _position;
                    }
                    break;
                }
            case 'move_node':
                {
                    var { path: _op4, newPath: onp } = operation;
                    // If the old and new path are the same, it's a no-op.
                    if (Path.equals(_op4, onp)) {
                        return p;
                    }
                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
                        var copy = onp.slice();
                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                            copy[_op4.length - 1] -= 1;
                        }
                        return copy.concat(p.slice(_op4.length));
                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        } else {
                            p[_op4.length - 1] += 1;
                        }
                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        }
                        p[onp.length - 1] += 1;
                    } else if (Path.endsBefore(_op4, p)) {
                        if (Path.equals(onp, p)) {
                            p[onp.length - 1] += 1;
                        }
                        p[_op4.length - 1] -= 1;
                    }
                    break;
                }
        }
        return p;
    }
};
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function ownKeys$e(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$e(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$e(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var applyToDraft = (editor, selection, op)=>{
    switch(op.type){
        case 'insert_node':
            {
                var { path, node } = op;
                var parent = Node.parent(editor, path);
                var index = path[path.length - 1];
                if (index > parent.children.length) {
                    throw new Error("Cannot apply an \"insert_node\" operation at path [".concat(path, "] because the destination is past the end of the node."));
                }
                parent.children.splice(index, 0, node);
                if (selection) {
                    for (var [point, key] of Range.points(selection)){
                        selection[key] = Point.transform(point, op);
                    }
                }
                break;
            }
        case 'insert_text':
            {
                var { path: _path, offset, text } = op;
                if (text.length === 0) break;
                var _node = Node.leaf(editor, _path);
                var before = _node.text.slice(0, offset);
                var after = _node.text.slice(offset);
                _node.text = before + text + after;
                if (selection) {
                    for (var [_point, _key] of Range.points(selection)){
                        selection[_key] = Point.transform(_point, op);
                    }
                }
                break;
            }
        case 'merge_node':
            {
                var { path: _path2 } = op;
                var _node2 = Node.get(editor, _path2);
                var prevPath = Path.previous(_path2);
                var prev = Node.get(editor, prevPath);
                var _parent = Node.parent(editor, _path2);
                var _index = _path2[_path2.length - 1];
                if (Text.isText(_node2) && Text.isText(prev)) {
                    prev.text += _node2.text;
                } else if (!Text.isText(_node2) && !Text.isText(prev)) {
                    prev.children.push(..._node2.children);
                } else {
                    throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev)));
                }
                _parent.children.splice(_index, 1);
                if (selection) {
                    for (var [_point2, _key2] of Range.points(selection)){
                        selection[_key2] = Point.transform(_point2, op);
                    }
                }
                break;
            }
        case 'move_node':
            {
                var { path: _path3, newPath } = op;
                if (Path.isAncestor(_path3, newPath)) {
                    throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
                }
                var _node3 = Node.get(editor, _path3);
                var _parent2 = Node.parent(editor, _path3);
                var _index2 = _path3[_path3.length - 1];
                // This is tricky, but since the `path` and `newPath` both refer to
                // the same snapshot in time, there's a mismatch. After either
                // removing the original position, the second step's path can be out
                // of date. So instead of using the `op.newPath` directly, we
                // transform `op.path` to ascertain what the `newPath` would be after
                // the operation was applied.
                _parent2.children.splice(_index2, 1);
                var truePath = Path.transform(_path3, op);
                var newParent = Node.get(editor, Path.parent(truePath));
                var newIndex = truePath[truePath.length - 1];
                newParent.children.splice(newIndex, 0, _node3);
                if (selection) {
                    for (var [_point3, _key3] of Range.points(selection)){
                        selection[_key3] = Point.transform(_point3, op);
                    }
                }
                break;
            }
        case 'remove_node':
            {
                var { path: _path4 } = op;
                var _index3 = _path4[_path4.length - 1];
                var _parent3 = Node.parent(editor, _path4);
                _parent3.children.splice(_index3, 1);
                // Transform all the points in the value, but if the point was in the
                // node that was removed we need to update the range or remove it.
                if (selection) {
                    for (var [_point4, _key4] of Range.points(selection)){
                        var result = Point.transform(_point4, op);
                        if (selection != null && result != null) {
                            selection[_key4] = result;
                        } else {
                            var _prev = void 0;
                            var next = void 0;
                            for (var [n, p] of Node.texts(editor)){
                                if (Path.compare(p, _path4) === -1) {
                                    _prev = [
                                        n,
                                        p
                                    ];
                                } else {
                                    next = [
                                        n,
                                        p
                                    ];
                                    break;
                                }
                            }
                            var preferNext = false;
                            if (_prev && next) {
                                if (Path.equals(next[1], _path4)) {
                                    preferNext = !Path.hasPrevious(next[1]);
                                } else {
                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
                                }
                            }
                            if (_prev && !preferNext) {
                                _point4.path = _prev[1];
                                _point4.offset = _prev[0].text.length;
                            } else if (next) {
                                _point4.path = next[1];
                                _point4.offset = 0;
                            } else {
                                selection = null;
                            }
                        }
                    }
                }
                break;
            }
        case 'remove_text':
            {
                var { path: _path5, offset: _offset, text: _text } = op;
                if (_text.length === 0) break;
                var _node4 = Node.leaf(editor, _path5);
                var _before = _node4.text.slice(0, _offset);
                var _after = _node4.text.slice(_offset + _text.length);
                _node4.text = _before + _after;
                if (selection) {
                    for (var [_point5, _key5] of Range.points(selection)){
                        selection[_key5] = Point.transform(_point5, op);
                    }
                }
                break;
            }
        case 'set_node':
            {
                var { path: _path6, properties, newProperties } = op;
                if (_path6.length === 0) {
                    throw new Error("Cannot set properties on the root node!");
                }
                var _node5 = Node.get(editor, _path6);
                for(var _key6 in newProperties){
                    if (_key6 === 'children' || _key6 === 'text') {
                        throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
                    }
                    var value = newProperties[_key6];
                    if (value == null) {
                        delete _node5[_key6];
                    } else {
                        _node5[_key6] = value;
                    }
                }
                // properties that were previously defined, but are now missing, must be deleted
                for(var _key7 in properties){
                    if (!newProperties.hasOwnProperty(_key7)) {
                        delete _node5[_key7];
                    }
                }
                break;
            }
        case 'set_selection':
            {
                var { newProperties: _newProperties } = op;
                if (_newProperties == null) {
                    selection = _newProperties;
                } else {
                    if (selection == null) {
                        if (!Range.isRange(_newProperties)) {
                            throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
                        }
                        selection = _objectSpread$e({}, _newProperties);
                    }
                    for(var _key8 in _newProperties){
                        var _value = _newProperties[_key8];
                        if (_value == null) {
                            if (_key8 === 'anchor' || _key8 === 'focus') {
                                throw new Error("Cannot remove the \"".concat(_key8, "\" selection property"));
                            }
                            delete selection[_key8];
                        } else {
                            selection[_key8] = _value;
                        }
                    }
                }
                break;
            }
        case 'split_node':
            {
                var { path: _path7, position, properties: _properties } = op;
                if (_path7.length === 0) {
                    throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
                }
                var _node6 = Node.get(editor, _path7);
                var _parent4 = Node.parent(editor, _path7);
                var _index4 = _path7[_path7.length - 1];
                var newNode;
                if (Text.isText(_node6)) {
                    var _before2 = _node6.text.slice(0, position);
                    var _after2 = _node6.text.slice(position);
                    _node6.text = _before2;
                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
                        text: _after2
                    });
                } else {
                    var _before3 = _node6.children.slice(0, position);
                    var _after3 = _node6.children.slice(position);
                    _node6.children = _before3;
                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
                        children: _after3
                    });
                }
                _parent4.children.splice(_index4 + 1, 0, newNode);
                if (selection) {
                    for (var [_point6, _key9] of Range.points(selection)){
                        selection[_key9] = Point.transform(_point6, op);
                    }
                }
                break;
            }
    }
    return selection;
};
// eslint-disable-next-line no-redeclare
var GeneralTransforms = {
    transform (editor, op) {
        editor.children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDraft"])(editor.children);
        var selection = editor.selection && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDraft"])(editor.selection);
        try {
            selection = applyToDraft(editor, selection, op);
        } finally{
            editor.children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finishDraft"])(editor.children);
            if (selection) {
                editor.selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"])(selection) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finishDraft"])(selection) : selection;
            } else {
                editor.selection = null;
            }
        }
    }
};
// eslint-disable-next-line no-redeclare
var NodeTransforms = {
    insertNodes (editor, nodes, options) {
        editor.insertNodes(nodes, options);
    },
    liftNodes (editor, options) {
        editor.liftNodes(options);
    },
    mergeNodes (editor, options) {
        editor.mergeNodes(options);
    },
    moveNodes (editor, options) {
        editor.moveNodes(options);
    },
    removeNodes (editor, options) {
        editor.removeNodes(options);
    },
    setNodes (editor, props, options) {
        editor.setNodes(props, options);
    },
    splitNodes (editor, options) {
        editor.splitNodes(options);
    },
    unsetNodes (editor, props, options) {
        editor.unsetNodes(props, options);
    },
    unwrapNodes (editor, options) {
        editor.unwrapNodes(options);
    },
    wrapNodes (editor, element, options) {
        editor.wrapNodes(element, options);
    }
};
// eslint-disable-next-line no-redeclare
var SelectionTransforms = {
    collapse (editor, options) {
        editor.collapse(options);
    },
    deselect (editor) {
        editor.deselect();
    },
    move (editor, options) {
        editor.move(options);
    },
    select (editor, target) {
        editor.select(target);
    },
    setPoint (editor, props, options) {
        editor.setPoint(props, options);
    },
    setSelection (editor, props) {
        editor.setSelection(props);
    }
};
/*
  Custom deep equal comparison for Slate nodes.

  We don't need general purpose deep equality;
  Slate only supports plain values, Arrays, and nested objects.
  Complex values nested inside Arrays are not supported.

  Slate objects are designed to be serialised, so
  missing keys are deliberately normalised to undefined.
 */ var isDeepEqual = (node, another)=>{
    for(var key in node){
        var a = node[key];
        var b = another[key];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(a) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(b)) {
            if (!isDeepEqual(a, b)) return false;
        } else if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) return false;
            for(var i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
        } else if (a !== b) {
            return false;
        }
    }
    /*
    Deep object equality is only necessary in one direction; in the reverse direction
    we are only looking for keys that are missing.
    As above, undefined keys are normalised to missing.
  */ for(var _key in another){
        if (node[_key] === undefined && another[_key] !== undefined) {
            return false;
        }
    }
    return true;
};
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
var _excluded$4 = [
    "anchor",
    "focus"
];
function ownKeys$d(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$d(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$d(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// eslint-disable-next-line no-redeclare
var Range = {
    edges (range) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var { reverse = false } = options;
        var { anchor, focus } = range;
        return Range.isBackward(range) === reverse ? [
            anchor,
            focus
        ] : [
            focus,
            anchor
        ];
    },
    end (range) {
        var [, end] = Range.edges(range);
        return end;
    },
    equals (range, another) {
        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
    },
    surrounds (range, target) {
        var intersectionRange = Range.intersection(range, target);
        if (!intersectionRange) {
            return false;
        }
        return Range.equals(intersectionRange, target);
    },
    includes (range, target) {
        if (Range.isRange(target)) {
            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
                return true;
            }
            var [rs, re] = Range.edges(range);
            var [ts, te] = Range.edges(target);
            return Point.isBefore(rs, ts) && Point.isAfter(re, te);
        }
        var [start, end] = Range.edges(range);
        var isAfterStart = false;
        var isBeforeEnd = false;
        if (Point.isPoint(target)) {
            isAfterStart = Point.compare(target, start) >= 0;
            isBeforeEnd = Point.compare(target, end) <= 0;
        } else {
            isAfterStart = Path.compare(target, start.path) >= 0;
            isBeforeEnd = Path.compare(target, end.path) <= 0;
        }
        return isAfterStart && isBeforeEnd;
    },
    intersection (range, another) {
        var rest = _objectWithoutProperties(range, _excluded$4);
        var [s1, e1] = Range.edges(range);
        var [s2, e2] = Range.edges(another);
        var start = Point.isBefore(s1, s2) ? s2 : s1;
        var end = Point.isBefore(e1, e2) ? e1 : e2;
        if (Point.isBefore(end, start)) {
            return null;
        } else {
            return _objectSpread$d({
                anchor: start,
                focus: end
            }, rest);
        }
    },
    isBackward (range) {
        var { anchor, focus } = range;
        return Point.isAfter(anchor, focus);
    },
    isCollapsed (range) {
        var { anchor, focus } = range;
        return Point.equals(anchor, focus);
    },
    isExpanded (range) {
        return !Range.isCollapsed(range);
    },
    isForward (range) {
        return !Range.isBackward(range);
    },
    isRange (value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
    },
    *points (range) {
        yield [
            range.anchor,
            'anchor'
        ];
        yield [
            range.focus,
            'focus'
        ];
    },
    start (range) {
        var [start] = Range.edges(range);
        return start;
    },
    transform (range, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(range, (r)=>{
            if (r === null) {
                return null;
            }
            var { affinity = 'inward' } = options;
            var affinityAnchor;
            var affinityFocus;
            if (affinity === 'inward') {
                // If the range is collapsed, make sure to use the same affinity to
                // avoid the two points passing each other and expanding in the opposite
                // direction
                var isCollapsed = Range.isCollapsed(r);
                if (Range.isForward(r)) {
                    affinityAnchor = 'forward';
                    affinityFocus = isCollapsed ? affinityAnchor : 'backward';
                } else {
                    affinityAnchor = 'backward';
                    affinityFocus = isCollapsed ? affinityAnchor : 'forward';
                }
            } else if (affinity === 'outward') {
                if (Range.isForward(r)) {
                    affinityAnchor = 'backward';
                    affinityFocus = 'forward';
                } else {
                    affinityAnchor = 'forward';
                    affinityFocus = 'backward';
                }
            } else {
                affinityAnchor = affinity;
                affinityFocus = affinity;
            }
            var anchor = Point.transform(r.anchor, op, {
                affinity: affinityAnchor
            });
            var focus = Point.transform(r.focus, op, {
                affinity: affinityFocus
            });
            if (!anchor || !focus) {
                return null;
            }
            r.anchor = anchor;
            r.focus = focus;
        });
    }
};
/**
 * Shared the function with isElementType utility
 */ var isElement = (value)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);
};
// eslint-disable-next-line no-redeclare
var Element = {
    isAncestor (value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && Node.isNodeList(value.children);
    },
    isElement,
    isElementList (value) {
        return Array.isArray(value) && value.every((val)=>Element.isElement(val));
    },
    isElementProps (props) {
        return props.children !== undefined;
    },
    isElementType: function isElementType(value, elementVal) {
        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';
        return isElement(value) && value[elementKey] === elementVal;
    },
    matches (element, props) {
        for(var key in props){
            if (key === 'children') {
                continue;
            }
            if (element[key] !== props[key]) {
                return false;
            }
        }
        return true;
    }
};
var _excluded$3 = [
    "children"
], _excluded2$3 = [
    "text"
];
var IS_NODE_LIST_CACHE = new WeakMap();
// eslint-disable-next-line no-redeclare
var Node = {
    ancestor (root, path) {
        var node = Node.get(root, path);
        if (Text.isText(node)) {
            throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    ancestors (root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return function*() {
            for (var p of Path.ancestors(path, options)){
                var n = Node.ancestor(root, p);
                var entry = [
                    n,
                    p
                ];
                yield entry;
            }
        }();
    },
    child (root, index) {
        if (Text.isText(root)) {
            throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
        }
        var c = root.children[index];
        if (c == null) {
            throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(Scrubber.stringify(root)));
        }
        return c;
    },
    children (root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return function*() {
            var { reverse = false } = options;
            var ancestor = Node.ancestor(root, path);
            var { children } = ancestor;
            var index = reverse ? children.length - 1 : 0;
            while(reverse ? index >= 0 : index < children.length){
                var child = Node.child(ancestor, index);
                var childPath = path.concat(index);
                yield [
                    child,
                    childPath
                ];
                index = reverse ? index - 1 : index + 1;
            }
        }();
    },
    common (root, path, another) {
        var p = Path.common(path, another);
        var n = Node.get(root, p);
        return [
            n,
            p
        ];
    },
    descendant (root, path) {
        var node = Node.get(root, path);
        if (Editor.isEditor(node)) {
            throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    descendants (root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node.nodes(root, options)){
                if (path.length !== 0) {
                    // NOTE: we have to coerce here because checking the path's length does
                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    },
    elements (root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node.nodes(root, options)){
                if (Element.isElement(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    },
    extractProps (node) {
        if (Element.isAncestor(node)) {
            var properties = _objectWithoutProperties(node, _excluded$3);
            return properties;
        } else {
            var properties = _objectWithoutProperties(node, _excluded2$3);
            return properties;
        }
    },
    first (root, path) {
        var p = path.slice();
        var n = Node.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                n = n.children[0];
                p.push(0);
            }
        }
        return [
            n,
            p
        ];
    },
    fragment (root, range) {
        if (Text.isText(root)) {
            throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
        }
        var newRoot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])({
            children: root.children
        }, (r)=>{
            var [start, end] = Range.edges(range);
            var nodeEntries = Node.nodes(r, {
                reverse: true,
                pass: (_ref)=>{
                    var [, path] = _ref;
                    return !Range.includes(range, path);
                }
            });
            for (var [, path] of nodeEntries){
                if (!Range.includes(range, path)) {
                    var parent = Node.parent(r, path);
                    var index = path[path.length - 1];
                    parent.children.splice(index, 1);
                }
                if (Path.equals(path, end.path)) {
                    var leaf = Node.leaf(r, path);
                    leaf.text = leaf.text.slice(0, end.offset);
                }
                if (Path.equals(path, start.path)) {
                    var _leaf = Node.leaf(r, path);
                    _leaf.text = _leaf.text.slice(start.offset);
                }
            }
            if (Editor.isEditor(r)) {
                r.selection = null;
            }
        });
        return newRoot.children;
    },
    get (root, path) {
        var node = Node.getIf(root, path);
        if (node === undefined) {
            throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(Scrubber.stringify(root)));
        }
        return node;
    },
    getIf (root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                return;
            }
            node = node.children[p];
        }
        return node;
    },
    has (root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                return false;
            }
            node = node.children[p];
        }
        return true;
    },
    isNode (value) {
        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);
    },
    isNodeList (value) {
        if (!Array.isArray(value)) {
            return false;
        }
        var cachedResult = IS_NODE_LIST_CACHE.get(value);
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        var isNodeList = value.every((val)=>Node.isNode(val));
        IS_NODE_LIST_CACHE.set(value, isNodeList);
        return isNodeList;
    },
    last (root, path) {
        var p = path.slice();
        var n = Node.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                var i = n.children.length - 1;
                n = n.children[i];
                p.push(i);
            }
        }
        return [
            n,
            p
        ];
    },
    leaf (root, path) {
        var node = Node.get(root, path);
        if (!Text.isText(node)) {
            throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    levels (root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return function*() {
            for (var p of Path.levels(path, options)){
                var n = Node.get(root, p);
                yield [
                    n,
                    p
                ];
            }
        }();
    },
    matches (node, props) {
        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);
    },
    nodes (root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return function*() {
            var { pass, reverse = false } = options;
            var { from = [], to } = options;
            var visited = new Set();
            var p = [];
            var n = root;
            while(true){
                if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
                    break;
                }
                if (!visited.has(n)) {
                    yield [
                        n,
                        p
                    ];
                }
                // If we're allowed to go downward and we haven't descended yet, do.
                if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([
                    n,
                    p
                ]) === false)) {
                    visited.add(n);
                    var nextIndex = reverse ? n.children.length - 1 : 0;
                    if (Path.isAncestor(p, from)) {
                        nextIndex = from[p.length];
                    }
                    p = p.concat(nextIndex);
                    n = Node.get(root, p);
                    continue;
                }
                // If we're at the root and we can't go down, we're done.
                if (p.length === 0) {
                    break;
                }
                // If we're going forward...
                if (!reverse) {
                    var newPath = Path.next(p);
                    if (Node.has(root, newPath)) {
                        p = newPath;
                        n = Node.get(root, p);
                        continue;
                    }
                }
                // If we're going backward...
                if (reverse && p[p.length - 1] !== 0) {
                    var _newPath = Path.previous(p);
                    p = _newPath;
                    n = Node.get(root, p);
                    continue;
                }
                // Otherwise we're going upward...
                p = Path.parent(p);
                n = Node.get(root, p);
                visited.add(n);
            }
        }();
    },
    parent (root, path) {
        var parentPath = Path.parent(path);
        var p = Node.get(root, parentPath);
        if (Text.isText(p)) {
            throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
        }
        return p;
    },
    string (node) {
        if (Text.isText(node)) {
            return node.text;
        } else {
            return node.children.map(Node.string).join('');
        }
    },
    texts (root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node.nodes(root, options)){
                if (Text.isText(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    }
};
function ownKeys$c(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$c(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$c(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// eslint-disable-next-line no-redeclare
var Operation = {
    isNodeOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith('_node');
    },
    isOperation (value) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value)) {
            return false;
        }
        switch(value.type){
            case 'insert_node':
                return Path.isPath(value.path) && Node.isNode(value.node);
            case 'insert_text':
                return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);
            case 'merge_node':
                return typeof value.position === 'number' && Path.isPath(value.path) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.properties);
            case 'move_node':
                return Path.isPath(value.path) && Path.isPath(value.newPath);
            case 'remove_node':
                return Path.isPath(value.path) && Node.isNode(value.node);
            case 'remove_text':
                return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);
            case 'set_node':
                return Path.isPath(value.path) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.properties) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.newProperties);
            case 'set_selection':
                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.properties) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.newProperties);
            case 'split_node':
                return Path.isPath(value.path) && typeof value.position === 'number' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.properties);
            default:
                return false;
        }
    },
    isOperationList (value) {
        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));
    },
    isSelectionOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith('_selection');
    },
    isTextOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith('_text');
    },
    inverse (op) {
        switch(op.type){
            case 'insert_node':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'remove_node'
                    });
                }
            case 'insert_text':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'remove_text'
                    });
                }
            case 'merge_node':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'split_node',
                        path: Path.previous(op.path)
                    });
                }
            case 'move_node':
                {
                    var { newPath, path } = op;
                    // PERF: in this case the move operation is a no-op anyways.
                    if (Path.equals(newPath, path)) {
                        return op;
                    }
                    // If the move happens completely within a single parent the path and
                    // newPath are stable with respect to each other.
                    if (Path.isSibling(path, newPath)) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            path: newPath,
                            newPath: path
                        });
                    }
                    // If the move does not happen within a single parent it is possible
                    // for the move to impact the true path to the location where the node
                    // was removed from and where it was inserted. We have to adjust for this
                    // and find the original path. We can accomplish this (only in non-sibling)
                    // moves by looking at the impact of the move operation on the node
                    // after the original move path.
                    var inversePath = Path.transform(path, op);
                    var inverseNewPath = Path.transform(Path.next(path), op);
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        path: inversePath,
                        newPath: inverseNewPath
                    });
                }
            case 'remove_node':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'insert_node'
                    });
                }
            case 'remove_text':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'insert_text'
                    });
                }
            case 'set_node':
                {
                    var { properties, newProperties } = op;
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        properties: newProperties,
                        newProperties: properties
                    });
                }
            case 'set_selection':
                {
                    var { properties: _properties, newProperties: _newProperties } = op;
                    if (_properties == null) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: _newProperties,
                            newProperties: null
                        });
                    } else if (_newProperties == null) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: null,
                            newProperties: _properties
                        });
                    } else {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: _newProperties,
                            newProperties: _properties
                        });
                    }
                }
            case 'split_node':
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: 'merge_node',
                        path: Path.next(op.path)
                    });
                }
        }
    }
};
var IS_EDITOR_CACHE = new WeakMap();
var isEditor = (value)=>{
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);
    if (cachedIsEditor !== undefined) {
        return cachedIsEditor;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value)) {
        return false;
    }
    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor);
    return isEditor;
};
// eslint-disable-next-line no-redeclare
var Editor = {
    above (editor, options) {
        return editor.above(options);
    },
    addMark (editor, key, value) {
        editor.addMark(key, value);
    },
    after (editor, at, options) {
        return editor.after(at, options);
    },
    before (editor, at, options) {
        return editor.before(at, options);
    },
    deleteBackward (editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var { unit = 'character' } = options;
        editor.deleteBackward(unit);
    },
    deleteForward (editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var { unit = 'character' } = options;
        editor.deleteForward(unit);
    },
    deleteFragment (editor, options) {
        editor.deleteFragment(options);
    },
    edges (editor, at) {
        return editor.edges(at);
    },
    elementReadOnly (editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return editor.elementReadOnly(options);
    },
    end (editor, at) {
        return editor.end(at);
    },
    first (editor, at) {
        return editor.first(at);
    },
    fragment (editor, at) {
        return editor.fragment(at);
    },
    hasBlocks (editor, element) {
        return editor.hasBlocks(element);
    },
    hasInlines (editor, element) {
        return editor.hasInlines(element);
    },
    hasPath (editor, path) {
        return editor.hasPath(path);
    },
    hasTexts (editor, element) {
        return editor.hasTexts(element);
    },
    insertBreak (editor) {
        editor.insertBreak();
    },
    insertFragment (editor, fragment, options) {
        editor.insertFragment(fragment, options);
    },
    insertNode (editor, node) {
        editor.insertNode(node);
    },
    insertSoftBreak (editor) {
        editor.insertSoftBreak();
    },
    insertText (editor, text) {
        editor.insertText(text);
    },
    isBlock (editor, value) {
        return editor.isBlock(value);
    },
    isEdge (editor, point, at) {
        return editor.isEdge(point, at);
    },
    isEditor (value) {
        return isEditor(value);
    },
    isElementReadOnly (editor, element) {
        return editor.isElementReadOnly(element);
    },
    isEmpty (editor, element) {
        return editor.isEmpty(element);
    },
    isEnd (editor, point, at) {
        return editor.isEnd(point, at);
    },
    isInline (editor, value) {
        return editor.isInline(value);
    },
    isNormalizing (editor) {
        return editor.isNormalizing();
    },
    isSelectable (editor, value) {
        return editor.isSelectable(value);
    },
    isStart (editor, point, at) {
        return editor.isStart(point, at);
    },
    isVoid (editor, value) {
        return editor.isVoid(value);
    },
    last (editor, at) {
        return editor.last(at);
    },
    leaf (editor, at, options) {
        return editor.leaf(at, options);
    },
    levels (editor, options) {
        return editor.levels(options);
    },
    marks (editor) {
        return editor.getMarks();
    },
    next (editor, options) {
        return editor.next(options);
    },
    node (editor, at, options) {
        return editor.node(at, options);
    },
    nodes (editor, options) {
        return editor.nodes(options);
    },
    normalize (editor, options) {
        editor.normalize(options);
    },
    parent (editor, at, options) {
        return editor.parent(at, options);
    },
    path (editor, at, options) {
        return editor.path(at, options);
    },
    pathRef (editor, path, options) {
        return editor.pathRef(path, options);
    },
    pathRefs (editor) {
        return editor.pathRefs();
    },
    point (editor, at, options) {
        return editor.point(at, options);
    },
    pointRef (editor, point, options) {
        return editor.pointRef(point, options);
    },
    pointRefs (editor) {
        return editor.pointRefs();
    },
    positions (editor, options) {
        return editor.positions(options);
    },
    previous (editor, options) {
        return editor.previous(options);
    },
    range (editor, at, to) {
        return editor.range(at, to);
    },
    rangeRef (editor, range, options) {
        return editor.rangeRef(range, options);
    },
    rangeRefs (editor) {
        return editor.rangeRefs();
    },
    removeMark (editor, key) {
        editor.removeMark(key);
    },
    setNormalizing (editor, isNormalizing) {
        editor.setNormalizing(isNormalizing);
    },
    start (editor, at) {
        return editor.start(at);
    },
    string (editor, at, options) {
        return editor.string(at, options);
    },
    unhangRange (editor, range, options) {
        return editor.unhangRange(range, options);
    },
    void (editor, options) {
        return editor.void(options);
    },
    withoutNormalizing (editor, fn) {
        editor.withoutNormalizing(fn);
    },
    shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode)=>{
        return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);
    }
};
// eslint-disable-next-line no-redeclare
var Location = {
    isLocation (value) {
        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);
    }
};
// eslint-disable-next-line no-redeclare
var Span = {
    isSpan (value) {
        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
    }
};
function ownKeys$b(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$b(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$b(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// eslint-disable-next-line no-redeclare
var Point = {
    compare (point, another) {
        var result = Path.compare(point.path, another.path);
        if (result === 0) {
            if (point.offset < another.offset) return -1;
            if (point.offset > another.offset) return 1;
            return 0;
        }
        return result;
    },
    isAfter (point, another) {
        return Point.compare(point, another) === 1;
    },
    isBefore (point, another) {
        return Point.compare(point, another) === -1;
    },
    equals (point, another) {
        // PERF: ensure the offsets are equal first since they are cheaper to check.
        return point.offset === another.offset && Path.equals(point.path, another.path);
    },
    isPoint (value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && typeof value.offset === 'number' && Path.isPath(value.path);
    },
    transform (point, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(point, (p)=>{
            if (p === null) {
                return null;
            }
            var { affinity = 'forward' } = options;
            var { path, offset } = p;
            switch(op.type){
                case 'insert_node':
                case 'move_node':
                    {
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case 'insert_text':
                    {
                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {
                            p.offset += op.text.length;
                        }
                        break;
                    }
                case 'merge_node':
                    {
                        if (Path.equals(op.path, path)) {
                            p.offset += op.position;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case 'remove_text':
                    {
                        if (Path.equals(op.path, path) && op.offset <= offset) {
                            p.offset -= Math.min(offset - op.offset, op.text.length);
                        }
                        break;
                    }
                case 'remove_node':
                    {
                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
                            return null;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case 'split_node':
                    {
                        if (Path.equals(op.path, path)) {
                            if (op.position === offset && affinity == null) {
                                return null;
                            } else if (op.position < offset || op.position === offset && affinity === 'forward') {
                                p.offset -= op.position;
                                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {
                                    affinity: 'forward'
                                }));
                            }
                        } else {
                            p.path = Path.transform(path, op, options);
                        }
                        break;
                    }
            }
        });
    }
};
var _scrubber = undefined;
/**
 * This interface implements a stringify() function, which is used by Slate
 * internally when generating exceptions containing end user data. Developers
 * using Slate may call Scrubber.setScrubber() to alter the behavior of this
 * stringify() function.
 *
 * For example, to prevent the cleartext logging of 'text' fields within Nodes:
 *
 *    import { Scrubber } from 'slate';
 *    Scrubber.setScrubber((key, val) => {
 *      if (key === 'text') return '...scrubbed...'
 *      return val
 *    });
 *
 */ // eslint-disable-next-line no-redeclare
var Scrubber = {
    setScrubber (scrubber) {
        _scrubber = scrubber;
    },
    stringify (value) {
        return JSON.stringify(value, _scrubber);
    }
};
var _excluded$2 = [
    "text"
], _excluded2$2 = [
    "anchor",
    "focus",
    "merge"
];
function ownKeys$a(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$a(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$a(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// eslint-disable-next-line no-redeclare
var Text = {
    equals (text, another) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var { loose = false } = options;
        function omitText(obj) {
            var rest = _objectWithoutProperties(obj, _excluded$2);
            return rest;
        }
        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
    },
    isText (value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && typeof value.text === 'string';
    },
    isTextList (value) {
        return Array.isArray(value) && value.every((val)=>Text.isText(val));
    },
    isTextProps (props) {
        return props.text !== undefined;
    },
    matches (text, props) {
        for(var key in props){
            if (key === 'text') {
                continue;
            }
            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
                return false;
            }
        }
        return true;
    },
    decorations (node, decorations) {
        var leaves = [
            _objectSpread$a({}, node)
        ];
        for (var dec of decorations){
            var { anchor, focus, merge: mergeDecoration } = dec, rest = _objectWithoutProperties(dec, _excluded2$2);
            var [start, end] = Range.edges(dec);
            var next = [];
            var leafEnd = 0;
            var decorationStart = start.offset;
            var decorationEnd = end.offset;
            var merge = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;
            for (var leaf of leaves){
                var { length } = leaf.text;
                var leafStart = leafEnd;
                leafEnd += length;
                // If the range encompasses the entire leaf, add the range.
                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
                    merge(leaf, rest);
                    next.push(leaf);
                    continue;
                }
                // If the range expanded and match the leaf, or starts after, or ends before it, continue.
                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
                    next.push(leaf);
                    continue;
                }
                // Otherwise we need to split the leaf, at the start, end, or both,
                // and add the range to the middle intersecting section. Do the end
                // split first since we don't need to update the offset that way.
                var middle = leaf;
                var before = void 0;
                var after = void 0;
                if (decorationEnd < leafEnd) {
                    var off = decorationEnd - leafStart;
                    after = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(off)
                    });
                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(0, off)
                    });
                }
                if (decorationStart > leafStart) {
                    var _off = decorationStart - leafStart;
                    before = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(0, _off)
                    });
                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(_off)
                    });
                }
                merge(middle, rest);
                if (before) {
                    next.push(before);
                }
                next.push(middle);
                if (after) {
                    next.push(after);
                }
            }
            leaves = next;
        }
        return leaves;
    }
};
/**
 * Get the default location to insert content into the editor.
 * By default, use the selection as the target location. But if there is
 * no selection, insert at the end of the document since that is such a
 * common use case when inserting from a non-selected state.
 */ var getDefaultInsertLocation = (editor)=>{
    if (editor.selection) {
        return editor.selection;
    } else if (editor.children.length > 0) {
        return Editor.end(editor, []);
    } else {
        return [
            0
        ];
    }
};
var matchPath = (editor, path)=>{
    var [node] = Editor.node(editor, path);
    return (n)=>n === node;
};
// Character (grapheme cluster) boundaries are determined according to
// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].
//
// References:
//
// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table
// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt
// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html
// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt
/**
 * Get the distance to the end of the first character in a string of text.
 */ var getCharacterDistance = function getCharacterDistance(str) {
    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var isLTR = !isRTL;
    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
    var left = CodepointType.None;
    var right = CodepointType.None;
    var distance = 0;
    // Evaluation of these conditions are deferred.
    var gb11 = null; // Is GB11 applicable?
    var gb12Or13 = null; // Is GB12 or GB13 applicable?
    for (var char of codepoints){
        var code = char.codePointAt(0);
        if (!code) break;
        var type = getCodepointType(char, code);
        [left, right] = isLTR ? [
            right,
            type
        ] : [
            type,
            left
        ];
        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
            if (isLTR) {
                gb11 = endsWithEmojiZWJ(str.substring(0, distance));
            } else {
                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
            }
            if (!gb11) break;
        }
        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
            if (gb12Or13 !== null) {
                gb12Or13 = !gb12Or13;
            } else {
                if (isLTR) {
                    gb12Or13 = true;
                } else {
                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
                }
            }
            if (!gb12Or13) break;
        }
        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
            break;
        }
        distance += char.length;
    }
    return distance || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
/**
 * Get the distance to the end of the first word in a string of text.
 */ var getWordDistance = function getWordDistance(text) {
    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var dist = 0;
    var started = false;
    while(text.length > 0){
        var charDist = getCharacterDistance(text, isRTL);
        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);
        if (isWordCharacter(char, remaining, isRTL)) {
            started = true;
            dist += charDist;
        } else if (!started) {
            dist += charDist;
        } else {
            break;
        }
        text = remaining;
    }
    return dist;
};
/**
 * Split a string in two parts at a given distance starting from the end when
 * `isRTL` is set to `true`.
 */ var splitByCharacterDistance = (str, dist, isRTL)=>{
    if (isRTL) {
        var at = str.length - dist;
        return [
            str.slice(at, str.length),
            str.slice(0, at)
        ];
    }
    return [
        str.slice(0, dist),
        str.slice(dist)
    ];
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */ var isWordCharacter = function isWordCharacter(char, remaining) {
    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (SPACE.test(char)) {
        return false;
    }
    // Chameleons count as word characters as long as they're in a word, so
    // recurse to see if the next one is a word character or not.
    if (CHAMELEON.test(char)) {
        var charDist = getCharacterDistance(remaining, isRTL);
        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {
            return true;
        }
    }
    if (PUNCTUATION.test(char)) {
        return false;
    }
    return true;
};
/**
 * Iterate on codepoints from right to left.
 */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {
    var end = str.length - 1;
    for(var i = 0; i < str.length; i++){
        var char1 = str.charAt(end - i);
        if (isLowSurrogate(char1.charCodeAt(0))) {
            var char2 = str.charAt(end - i - 1);
            if (isHighSurrogate(char2.charCodeAt(0))) {
                yield char2 + char1;
                i++;
                continue;
            }
        }
        yield char1;
    }
};
/**
 * Is `charCode` a high surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */ var isHighSurrogate = (charCode)=>{
    return charCode >= 0xd800 && charCode <= 0xdbff;
};
/**
 * Is `charCode` a low surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */ var isLowSurrogate = (charCode)=>{
    return charCode >= 0xdc00 && charCode <= 0xdfff;
};
var CodepointType;
(function(CodepointType) {
    CodepointType[CodepointType["None"] = 0] = "None";
    CodepointType[CodepointType["Extend"] = 1] = "Extend";
    CodepointType[CodepointType["ZWJ"] = 2] = "ZWJ";
    CodepointType[CodepointType["RI"] = 4] = "RI";
    CodepointType[CodepointType["Prepend"] = 8] = "Prepend";
    CodepointType[CodepointType["SpacingMark"] = 16] = "SpacingMark";
    CodepointType[CodepointType["L"] = 32] = "L";
    CodepointType[CodepointType["V"] = 64] = "V";
    CodepointType[CodepointType["T"] = 128] = "T";
    CodepointType[CodepointType["LV"] = 256] = "LV";
    CodepointType[CodepointType["LVT"] = 512] = "LVT";
    CodepointType[CodepointType["ExtPict"] = 1024] = "ExtPict";
    CodepointType[CodepointType["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char, code)=>{
    var type = CodepointType.Any;
    if (char.search(reExtend) !== -1) {
        type |= CodepointType.Extend;
    }
    if (code === 0x200d) {
        type |= CodepointType.ZWJ;
    }
    if (code >= 0x1f1e6 && code <= 0x1f1ff) {
        type |= CodepointType.RI;
    }
    if (char.search(rePrepend) !== -1) {
        type |= CodepointType.Prepend;
    }
    if (char.search(reSpacingMark) !== -1) {
        type |= CodepointType.SpacingMark;
    }
    if (char.search(reL) !== -1) {
        type |= CodepointType.L;
    }
    if (char.search(reV) !== -1) {
        type |= CodepointType.V;
    }
    if (char.search(reT) !== -1) {
        type |= CodepointType.T;
    }
    if (char.search(reLV) !== -1) {
        type |= CodepointType.LV;
    }
    if (char.search(reLVT) !== -1) {
        type |= CodepointType.LVT;
    }
    if (char.search(reExtPict) !== -1) {
        type |= CodepointType.ExtPict;
    }
    return type;
};
function intersects(x, y) {
    return (x & y) !== 0;
}
var NonBoundaryPairs = [
    // GB6
    [
        CodepointType.L,
        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT
    ],
    // GB7
    [
        CodepointType.LV | CodepointType.V,
        CodepointType.V | CodepointType.T
    ],
    // GB8
    [
        CodepointType.LVT | CodepointType.T,
        CodepointType.T
    ],
    // GB9
    [
        CodepointType.Any,
        CodepointType.Extend | CodepointType.ZWJ
    ],
    // GB9a
    [
        CodepointType.Any,
        CodepointType.SpacingMark
    ],
    // GB9b
    [
        CodepointType.Prepend,
        CodepointType.Any
    ],
    // GB11
    [
        CodepointType.ZWJ,
        CodepointType.ExtPict
    ],
    // GB12 and GB13
    [
        CodepointType.RI,
        CodepointType.RI
    ]
];
function isBoundaryPair(left, right) {
    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str)=>{
    return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str)=>{
    var match = str.match(endingRIs);
    if (match === null) {
        return false;
    } else {
        // A RI is represented by a surrogate pair.
        var numRIs = match[0].length / 2;
        return numRIs % 2 === 1;
    }
};
// eslint-disable-next-line no-redeclare
var TextTransforms = {
    delete (editor, options) {
        editor.delete(options);
    },
    insertFragment (editor, fragment, options) {
        editor.insertFragment(fragment, options);
    },
    insertText (editor, text) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, ()=>{
            var { voids = false } = options;
            var { at = getDefaultInsertLocation(editor) } = options;
            if (Path.isPath(at)) {
                at = Editor.range(editor, at);
            }
            if (Range.isRange(at)) {
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var end = Range.end(at);
                    if (!voids && Editor.void(editor, {
                        at: end
                    })) {
                        return;
                    }
                    var start = Range.start(at);
                    var startRef = Editor.pointRef(editor, start);
                    var endRef = Editor.pointRef(editor, end);
                    Transforms.delete(editor, {
                        at,
                        voids
                    });
                    var startPoint = startRef.unref();
                    var endPoint = endRef.unref();
                    at = startPoint || endPoint;
                    Transforms.setSelection(editor, {
                        anchor: at,
                        focus: at
                    });
                }
            }
            if (!voids && Editor.void(editor, {
                at
            }) || Editor.elementReadOnly(editor, {
                at
            })) {
                return;
            }
            var { path, offset } = at;
            if (text.length > 0) editor.apply({
                type: 'insert_text',
                path,
                offset,
                text
            });
        });
    }
};
function ownKeys$9(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$9(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$9(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
// perf
var BATCHING_DIRTY_PATHS = new WeakMap();
var isBatchingDirtyPaths = (editor)=>{
    return BATCHING_DIRTY_PATHS.get(editor) || false;
};
var batchDirtyPaths = (editor, fn, update)=>{
    var value = BATCHING_DIRTY_PATHS.get(editor) || false;
    BATCHING_DIRTY_PATHS.set(editor, true);
    try {
        fn();
        update();
    } finally{
        BATCHING_DIRTY_PATHS.set(editor, value);
    }
};
/**
 * update editor dirty paths
 *
 * @param newDirtyPaths: Path[]; new dirty paths
 * @param transform: (p: Path) => Path | null; how to transform existing dirty paths
 */ function updateDirtyPaths(editor, newDirtyPaths, transform) {
    var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
    var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();
    var dirtyPaths;
    var dirtyPathKeys;
    var add = (path)=>{
        if (path) {
            var key = path.join(',');
            if (!dirtyPathKeys.has(key)) {
                dirtyPathKeys.add(key);
                dirtyPaths.push(path);
            }
        }
    };
    if (transform) {
        dirtyPaths = [];
        dirtyPathKeys = new Set();
        for (var path of oldDirtyPaths){
            var newPath = transform(path);
            add(newPath);
        }
    } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
    }
    for (var _path of newDirtyPaths){
        add(_path);
    }
    DIRTY_PATHS.set(editor, dirtyPaths);
    DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
}
var apply = (editor, op)=>{
    for (var ref of Editor.pathRefs(editor)){
        PathRef.transform(ref, op);
    }
    for (var _ref of Editor.pointRefs(editor)){
        PointRef.transform(_ref, op);
    }
    for (var _ref2 of Editor.rangeRefs(editor)){
        RangeRef.transform(_ref2, op);
    }
    // update dirty paths
    if (!isBatchingDirtyPaths(editor)) {
        var transform = Path.operationCanTransformPath(op) ? (p)=>Path.transform(p, op) : undefined;
        updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);
    }
    Transforms.transform(editor, op);
    editor.operations.push(op);
    Editor.normalize(editor, {
        operation: op
    });
    // Clear any formats applied to the cursor if the selection changes.
    if (op.type === 'set_selection') {
        editor.marks = null;
    }
    if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(()=>{
            FLUSHING.set(editor, false);
            editor.onChange({
                operation: op
            });
            editor.operations = [];
        });
    }
};
/**
 * Get the "dirty" paths generated from an operation.
 */ var getDirtyPaths = (editor, op)=>{
    switch(op.type){
        case 'insert_text':
        case 'remove_text':
        case 'set_node':
            {
                var { path } = op;
                return Path.levels(path);
            }
        case 'insert_node':
            {
                var { node, path: _path } = op;
                var levels = Path.levels(_path);
                var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref)=>{
                    var [, p] = _ref;
                    return _path.concat(p);
                });
                return [
                    ...levels,
                    ...descendants
                ];
            }
        case 'merge_node':
            {
                var { path: _path2 } = op;
                var ancestors = Path.ancestors(_path2);
                var previousPath = Path.previous(_path2);
                return [
                    ...ancestors,
                    previousPath
                ];
            }
        case 'move_node':
            {
                var { path: _path3, newPath } = op;
                if (Path.equals(_path3, newPath)) {
                    return [];
                }
                var oldAncestors = [];
                var newAncestors = [];
                for (var ancestor of Path.ancestors(_path3)){
                    var p = Path.transform(ancestor, op);
                    oldAncestors.push(p);
                }
                for (var _ancestor of Path.ancestors(newPath)){
                    var _p = Path.transform(_ancestor, op);
                    newAncestors.push(_p);
                }
                var newParent = newAncestors[newAncestors.length - 1];
                var newIndex = newPath[newPath.length - 1];
                var resultPath = newParent.concat(newIndex);
                return [
                    ...oldAncestors,
                    ...newAncestors,
                    resultPath
                ];
            }
        case 'remove_node':
            {
                var { path: _path4 } = op;
                var _ancestors = Path.ancestors(_path4);
                return [
                    ..._ancestors
                ];
            }
        case 'split_node':
            {
                var { path: _path5 } = op;
                var _levels = Path.levels(_path5);
                var nextPath = Path.next(_path5);
                return [
                    ..._levels,
                    nextPath
                ];
            }
        default:
            {
                return [];
            }
    }
};
var getFragment = (editor)=>{
    var { selection } = editor;
    if (selection) {
        return Node.fragment(editor, selection);
    }
    return [];
};
var normalizeNode = (editor, entry)=>{
    var [node, path] = entry;
    // There are no core normalizations for text nodes.
    if (Text.isText(node)) {
        return;
    }
    // Ensure that block and inline nodes have at least one text child.
    if (Element.isElement(node) && node.children.length === 0) {
        var child = {
            text: ''
        };
        Transforms.insertNodes(editor, child, {
            at: path.concat(0),
            voids: true
        });
        return;
    }
    // Determine whether the node should have block or inline children.
    var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));
    // Since we'll be applying operations while iterating, keep track of an
    // index that accounts for any added/removed nodes.
    var n = 0;
    for(var i = 0; i < node.children.length; i++, n++){
        var currentNode = Node.get(editor, path);
        if (Text.isText(currentNode)) continue;
        var _child = currentNode.children[n];
        var prev = currentNode.children[n - 1];
        var isLast = i === node.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);
        // Only allow block nodes in the top-level children and parent blocks
        // that only contain block nodes. Similarly, only allow inline nodes in
        // other inline nodes, or parent blocks that only contain inlines and
        // text.
        if (isInlineOrText !== shouldHaveInlines) {
            if (isInlineOrText) {
                Transforms.removeNodes(editor, {
                    at: path.concat(n),
                    voids: true
                });
            } else {
                Transforms.unwrapNodes(editor, {
                    at: path.concat(n),
                    voids: true
                });
            }
            n--;
        } else if (Element.isElement(_child)) {
            // Ensure that inline nodes are surrounded by text nodes.
            if (editor.isInline(_child)) {
                if (prev == null || !Text.isText(prev)) {
                    var newChild = {
                        text: ''
                    };
                    Transforms.insertNodes(editor, newChild, {
                        at: path.concat(n),
                        voids: true
                    });
                    n++;
                } else if (isLast) {
                    var _newChild = {
                        text: ''
                    };
                    Transforms.insertNodes(editor, _newChild, {
                        at: path.concat(n + 1),
                        voids: true
                    });
                    n++;
                }
            }
        } else {
            // If the child is not a text node, and doesn't have a `children` field,
            // then we have an invalid node that will upset slate.
            //
            // eg: `{ type: 'some_node' }`.
            //
            // To prevent slate from breaking, we can add the `children` field,
            // and now that it is valid, we can to many more operations easily,
            // such as extend normalizers to fix erronous structure.
            if (!Text.isText(_child) && !('children' in _child)) {
                var elementChild = _child;
                elementChild.children = [];
            }
            // Merge adjacent text nodes that are empty or match.
            if (prev != null && Text.isText(prev)) {
                if (Text.equals(_child, prev, {
                    loose: true
                })) {
                    Transforms.mergeNodes(editor, {
                        at: path.concat(n),
                        voids: true
                    });
                    n--;
                } else if (prev.text === '') {
                    Transforms.removeNodes(editor, {
                        at: path.concat(n - 1),
                        voids: true
                    });
                    n--;
                } else if (_child.text === '') {
                    Transforms.removeNodes(editor, {
                        at: path.concat(n),
                        voids: true
                    });
                    n--;
                }
            }
        }
    }
};
var shouldNormalize = (editor, _ref)=>{
    var { iteration, initialDirtyPathsLength } = _ref;
    var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?
    if (iteration > maxIterations) {
        throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
    }
    return true;
};
var above = function above(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { voids = false, mode = 'lowest', at = editor.selection, match } = options;
    if (!at) {
        return;
    }
    var path = Editor.path(editor, at);
    var reverse = mode === 'lowest';
    for (var [n, p] of Editor.levels(editor, {
        at: path,
        voids,
        match,
        reverse
    })){
        if (Text.isText(n)) continue;
        if (Range.isRange(at)) {
            if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {
                return [
                    n,
                    p
                ];
            }
        } else {
            if (!Path.equals(path, p)) {
                return [
                    n,
                    p
                ];
            }
        }
    }
};
function ownKeys$8(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$8(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$8(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var addMark = (editor, key, value)=>{
    var { selection } = editor;
    if (selection) {
        var match = (node, path)=>{
            if (!Text.isText(node)) {
                return false; // marks can only be applied to text
            }
            var [parentNode, parentPath] = Editor.parent(editor, path);
            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
            var [selectedNode, selectedPath] = Editor.node(editor, selection);
            if (selectedNode && match(selectedNode, selectedPath)) {
                var [parentNode] = Editor.parent(editor, selectedPath);
                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
            }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
            Transforms.setNodes(editor, {
                [key]: value
            }, {
                match,
                split: true,
                voids: true
            });
        } else {
            var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {
                [key]: value
            });
            editor.marks = marks;
            if (!FLUSHING.get(editor)) {
                editor.onChange();
            }
        }
    }
};
function ownKeys$7(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$7(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$7(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var after = function after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
        edge: 'end'
    });
    var focus = Editor.end(editor, []);
    var range = {
        anchor,
        focus
    };
    var { distance = 1 } = options;
    var d = 0;
    var target;
    for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {
        at: range
    }))){
        if (d > distance) {
            break;
        }
        if (d !== 0) {
            target = p;
        }
        d++;
    }
    return target;
};
function ownKeys$6(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$6(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$6(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var before = function before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
        edge: 'start'
    });
    var range = {
        anchor,
        focus
    };
    var { distance = 1 } = options;
    var d = 0;
    var target;
    for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {
        at: range,
        reverse: true
    }))){
        if (d > distance) {
            break;
        }
        if (d !== 0) {
            target = p;
        }
        d++;
    }
    return target;
};
var deleteBackward = (editor, unit)=>{
    var { selection } = editor;
    if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
            unit,
            reverse: true
        });
    }
};
var deleteForward = (editor, unit)=>{
    var { selection } = editor;
    if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
            unit
        });
    }
};
var deleteFragment = function deleteFragment(editor) {
    var { direction = 'forward' } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { selection } = editor;
    if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
            reverse: direction === 'backward'
        });
    }
};
var edges = (editor, at)=>{
    return [
        Editor.start(editor, at),
        Editor.end(editor, at)
    ];
};
function ownKeys$5(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$5(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var elementReadOnly = function elementReadOnly(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {
        match: (n)=>Element.isElement(n) && Editor.isElementReadOnly(editor, n)
    }));
};
var end = (editor, at)=>{
    return Editor.point(editor, at, {
        edge: 'end'
    });
};
var first = (editor, at)=>{
    var path = Editor.path(editor, at, {
        edge: 'start'
    });
    return Editor.node(editor, path);
};
var fragment = (editor, at)=>{
    var range = Editor.range(editor, at);
    return Node.fragment(editor, range);
};
function ownKeys$4(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$4(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var getVoid = function getVoid(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {
        match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)
    }));
};
var hasBlocks = (editor, element)=>{
    return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));
};
var hasInlines = (editor, element)=>{
    return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));
};
var hasPath = (editor, path)=>{
    return Node.has(editor, path);
};
var hasTexts = (editor, element)=>{
    return element.children.every((n)=>Text.isText(n));
};
var insertBreak = (editor)=>{
    Transforms.splitNodes(editor, {
        always: true
    });
};
var insertNode = (editor, node, options)=>{
    Transforms.insertNodes(editor, node, options);
};
var insertSoftBreak = (editor)=>{
    Transforms.splitNodes(editor, {
        always: true
    });
};
function ownKeys$3(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$3(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var insertText = function insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { selection, marks } = editor;
    if (selection) {
        if (marks) {
            var node = _objectSpread$3({
                text
            }, marks);
            Transforms.insertNodes(editor, node, {
                at: options.at,
                voids: options.voids
            });
        } else {
            Transforms.insertText(editor, text, options);
        }
        editor.marks = null;
    }
};
var isBlock = (editor, value)=>{
    return !editor.isInline(value);
};
var isEdge = (editor, point, at)=>{
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
};
var isEmpty = (editor, element)=>{
    var { children } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);
};
var isEnd = (editor, point, at)=>{
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
};
var isNormalizing = (editor)=>{
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === undefined ? true : isNormalizing;
};
var isStart = (editor, point, at)=>{
    // PERF: If the offset isn't `0` we know it's not the start.
    if (point.offset !== 0) {
        return false;
    }
    var start = Editor.start(editor, at);
    return Point.equals(point, start);
};
var last = (editor, at)=>{
    var path = Editor.path(editor, at, {
        edge: 'end'
    });
    return Editor.node(editor, path);
};
var leaf = function leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.leaf(editor, path);
    return [
        node,
        path
    ];
};
function levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function*() {
        var { at = editor.selection, reverse = false, voids = false } = options;
        var { match } = options;
        if (match == null) {
            match = ()=>true;
        }
        if (!at) {
            return;
        }
        var levels = [];
        var path = Editor.path(editor, at);
        for (var [n, p] of Node.levels(editor, path)){
            if (!match(n, p)) {
                continue;
            }
            levels.push([
                n,
                p
            ]);
            if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {
                break;
            }
        }
        if (reverse) {
            levels.reverse();
        }
        yield* levels;
    }();
}
var _excluded$1 = [
    "text"
], _excluded2$1 = [
    "text"
];
var marks = function marks(editor) {
    var { marks, selection } = editor;
    if (!selection) {
        return null;
    }
    var { anchor, focus } = selection;
    if (marks) {
        return marks;
    }
    if (Range.isExpanded(selection)) {
        var isBackward = Range.isBackward(selection);
        if (isBackward) {
            [focus, anchor] = [
                anchor,
                focus
            ];
        }
        /**
     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)
     * do not adversely affect the returned marks.
     */ var isEnd = Editor.isEnd(editor, anchor, anchor.path);
        if (isEnd) {
            var after = Editor.after(editor, anchor);
            if (after) {
                anchor = after;
            }
        }
        var [match] = Editor.nodes(editor, {
            match: Text.isText,
            at: {
                anchor,
                focus
            }
        });
        if (match) {
            var [_node] = match;
            var _rest = _objectWithoutProperties(_node, _excluded$1);
            return _rest;
        } else {
            return {};
        }
    }
    var { path } = anchor;
    var [node] = Editor.leaf(editor, path);
    if (anchor.offset === 0) {
        var prev = Editor.previous(editor, {
            at: path,
            match: Text.isText
        });
        var markedVoid = Editor.above(editor, {
            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)
        });
        if (!markedVoid) {
            var block = Editor.above(editor, {
                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)
            });
            if (prev && block) {
                var [prevNode, prevPath] = prev;
                var [, blockPath] = block;
                if (Path.isAncestor(blockPath, prevPath)) {
                    node = prevNode;
                }
            }
        }
    }
    var rest = _objectWithoutProperties(node, _excluded2$1);
    return rest;
};
var next = function next(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { mode = 'lowest', voids = false } = options;
    var { match, at = editor.selection } = options;
    if (!at) {
        return;
    }
    var pointAfterLocation = Editor.after(editor, at, {
        voids
    });
    if (!pointAfterLocation) return;
    var [, to] = Editor.last(editor, []);
    var span = [
        pointAfterLocation.path,
        to
    ];
    if (Path.isPath(at) && at.length === 0) {
        throw new Error("Cannot get the next node from the root node!");
    }
    if (match == null) {
        if (Path.isPath(at)) {
            var [parent] = Editor.parent(editor, at);
            match = (n)=>parent.children.includes(n);
        } else {
            match = ()=>true;
        }
    }
    var [next] = Editor.nodes(editor, {
        at: span,
        match,
        mode,
        voids
    });
    return next;
};
var node = function node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.get(editor, path);
    return [
        node,
        path
    ];
};
function nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function*() {
        var { at = editor.selection, mode = 'all', universal = false, reverse = false, voids = false, ignoreNonSelectable = false } = options;
        var { match } = options;
        if (!match) {
            match = ()=>true;
        }
        if (!at) {
            return;
        }
        var from;
        var to;
        if (Span.isSpan(at)) {
            from = at[0];
            to = at[1];
        } else {
            var first = Editor.path(editor, at, {
                edge: 'start'
            });
            var last = Editor.path(editor, at, {
                edge: 'end'
            });
            from = reverse ? last : first;
            to = reverse ? first : last;
        }
        var nodeEntries = Node.nodes(editor, {
            reverse,
            from,
            to,
            pass: (_ref)=>{
                var [node] = _ref;
                if (!Element.isElement(node)) return false;
                if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;
                if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;
                return false;
            }
        });
        var matches = [];
        var hit;
        for (var [node, path] of nodeEntries){
            if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {
                continue;
            }
            var isLower = hit && Path.compare(path, hit[1]) === 0;
            // In highest mode any node lower than the last hit is not a match.
            if (mode === 'highest' && isLower) {
                continue;
            }
            if (!match(node, path)) {
                // If we've arrived at a leaf text node that is not lower than the last
                // hit, then we've found a branch that doesn't include a match, which
                // means the match is not universal.
                if (universal && !isLower && Text.isText(node)) {
                    return;
                } else {
                    continue;
                }
            }
            // If there's a match and it's lower than the last, update the hit.
            if (mode === 'lowest' && isLower) {
                hit = [
                    node,
                    path
                ];
                continue;
            }
            // In lowest mode we emit the last hit, once it's guaranteed lowest.
            var emit = mode === 'lowest' ? hit : [
                node,
                path
            ];
            if (emit) {
                if (universal) {
                    matches.push(emit);
                } else {
                    yield emit;
                }
            }
            hit = [
                node,
                path
            ];
        }
        // Since lowest is always emitting one behind, catch up at the end.
        if (mode === 'lowest' && hit) {
            if (universal) {
                matches.push(hit);
            } else {
                yield hit;
            }
        }
        // Universal defers to ensure that the match occurs in every branch, so we
        // yield all of the matches after iterating.
        if (universal) {
            yield* matches;
        }
    }();
}
var normalize = function normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { force = false, operation } = options;
    var getDirtyPaths = (editor)=>{
        return DIRTY_PATHS.get(editor) || [];
    };
    var getDirtyPathKeys = (editor)=>{
        return DIRTY_PATH_KEYS.get(editor) || new Set();
    };
    var popDirtyPath = (editor)=>{
        var path = getDirtyPaths(editor).pop();
        var key = path.join(',');
        getDirtyPathKeys(editor).delete(key);
        return path;
    };
    if (!Editor.isNormalizing(editor)) {
        return;
    }
    if (force) {
        var allPaths = Array.from(Node.nodes(editor), (_ref)=>{
            var [, p] = _ref;
            return p;
        });
        var allPathKeys = new Set(allPaths.map((p)=>p.join(',')));
        DIRTY_PATHS.set(editor, allPaths);
        DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }
    if (getDirtyPaths(editor).length === 0) {
        return;
    }
    Editor.withoutNormalizing(editor, ()=>{
        /*
      Fix dirty elements with no children.
      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.
      Running an initial pass avoids the catch-22 race condition.
    */ for (var dirtyPath of getDirtyPaths(editor)){
            if (Node.has(editor, dirtyPath)) {
                var entry = Editor.node(editor, dirtyPath);
                var [node, _] = entry;
                /*
          The default normalizer inserts an empty text node in this scenario, but it can be customised.
          So there is some risk here.
                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;
          by definition adding children to an empty node can't cause other paths to change.
        */ if (Element.isElement(node) && node.children.length === 0) {
                    editor.normalizeNode(entry, {
                        operation
                    });
                }
            }
        }
        var dirtyPaths = getDirtyPaths(editor);
        var initialDirtyPathsLength = dirtyPaths.length;
        var iteration = 0;
        while(dirtyPaths.length !== 0){
            if (!editor.shouldNormalize({
                dirtyPaths,
                iteration,
                initialDirtyPathsLength,
                operation
            })) {
                return;
            }
            var _dirtyPath = popDirtyPath(editor);
            // If the node doesn't exist in the tree, it does not need to be normalized.
            if (Node.has(editor, _dirtyPath)) {
                var _entry = Editor.node(editor, _dirtyPath);
                editor.normalizeNode(_entry, {
                    operation
                });
            }
            iteration++;
            dirtyPaths = getDirtyPaths(editor);
        }
    });
};
var parent = function parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
};
var pathRef = function pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { affinity = 'forward' } = options;
    var ref = {
        current: path,
        affinity,
        unref () {
            var { current } = ref;
            var pathRefs = Editor.pathRefs(editor);
            pathRefs.delete(ref);
            ref.current = null;
            return current;
        }
    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
};
var pathRefs = (editor)=>{
    var refs = PATH_REFS.get(editor);
    if (!refs) {
        refs = new Set();
        PATH_REFS.set(editor, refs);
    }
    return refs;
};
var path = function path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { depth, edge } = options;
    if (Path.isPath(at)) {
        if (edge === 'start') {
            var [, firstPath] = Node.first(editor, at);
            at = firstPath;
        } else if (edge === 'end') {
            var [, lastPath] = Node.last(editor, at);
            at = lastPath;
        }
    }
    if (Range.isRange(at)) {
        if (edge === 'start') {
            at = Range.start(at);
        } else if (edge === 'end') {
            at = Range.end(at);
        } else {
            at = Path.common(at.anchor.path, at.focus.path);
        }
    }
    if (Point.isPoint(at)) {
        at = at.path;
    }
    if (depth != null) {
        at = at.slice(0, depth);
    }
    return at;
};
var pointRef = function pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { affinity = 'forward' } = options;
    var ref = {
        current: point,
        affinity,
        unref () {
            var { current } = ref;
            var pointRefs = Editor.pointRefs(editor);
            pointRefs.delete(ref);
            ref.current = null;
            return current;
        }
    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
};
var pointRefs = (editor)=>{
    var refs = POINT_REFS.get(editor);
    if (!refs) {
        refs = new Set();
        POINT_REFS.set(editor, refs);
    }
    return refs;
};
var point = function point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { edge = 'start' } = options;
    if (Path.isPath(at)) {
        var path;
        if (edge === 'end') {
            var [, lastPath] = Node.last(editor, at);
            path = lastPath;
        } else {
            var [, firstPath] = Node.first(editor, at);
            path = firstPath;
        }
        var node = Node.get(editor, path);
        if (!Text.isText(node)) {
            throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
        }
        return {
            path,
            offset: edge === 'end' ? node.text.length : 0
        };
    }
    if (Range.isRange(at)) {
        var [start, end] = Range.edges(at);
        return edge === 'start' ? start : end;
    }
    return at;
};
function positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function*() {
        var { at = editor.selection, unit = 'offset', reverse = false, voids = false, ignoreNonSelectable = false } = options;
        if (!at) {
            return;
        }
        /**
     * Algorithm notes:
     *
     * Each step `distance` is dynamic depending on the underlying text
     * and the `unit` specified.  Each step, e.g., a line or word, may
     * span multiple text nodes, so we iterate through the text both on
     * two levels in step-sync:
     *
     * `leafText` stores the text on a text leaf level, and is advanced
     * through using the counters `leafTextOffset` and `leafTextRemaining`.
     *
     * `blockText` stores the text on a block level, and is shortened
     * by `distance` every time it is advanced.
     *
     * We only maintain a window of one blockText and one leafText because
     * a block node always appears before all of its leaf nodes.
     */ var range = Editor.range(editor, at);
        var [start, end] = Range.edges(range);
        var first = reverse ? end : start;
        var isNewBlock = false;
        var blockText = '';
        var distance = 0; // Distance for leafText to catch up to blockText.
        var leafTextRemaining = 0;
        var leafTextOffset = 0;
        // Iterate through all nodes in range, grabbing entire textual content
        // of block nodes in blockText, and text nodes in leafText.
        // Exploits the fact that nodes are sequenced in such a way that we first
        // encounter the block node, then all of its text nodes, so when iterating
        // through the blockText and leafText we just need to remember a window of
        // one block node and leaf node, respectively.
        for (var [node, path] of Editor.nodes(editor, {
            at,
            reverse,
            voids,
            ignoreNonSelectable
        })){
            /*
       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks
       */ if (Element.isElement(node)) {
                // Void nodes are a special case, so by default we will always
                // yield their first point. If the `voids` option is set to true,
                // then we will iterate over their content.
                if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {
                    yield Editor.start(editor, path);
                    continue;
                }
                // Inline element nodes are ignored as they don't themselves
                // contribute to `blockText` or `leafText` - their parent and
                // children do.
                if (editor.isInline(node)) continue;
                // Block element node - set `blockText` to its text content.
                if (Editor.hasInlines(editor, node)) {
                    // We always exhaust block nodes before encountering a new one:
                    //   console.assert(blockText === '',
                    //     `blockText='${blockText}' - `+
                    //     `not exhausted before new block node`, path)
                    // Ensure range considered is capped to `range`, in the
                    // start/end edge cases where block extends beyond range.
                    // Equivalent to this, but presumably more performant:
                    //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))
                    //   blockRange = Range.intersection(range, blockRange) // intersect
                    //   blockText = Editor.string(editor, blockRange, { voids })
                    var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
                    var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);
                    blockText = Editor.string(editor, {
                        anchor: s,
                        focus: e
                    }, {
                        voids
                    });
                    isNewBlock = true;
                }
            }
            /*
       * TEXT LEAF NODE - Iterate through text content, yielding
       * positions every `distance` offset according to `unit`.
       */ if (Text.isText(node)) {
                var isFirst = Path.equals(path, first.path);
                // Proof that we always exhaust text nodes before encountering a new one:
                //   console.assert(leafTextRemaining <= 0,
                //     `leafTextRemaining=${leafTextRemaining} - `+
                //     `not exhausted before new leaf text node`, path)
                // Reset `leafText` counters for new text node.
                if (isFirst) {
                    leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;
                    leafTextOffset = first.offset; // Works for reverse too.
                } else {
                    leafTextRemaining = node.text.length;
                    leafTextOffset = reverse ? leafTextRemaining : 0;
                }
                // Yield position at the start of node (potentially).
                if (isFirst || isNewBlock || unit === 'offset') {
                    yield {
                        path,
                        offset: leafTextOffset
                    };
                    isNewBlock = false;
                }
                // Yield positions every (dynamically calculated) `distance` offset.
                while(true){
                    // If `leafText` has caught up with `blockText` (distance=0),
                    // and if blockText is exhausted, break to get another block node,
                    // otherwise advance blockText forward by the new `distance`.
                    if (distance === 0) {
                        if (blockText === '') break;
                        distance = calcDistance(blockText, unit, reverse);
                        // Split the string at the previously found distance and use the
                        // remaining string for the next iteration.
                        blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
                    }
                    // Advance `leafText` by the current `distance`.
                    leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
                    leafTextRemaining = leafTextRemaining - distance;
                    // If `leafText` is exhausted, break to get a new leaf node
                    // and set distance to the overflow amount, so we'll (maybe)
                    // catch up to blockText in the next leaf text node.
                    if (leafTextRemaining < 0) {
                        distance = -leafTextRemaining;
                        break;
                    }
                    // Successfully walked `distance` offsets through `leafText`
                    // to catch up with `blockText`, so we can reset `distance`
                    // and yield this position in this node.
                    distance = 0;
                    yield {
                        path,
                        offset: leafTextOffset
                    };
                }
            }
        }
        // Proof that upon completion, we've exahusted both leaf and block text:
        //   console.assert(leafTextRemaining <= 0, "leafText wasn't exhausted")
        //   console.assert(blockText === '', "blockText wasn't exhausted")
        // Helper:
        // Return the distance in offsets for a step of size `unit` on given string.
        function calcDistance(text, unit, reverse) {
            if (unit === 'character') {
                return getCharacterDistance(text, reverse);
            } else if (unit === 'word') {
                return getWordDistance(text, reverse);
            } else if (unit === 'line' || unit === 'block') {
                return text.length;
            }
            return 1;
        }
    }();
}
var previous = function previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { mode = 'lowest', voids = false } = options;
    var { match, at = editor.selection } = options;
    if (!at) {
        return;
    }
    var pointBeforeLocation = Editor.before(editor, at, {
        voids
    });
    if (!pointBeforeLocation) {
        return;
    }
    var [, to] = Editor.first(editor, []);
    // The search location is from the start of the document to the path of
    // the point before the location passed in
    var span = [
        pointBeforeLocation.path,
        to
    ];
    if (Path.isPath(at) && at.length === 0) {
        throw new Error("Cannot get the previous node from the root node!");
    }
    if (match == null) {
        if (Path.isPath(at)) {
            var [parent] = Editor.parent(editor, at);
            match = (n)=>parent.children.includes(n);
        } else {
            match = ()=>true;
        }
    }
    var [previous] = Editor.nodes(editor, {
        reverse: true,
        at: span,
        match,
        mode,
        voids
    });
    return previous;
};
var rangeRef = function rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { affinity = 'forward' } = options;
    var ref = {
        current: range,
        affinity,
        unref () {
            var { current } = ref;
            var rangeRefs = Editor.rangeRefs(editor);
            rangeRefs.delete(ref);
            ref.current = null;
            return current;
        }
    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
};
var rangeRefs = (editor)=>{
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
        refs = new Set();
        RANGE_REFS.set(editor, refs);
    }
    return refs;
};
var range = (editor, at, to)=>{
    if (Range.isRange(at) && !to) {
        return at;
    }
    var start = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
        anchor: start,
        focus: end
    };
};
function ownKeys$2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$2(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var removeMark = (editor, key)=>{
    var { selection } = editor;
    if (selection) {
        var match = (node, path)=>{
            if (!Text.isText(node)) {
                return false; // marks can only be applied to text
            }
            var [parentNode, parentPath] = Editor.parent(editor, path);
            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
            var [selectedNode, selectedPath] = Editor.node(editor, selection);
            if (selectedNode && match(selectedNode, selectedPath)) {
                var [parentNode] = Editor.parent(editor, selectedPath);
                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
            }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
            Transforms.unsetNodes(editor, key, {
                match,
                split: true,
                voids: true
            });
        } else {
            var marks = _objectSpread$2({}, Editor.marks(editor) || {});
            delete marks[key];
            editor.marks = marks;
            if (!FLUSHING.get(editor)) {
                editor.onChange();
            }
        }
    }
};
var setNormalizing = (editor, isNormalizing)=>{
    NORMALIZING.set(editor, isNormalizing);
};
var start = (editor, at)=>{
    return Editor.point(editor, at, {
        edge: 'start'
    });
};
var string = function string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { voids = false } = options;
    var range = Editor.range(editor, at);
    var [start, end] = Range.edges(range);
    var text = '';
    for (var [node, path] of Editor.nodes(editor, {
        at: range,
        match: Text.isText,
        voids
    })){
        var t = node.text;
        if (Path.equals(path, end.path)) {
            t = t.slice(0, end.offset);
        }
        if (Path.equals(path, start.path)) {
            t = t.slice(start.offset);
        }
        text += t;
    }
    return text;
};
var unhangRange = function unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { voids = false } = options;
    var [start, end] = Range.edges(range);
    // PERF: exit early if we can guarantee that the range isn't hanging.
    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {
        return range;
    }
    var endBlock = Editor.above(editor, {
        at: end,
        match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),
        voids
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, start);
    var before = {
        anchor: first,
        focus: end
    };
    var skip = true;
    for (var [node, path] of Editor.nodes(editor, {
        at: before,
        match: Text.isText,
        reverse: true,
        voids
    })){
        if (skip) {
            skip = false;
            continue;
        }
        if (node.text !== '' || Path.isBefore(path, blockPath)) {
            end = {
                path,
                offset: node.text.length
            };
            break;
        }
    }
    return {
        anchor: start,
        focus: end
    };
};
var withoutNormalizing = (editor, fn)=>{
    var value = Editor.isNormalizing(editor);
    Editor.setNormalizing(editor, false);
    try {
        fn();
    } finally{
        Editor.setNormalizing(editor, value);
    }
    Editor.normalize(editor);
};
var shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2)=>{
    var [prevNode, prevPath] = _ref;
    // If the target node that we're merging with is empty, remove it instead
    // of merging the two. This is a common rich text editor behavior to
    // prevent losing formatting when deleting entire nodes when you have a
    // hanging selection.
    // if prevNode is first child in parent,don't remove it.
    return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;
};
var deleteText = function deleteText(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var _Editor$void, _Editor$void2;
        var { reverse = false, unit = 'character', distance = 1, voids = false } = options;
        var { at = editor.selection, hanging = false } = options;
        if (!at) {
            return;
        }
        var isCollapsed = false;
        if (Range.isRange(at) && Range.isCollapsed(at)) {
            isCollapsed = true;
            at = at.anchor;
        }
        if (Point.isPoint(at)) {
            var furthestVoid = Editor.void(editor, {
                at,
                mode: 'highest'
            });
            if (!voids && furthestVoid) {
                var [, voidPath] = furthestVoid;
                at = voidPath;
            } else {
                var opts = {
                    unit,
                    distance
                };
                var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
                at = {
                    anchor: at,
                    focus: target
                };
                hanging = true;
            }
        }
        if (Path.isPath(at)) {
            Transforms.removeNodes(editor, {
                at,
                voids
            });
            return;
        }
        if (Range.isCollapsed(at)) {
            return;
        }
        if (!hanging) {
            var [, _end] = Range.edges(at);
            var endOfDoc = Editor.end(editor, []);
            if (!Point.equals(_end, endOfDoc)) {
                at = Editor.unhangRange(editor, at, {
                    voids
                });
            }
        }
        var [start, end] = Range.edges(at);
        var startBlock = Editor.above(editor, {
            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),
            at: start,
            voids
        });
        var endBlock = Editor.above(editor, {
            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),
            at: end,
            voids
        });
        var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
        var isSingleText = Path.equals(start.path, end.path);
        var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {
            at: start,
            mode: 'highest'
        })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {
            at: start,
            mode: 'highest'
        });
        var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {
            at: end,
            mode: 'highest'
        })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {
            at: end,
            mode: 'highest'
        });
        // If the start or end points are inside an inline void, nudge them out.
        if (startNonEditable) {
            var before = Editor.before(editor, start);
            if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
                start = before;
            }
        }
        if (endNonEditable) {
            var after = Editor.after(editor, end);
            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
                end = after;
            }
        }
        // Get the highest nodes that are completely inside the range, as well as
        // the start and end nodes.
        var matches = [];
        var lastPath;
        for (var entry of Editor.nodes(editor, {
            at,
            voids
        })){
            var [node, path] = entry;
            if (lastPath && Path.compare(path, lastPath) === 0) {
                continue;
            }
            if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
                matches.push(entry);
                lastPath = path;
            }
        }
        var pathRefs = Array.from(matches, (_ref)=>{
            var [, p] = _ref;
            return Editor.pathRef(editor, p);
        });
        var startRef = Editor.pointRef(editor, start);
        var endRef = Editor.pointRef(editor, end);
        var removedText = '';
        if (!isSingleText && !startNonEditable) {
            var _point = startRef.current;
            var [_node] = Editor.leaf(editor, _point);
            var { path: _path } = _point;
            var { offset } = start;
            var text = _node.text.slice(offset);
            if (text.length > 0) {
                editor.apply({
                    type: 'remove_text',
                    path: _path,
                    offset,
                    text
                });
                removedText = text;
            }
        }
        pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {
                at: p,
                voids
            }));
        if (!endNonEditable) {
            var _point2 = endRef.current;
            var [_node2] = Editor.leaf(editor, _point2);
            var { path: _path2 } = _point2;
            var _offset = isSingleText ? start.offset : 0;
            var _text = _node2.text.slice(_offset, end.offset);
            if (_text.length > 0) {
                editor.apply({
                    type: 'remove_text',
                    path: _path2,
                    offset: _offset,
                    text: _text
                });
                removedText = _text;
            }
        }
        if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
            Transforms.mergeNodes(editor, {
                at: endRef.current,
                hanging: true,
                voids
            });
        }
        // For Thai script, deleting N character(s) backward should delete
        // N code point(s) instead of an entire grapheme cluster.
        // Therefore, the remaining code points should be inserted back.
        if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
            Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
        }
        var startUnref = startRef.unref();
        var endUnref = endRef.unref();
        var point = reverse ? startUnref || endUnref : endUnref || startUnref;
        if (options.at == null && point) {
            Transforms.select(editor, point);
        }
    });
};
var insertFragment = function insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { hanging = false, voids = false } = options;
        var { at = getDefaultInsertLocation(editor), batchDirty = true } = options;
        if (!fragment.length) {
            return;
        }
        if (Range.isRange(at)) {
            if (!hanging) {
                at = Editor.unhangRange(editor, at, {
                    voids
                });
            }
            if (Range.isCollapsed(at)) {
                at = at.anchor;
            } else {
                var [, end] = Range.edges(at);
                if (!voids && Editor.void(editor, {
                    at: end
                })) {
                    return;
                }
                var pointRef = Editor.pointRef(editor, end);
                Transforms.delete(editor, {
                    at
                });
                at = pointRef.unref();
            }
        } else if (Path.isPath(at)) {
            at = Editor.start(editor, at);
        }
        if (!voids && Editor.void(editor, {
            at
        })) {
            return;
        }
        // If the insert point is at the edge of an inline node, move it outside
        // instead since it will need to be split otherwise.
        var inlineElementMatch = Editor.above(editor, {
            at,
            match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),
            mode: 'highest',
            voids
        });
        if (inlineElementMatch) {
            var [, _inlinePath] = inlineElementMatch;
            if (Editor.isEnd(editor, at, _inlinePath)) {
                var after = Editor.after(editor, _inlinePath);
                at = after;
            } else if (Editor.isStart(editor, at, _inlinePath)) {
                var before = Editor.before(editor, _inlinePath);
                at = before;
            }
        }
        var blockMatch = Editor.above(editor, {
            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),
            at,
            voids
        });
        var [, blockPath] = blockMatch;
        var isBlockStart = Editor.isStart(editor, at, blockPath);
        var isBlockEnd = Editor.isEnd(editor, at, blockPath);
        var isBlockEmpty = isBlockStart && isBlockEnd;
        var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
        var mergeEnd = !isBlockEnd;
        var [, firstPath] = Node.first({
            children: fragment
        }, []);
        var [, lastPath] = Node.last({
            children: fragment
        }, []);
        var matches = [];
        var matcher = (_ref)=>{
            var [n, p] = _ref;
            var isRoot = p.length === 0;
            if (isRoot) {
                return false;
            }
            if (isBlockEmpty) {
                return true;
            }
            if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
                return false;
            }
            if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
                return false;
            }
            return true;
        };
        for (var entry of Node.nodes({
            children: fragment
        }, {
            pass: matcher
        })){
            if (matcher(entry)) {
                matches.push(entry);
            }
        }
        var starts = [];
        var middles = [];
        var ends = [];
        var starting = true;
        var hasBlocks = false;
        for (var [node] of matches){
            if (Element.isElement(node) && !editor.isInline(node)) {
                starting = false;
                hasBlocks = true;
                middles.push(node);
            } else if (starting) {
                starts.push(node);
            } else {
                ends.push(node);
            }
        }
        var [inlineMatch] = Editor.nodes(editor, {
            at,
            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),
            mode: 'highest',
            voids
        });
        var [, inlinePath] = inlineMatch;
        var isInlineStart = Editor.isStart(editor, at, inlinePath);
        var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
        var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
        var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
        Transforms.splitNodes(editor, {
            at,
            match: (n)=>hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),
            mode: hasBlocks ? 'lowest' : 'highest',
            always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
            voids
        });
        var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
        Transforms.insertNodes(editor, starts, {
            at: startRef.current,
            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),
            mode: 'highest',
            voids,
            batchDirty
        });
        if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
            Transforms.delete(editor, {
                at: blockPath,
                voids
            });
        }
        Transforms.insertNodes(editor, middles, {
            at: middleRef.current,
            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),
            mode: 'lowest',
            voids,
            batchDirty
        });
        Transforms.insertNodes(editor, ends, {
            at: endRef.current,
            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),
            mode: 'highest',
            voids,
            batchDirty
        });
        if (!options.at) {
            var path;
            if (ends.length > 0 && endRef.current) {
                path = Path.previous(endRef.current);
            } else if (middles.length > 0 && middleRef.current) {
                path = Path.previous(middleRef.current);
            } else if (startRef.current) {
                path = Path.previous(startRef.current);
            }
            if (path) {
                var _end = Editor.end(editor, path);
                Transforms.select(editor, _end);
            }
        }
        startRef.unref();
        middleRef.unref();
        endRef.unref();
    });
};
var collapse = function collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { edge = 'anchor' } = options;
    var { selection } = editor;
    if (!selection) {
        return;
    } else if (edge === 'anchor') {
        Transforms.select(editor, selection.anchor);
    } else if (edge === 'focus') {
        Transforms.select(editor, selection.focus);
    } else if (edge === 'start') {
        var [start] = Range.edges(selection);
        Transforms.select(editor, start);
    } else if (edge === 'end') {
        var [, end] = Range.edges(selection);
        Transforms.select(editor, end);
    }
};
var deselect = (editor)=>{
    var { selection } = editor;
    if (selection) {
        editor.apply({
            type: 'set_selection',
            properties: selection,
            newProperties: null
        });
    }
};
var move = function move(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var { selection } = editor;
    var { distance = 1, unit = 'character', reverse = false } = options;
    var { edge = null } = options;
    if (!selection) {
        return;
    }
    if (edge === 'start') {
        edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }
    if (edge === 'end') {
        edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }
    var { anchor, focus } = selection;
    var opts = {
        distance,
        unit,
        ignoreNonSelectable: true
    };
    var props = {};
    if (edge == null || edge === 'anchor') {
        var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
        if (point) {
            props.anchor = point;
        }
    }
    if (edge == null || edge === 'focus') {
        var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);
        if (_point) {
            props.focus = _point;
        }
    }
    Transforms.setSelection(editor, props);
};
var select = (editor, target)=>{
    var { selection } = editor;
    target = Editor.range(editor, target);
    if (selection) {
        Transforms.setSelection(editor, target);
        return;
    }
    if (!Range.isRange(target)) {
        throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
    }
    editor.apply({
        type: 'set_selection',
        properties: selection,
        newProperties: target
    });
};
function ownKeys$1(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$1(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var setPoint = function setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var { selection } = editor;
    var { edge = 'both' } = options;
    if (!selection) {
        return;
    }
    if (edge === 'start') {
        edge = Range.isBackward(selection) ? 'focus' : 'anchor';
    }
    if (edge === 'end') {
        edge = Range.isBackward(selection) ? 'anchor' : 'focus';
    }
    var { anchor, focus } = selection;
    var point = edge === 'anchor' ? anchor : focus;
    Transforms.setSelection(editor, {
        [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)
    });
};
var setSelection = (editor, props)=>{
    var { selection } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
        return;
    }
    for(var k in props){
        if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {
            oldProps[k] = selection[k];
            newProps[k] = props[k];
        }
    }
    if (Object.keys(oldProps).length > 0) {
        editor.apply({
            type: 'set_selection',
            properties: oldProps,
            newProperties: newProps
        });
    }
};
var insertNodes = function insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { hanging = false, voids = false, mode = 'lowest', batchDirty = true } = options;
        var { at, match, select } = options;
        if (Node.isNode(nodes)) {
            nodes = [
                nodes
            ];
        }
        if (nodes.length === 0) {
            return;
        }
        var [node] = nodes;
        if (!at) {
            at = getDefaultInsertLocation(editor);
            if (select !== false) {
                select = true;
            }
        }
        if (select == null) {
            select = false;
        }
        if (Range.isRange(at)) {
            if (!hanging) {
                at = Editor.unhangRange(editor, at, {
                    voids
                });
            }
            if (Range.isCollapsed(at)) {
                at = at.anchor;
            } else {
                var [, end] = Range.edges(at);
                var pointRef = Editor.pointRef(editor, end);
                Transforms.delete(editor, {
                    at
                });
                at = pointRef.unref();
            }
        }
        if (Point.isPoint(at)) {
            if (match == null) {
                if (Text.isText(node)) {
                    match = (n)=>Text.isText(n);
                } else if (editor.isInline(node)) {
                    match = (n)=>Text.isText(n) || Editor.isInline(editor, n);
                } else {
                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
                }
            }
            var [entry] = Editor.nodes(editor, {
                at: at.path,
                match,
                mode,
                voids
            });
            if (entry) {
                var [, matchPath] = entry;
                var pathRef = Editor.pathRef(editor, matchPath);
                var isAtEnd = Editor.isEnd(editor, at, matchPath);
                Transforms.splitNodes(editor, {
                    at,
                    match,
                    mode,
                    voids
                });
                var path = pathRef.unref();
                at = isAtEnd ? Path.next(path) : path;
            } else {
                return;
            }
        }
        var parentPath = Path.parent(at);
        var index = at[at.length - 1];
        if (!voids && Editor.void(editor, {
            at: parentPath
        })) {
            return;
        }
        if (batchDirty) {
            // PERF: batch update dirty paths
            // batched ops used to transform existing dirty paths
            var batchedOps = [];
            var newDirtyPaths = Path.levels(parentPath);
            batchDirtyPaths(editor, ()=>{
                var _loop = function _loop() {
                    var path = parentPath.concat(index);
                    index++;
                    var op = {
                        type: 'insert_node',
                        path,
                        node: _node
                    };
                    editor.apply(op);
                    at = Path.next(at);
                    batchedOps.push(op);
                    if (!Text.isText) {
                        newDirtyPaths.push(path);
                    } else {
                        newDirtyPaths.push(...Array.from(Node.nodes(_node), (_ref)=>{
                            var [, p] = _ref;
                            return path.concat(p);
                        }));
                    }
                };
                for (var _node of nodes){
                    _loop();
                }
            }, ()=>{
                updateDirtyPaths(editor, newDirtyPaths, (p)=>{
                    var newPath = p;
                    for (var op of batchedOps){
                        if (Path.operationCanTransformPath(op)) {
                            newPath = Path.transform(newPath, op);
                            if (!newPath) {
                                return null;
                            }
                        }
                    }
                    return newPath;
                });
            });
        } else {
            for (var _node2 of nodes){
                var _path = parentPath.concat(index);
                index++;
                editor.apply({
                    type: 'insert_node',
                    path: _path,
                    node: _node2
                });
                at = Path.next(at);
            }
        }
        at = Path.previous(at);
        if (select) {
            var point = Editor.end(editor, at);
            if (point) {
                Transforms.select(editor, point);
            }
        }
    });
};
var liftNodes = function liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { at = editor.selection, mode = 'lowest', voids = false } = options;
        var { match } = options;
        if (match == null) {
            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        if (!at) {
            return;
        }
        var matches = Editor.nodes(editor, {
            at,
            match,
            mode,
            voids
        });
        var pathRefs = Array.from(matches, (_ref)=>{
            var [, p] = _ref;
            return Editor.pathRef(editor, p);
        });
        for (var pathRef of pathRefs){
            var path = pathRef.unref();
            if (path.length < 2) {
                throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
            }
            var parentNodeEntry = Editor.node(editor, Path.parent(path));
            var [parent, parentPath] = parentNodeEntry;
            var index = path[path.length - 1];
            var { length } = parent.children;
            if (length === 1) {
                var toPath = Path.next(parentPath);
                Transforms.moveNodes(editor, {
                    at: path,
                    to: toPath,
                    voids
                });
                Transforms.removeNodes(editor, {
                    at: parentPath,
                    voids
                });
            } else if (index === 0) {
                Transforms.moveNodes(editor, {
                    at: path,
                    to: parentPath,
                    voids
                });
            } else if (index === length - 1) {
                var _toPath = Path.next(parentPath);
                Transforms.moveNodes(editor, {
                    at: path,
                    to: _toPath,
                    voids
                });
            } else {
                var splitPath = Path.next(path);
                var _toPath2 = Path.next(parentPath);
                Transforms.splitNodes(editor, {
                    at: splitPath,
                    voids
                });
                Transforms.moveNodes(editor, {
                    at: path,
                    to: _toPath2,
                    voids
                });
            }
        }
    });
};
var _excluded = [
    "text"
], _excluded2 = [
    "children"
];
var hasSingleChildNest = (editor, node)=>{
    if (Element.isElement(node)) {
        var element = node;
        if (Editor.isVoid(editor, node)) {
            return true;
        } else if (element.children.length === 1) {
            return hasSingleChildNest(editor, element.children[0]);
        } else {
            return false;
        }
    } else if (Editor.isEditor(node)) {
        return false;
    } else {
        return true;
    }
};
var mergeNodes = function mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { match, at = editor.selection } = options;
        var { hanging = false, voids = false, mode = 'lowest' } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            if (Path.isPath(at)) {
                var [parent] = Editor.parent(editor, at);
                match = (n)=>parent.children.includes(n);
            } else {
                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
            }
        }
        if (!hanging && Range.isRange(at)) {
            at = Editor.unhangRange(editor, at, {
                voids
            });
        }
        if (Range.isRange(at)) {
            if (Range.isCollapsed(at)) {
                at = at.anchor;
            } else {
                var [, end] = Range.edges(at);
                var pointRef = Editor.pointRef(editor, end);
                Transforms.delete(editor, {
                    at
                });
                at = pointRef.unref();
                if (options.at == null) {
                    Transforms.select(editor, at);
                }
            }
        }
        var [current] = Editor.nodes(editor, {
            at,
            match,
            voids,
            mode
        });
        var prev = Editor.previous(editor, {
            at,
            match,
            voids,
            mode
        });
        if (!current || !prev) {
            return;
        }
        var [node, path] = current;
        var [prevNode, prevPath] = prev;
        if (path.length === 0 || prevPath.length === 0) {
            return;
        }
        var newPath = Path.next(prevPath);
        var commonPath = Path.common(path, prevPath);
        var isPreviousSibling = Path.isSibling(path, prevPath);
        var levels = Array.from(Editor.levels(editor, {
            at: path
        }), (_ref)=>{
            var [n] = _ref;
            return n;
        }).slice(commonPath.length).slice(0, -1);
        // Determine if the merge will leave an ancestor of the path empty as a
        // result, in which case we'll want to remove it after merging.
        var emptyAncestor = Editor.above(editor, {
            at: path,
            mode: 'highest',
            match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)
        });
        var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
        var properties;
        var position;
        // Ensure that the nodes are equivalent, and figure out what the position
        // and extra properties of the merge will be.
        if (Text.isText(node) && Text.isText(prevNode)) {
            var rest = _objectWithoutProperties(node, _excluded);
            position = prevNode.text.length;
            properties = rest;
        } else if (Element.isElement(node) && Element.isElement(prevNode)) {
            var rest = _objectWithoutProperties(node, _excluded2);
            position = prevNode.children.length;
            properties = rest;
        } else {
            throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node), " ").concat(Scrubber.stringify(prevNode)));
        }
        // If the node isn't already the next sibling of the previous node, move
        // it so that it is before merging.
        if (!isPreviousSibling) {
            Transforms.moveNodes(editor, {
                at: path,
                to: newPath,
                voids
            });
        }
        // If there was going to be an empty ancestor of the node that was merged,
        // we remove it from the tree.
        if (emptyRef) {
            Transforms.removeNodes(editor, {
                at: emptyRef.current,
                voids
            });
        }
        if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {
            Transforms.removeNodes(editor, {
                at: prevPath,
                voids
            });
        } else {
            editor.apply({
                type: 'merge_node',
                path: newPath,
                position,
                properties
            });
        }
        if (emptyRef) {
            emptyRef.unref();
        }
    });
};
var moveNodes = (editor, options)=>{
    Editor.withoutNormalizing(editor, ()=>{
        var { to, at = editor.selection, mode = 'lowest', voids = false } = options;
        var { match } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        var toRef = Editor.pathRef(editor, to);
        var targets = Editor.nodes(editor, {
            at,
            match,
            mode,
            voids
        });
        var pathRefs = Array.from(targets, (_ref)=>{
            var [, p] = _ref;
            return Editor.pathRef(editor, p);
        });
        for (var pathRef of pathRefs){
            var path = pathRef.unref();
            var newPath = toRef.current;
            if (path.length !== 0) {
                editor.apply({
                    type: 'move_node',
                    path,
                    newPath
                });
            }
            if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
                // When performing a sibling move to a later index, the path at the destination is shifted
                // to before the insertion point instead of after. To ensure our group of nodes are inserted
                // in the correct order we increment toRef to account for that
                toRef.current = Path.next(toRef.current);
            }
        }
        toRef.unref();
    });
};
var removeNodes = function removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { hanging = false, voids = false, mode = 'lowest' } = options;
        var { at = editor.selection, match } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        if (!hanging && Range.isRange(at)) {
            at = Editor.unhangRange(editor, at, {
                voids
            });
        }
        var depths = Editor.nodes(editor, {
            at,
            match,
            mode,
            voids
        });
        var pathRefs = Array.from(depths, (_ref)=>{
            var [, p] = _ref;
            return Editor.pathRef(editor, p);
        });
        for (var pathRef of pathRefs){
            var path = pathRef.unref();
            if (path) {
                var [node] = Editor.node(editor, path);
                editor.apply({
                    type: 'remove_node',
                    path,
                    node
                });
            }
        }
    });
};
var setNodes = function setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { match, at = editor.selection, compare, merge } = options;
        var { hanging = false, mode = 'lowest', split = false, voids = false } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        if (!hanging && Range.isRange(at)) {
            at = Editor.unhangRange(editor, at, {
                voids
            });
        }
        if (split && Range.isRange(at)) {
            if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
                // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to
                // set that won't get normalized away
                return;
            }
            var rangeRef = Editor.rangeRef(editor, at, {
                affinity: 'inward'
            });
            var [start, end] = Range.edges(at);
            var splitMode = mode === 'lowest' ? 'lowest' : 'highest';
            var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
            Transforms.splitNodes(editor, {
                at: end,
                match,
                mode: splitMode,
                voids,
                always: !endAtEndOfNode
            });
            var startAtStartOfNode = Editor.isStart(editor, start, start.path);
            Transforms.splitNodes(editor, {
                at: start,
                match,
                mode: splitMode,
                voids,
                always: !startAtStartOfNode
            });
            at = rangeRef.unref();
            if (options.at == null) {
                Transforms.select(editor, at);
            }
        }
        if (!compare) {
            compare = (prop, nodeProp)=>prop !== nodeProp;
        }
        for (var [node, path] of Editor.nodes(editor, {
            at,
            match,
            mode,
            voids
        })){
            var properties = {};
            // FIXME: is this correct?
            var newProperties = {};
            // You can't set properties on the editor node.
            if (path.length === 0) {
                continue;
            }
            var hasChanges = false;
            for(var k in props){
                if (k === 'children' || k === 'text') {
                    continue;
                }
                if (compare(props[k], node[k])) {
                    hasChanges = true;
                    // Omit new properties from the old properties list
                    if (node.hasOwnProperty(k)) properties[k] = node[k];
                    // Omit properties that have been removed from the new properties list
                    if (merge) {
                        if (props[k] != null) newProperties[k] = merge(node[k], props[k]);
                    } else {
                        if (props[k] != null) newProperties[k] = props[k];
                    }
                }
            }
            if (hasChanges) {
                editor.apply({
                    type: 'set_node',
                    path,
                    properties,
                    newProperties
                });
            }
        }
    });
};
/**
 * Convert a range into a point by deleting it's content.
 */ var deleteRange = (editor, range)=>{
    if (Range.isCollapsed(range)) {
        return range.anchor;
    } else {
        var [, end] = Range.edges(range);
        var pointRef = Editor.pointRef(editor, end);
        Transforms.delete(editor, {
            at: range
        });
        return pointRef.unref();
    }
};
var splitNodes = function splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { mode = 'lowest', voids = false } = options;
        var { match, at = editor.selection, height = 0, always = false } = options;
        if (match == null) {
            match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        if (Range.isRange(at)) {
            at = deleteRange(editor, at);
        }
        // If the target is a path, the default height-skipping and position
        // counters need to account for us potentially splitting at a non-leaf.
        if (Path.isPath(at)) {
            var path = at;
            var point = Editor.point(editor, path);
            var [parent] = Editor.parent(editor, path);
            match = (n)=>n === parent;
            height = point.path.length - path.length + 1;
            at = point;
            always = true;
        }
        if (!at) {
            return;
        }
        var beforeRef = Editor.pointRef(editor, at, {
            affinity: 'backward'
        });
        var afterRef;
        try {
            var [highest] = Editor.nodes(editor, {
                at,
                match,
                mode,
                voids
            });
            if (!highest) {
                return;
            }
            var voidMatch = Editor.void(editor, {
                at,
                mode: 'highest'
            });
            var nudge = 0;
            if (!voids && voidMatch) {
                var [voidNode, voidPath] = voidMatch;
                if (Element.isElement(voidNode) && editor.isInline(voidNode)) {
                    var after = Editor.after(editor, voidPath);
                    if (!after) {
                        var text = {
                            text: ''
                        };
                        var afterPath = Path.next(voidPath);
                        Transforms.insertNodes(editor, text, {
                            at: afterPath,
                            voids
                        });
                        after = Editor.point(editor, afterPath);
                    }
                    at = after;
                    always = true;
                }
                var siblingHeight = at.path.length - voidPath.length;
                height = siblingHeight + 1;
                always = true;
            }
            afterRef = Editor.pointRef(editor, at);
            var depth = at.path.length - height;
            var [, highestPath] = highest;
            var lowestPath = at.path.slice(0, depth);
            var position = height === 0 ? at.offset : at.path[depth] + nudge;
            for (var [node, _path] of Editor.levels(editor, {
                at: lowestPath,
                reverse: true,
                voids
            })){
                var split = false;
                if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {
                    break;
                }
                var _point = beforeRef.current;
                var isEnd = Editor.isEnd(editor, _point, _path);
                if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {
                    split = true;
                    var properties = Node.extractProps(node);
                    editor.apply({
                        type: 'split_node',
                        path: _path,
                        position,
                        properties
                    });
                }
                position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);
            }
            if (options.at == null) {
                var _point2 = afterRef.current || Editor.end(editor, []);
                Transforms.select(editor, _point2);
            }
        } finally{
            var _afterRef;
            beforeRef.unref();
            (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();
        }
    });
};
var unsetNodes = function unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!Array.isArray(props)) {
        props = [
            props
        ];
    }
    var obj = {};
    for (var key of props){
        obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
};
var unwrapNodes = function unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { mode = 'lowest', split = false, voids = false } = options;
        var { at = editor.selection, match } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
        }
        if (Path.isPath(at)) {
            at = Editor.range(editor, at);
        }
        var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
        var matches = Editor.nodes(editor, {
            at,
            match,
            mode,
            voids
        });
        var pathRefs = Array.from(matches, (_ref)=>{
            var [, p] = _ref;
            return Editor.pathRef(editor, p);
        }).reverse();
        var _loop = function _loop() {
            var path = pathRef.unref();
            var [node] = Editor.node(editor, path);
            var range = Editor.range(editor, path);
            if (split && rangeRef) {
                range = Range.intersection(rangeRef.current, range);
            }
            Transforms.liftNodes(editor, {
                at: range,
                match: (n)=>Element.isAncestor(node) && node.children.includes(n),
                voids
            });
        };
        for (var pathRef of pathRefs){
            _loop();
        }
        if (rangeRef) {
            rangeRef.unref();
        }
    });
};
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var wrapNodes = function wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, ()=>{
        var { mode = 'lowest', split = false, voids = false } = options;
        var { match, at = editor.selection } = options;
        if (!at) {
            return;
        }
        if (match == null) {
            if (Path.isPath(at)) {
                match = matchPath(editor, at);
            } else if (editor.isInline(element)) {
                match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);
            } else {
                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);
            }
        }
        if (split && Range.isRange(at)) {
            var [start, end] = Range.edges(at);
            var rangeRef = Editor.rangeRef(editor, at, {
                affinity: 'inward'
            });
            Transforms.splitNodes(editor, {
                at: end,
                match,
                voids
            });
            Transforms.splitNodes(editor, {
                at: start,
                match,
                voids
            });
            at = rangeRef.unref();
            if (options.at == null) {
                Transforms.select(editor, at);
            }
        }
        var roots = Array.from(Editor.nodes(editor, {
            at,
            match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),
            mode: 'lowest',
            voids
        }));
        var _loop = function _loop() {
            var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
            if (!a) {
                return 0; // continue
            }
            var matches = Array.from(Editor.nodes(editor, {
                at: a,
                match,
                mode,
                voids
            }));
            if (matches.length > 0) {
                var [first] = matches;
                var last = matches[matches.length - 1];
                var [, firstPath] = first;
                var [, lastPath] = last;
                if (firstPath.length === 0 && lastPath.length === 0) {
                    // if there's no matching parent - usually means the node is an editor - don't do anything
                    return 0; // continue
                }
                var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
                var range = Editor.range(editor, firstPath, lastPath);
                var commonNodeEntry = Editor.node(editor, commonPath);
                var [commonNode] = commonNodeEntry;
                var depth = commonPath.length + 1;
                var wrapperPath = Path.next(lastPath.slice(0, depth));
                var wrapper = _objectSpread(_objectSpread({}, element), {}, {
                    children: []
                });
                Transforms.insertNodes(editor, wrapper, {
                    at: wrapperPath,
                    voids
                });
                Transforms.moveNodes(editor, {
                    at: range,
                    match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),
                    to: wrapperPath.concat(0),
                    voids
                });
            }
        }, _ret;
        for (var [, rootPath] of roots){
            _ret = _loop();
            if (_ret === 0) continue;
        }
    });
};
/**
 * Create a new Slate `Editor` object.
 */ var createEditor = ()=>{
    var editor = {
        children: [],
        operations: [],
        selection: null,
        marks: null,
        isElementReadOnly: ()=>false,
        isInline: ()=>false,
        isSelectable: ()=>true,
        isVoid: ()=>false,
        markableVoid: ()=>false,
        onChange: ()=>{},
        // Core
        apply: function apply$1() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return apply(editor, ...args);
        },
        // Editor
        addMark: function addMark$1() {
            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
                args[_key2] = arguments[_key2];
            }
            return addMark(editor, ...args);
        },
        deleteBackward: function deleteBackward$1() {
            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
                args[_key3] = arguments[_key3];
            }
            return deleteBackward(editor, ...args);
        },
        deleteForward: function deleteForward$1() {
            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
                args[_key4] = arguments[_key4];
            }
            return deleteForward(editor, ...args);
        },
        deleteFragment: function deleteFragment$1() {
            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
                args[_key5] = arguments[_key5];
            }
            return deleteFragment(editor, ...args);
        },
        getFragment: function getFragment$1() {
            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                args[_key6] = arguments[_key6];
            }
            return getFragment(editor, ...args);
        },
        insertBreak: function insertBreak$1() {
            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){
                args[_key7] = arguments[_key7];
            }
            return insertBreak(editor, ...args);
        },
        insertSoftBreak: function insertSoftBreak$1() {
            for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){
                args[_key8] = arguments[_key8];
            }
            return insertSoftBreak(editor, ...args);
        },
        insertFragment: function insertFragment$1() {
            for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){
                args[_key9] = arguments[_key9];
            }
            return insertFragment(editor, ...args);
        },
        insertNode: function insertNode$1() {
            for(var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){
                args[_key10] = arguments[_key10];
            }
            return insertNode(editor, ...args);
        },
        insertText: function insertText$1() {
            for(var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++){
                args[_key11] = arguments[_key11];
            }
            return insertText(editor, ...args);
        },
        normalizeNode: function normalizeNode$1() {
            for(var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++){
                args[_key12] = arguments[_key12];
            }
            return normalizeNode(editor, ...args);
        },
        removeMark: function removeMark$1() {
            for(var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++){
                args[_key13] = arguments[_key13];
            }
            return removeMark(editor, ...args);
        },
        getDirtyPaths: function getDirtyPaths$1() {
            for(var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++){
                args[_key14] = arguments[_key14];
            }
            return getDirtyPaths(editor, ...args);
        },
        shouldNormalize: function shouldNormalize$1() {
            for(var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++){
                args[_key15] = arguments[_key15];
            }
            return shouldNormalize(editor, ...args);
        },
        // Editor interface
        above: function above$1() {
            for(var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++){
                args[_key16] = arguments[_key16];
            }
            return above(editor, ...args);
        },
        after: function after$1() {
            for(var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++){
                args[_key17] = arguments[_key17];
            }
            return after(editor, ...args);
        },
        before: function before$1() {
            for(var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++){
                args[_key18] = arguments[_key18];
            }
            return before(editor, ...args);
        },
        collapse: function collapse$1() {
            for(var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++){
                args[_key19] = arguments[_key19];
            }
            return collapse(editor, ...args);
        },
        delete: function _delete() {
            for(var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++){
                args[_key20] = arguments[_key20];
            }
            return deleteText(editor, ...args);
        },
        deselect: function deselect$1() {
            for(var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++){
                args[_key21] = arguments[_key21];
            }
            return deselect(editor, ...args);
        },
        edges: function edges$1() {
            for(var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++){
                args[_key22] = arguments[_key22];
            }
            return edges(editor, ...args);
        },
        elementReadOnly: function elementReadOnly$1() {
            for(var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++){
                args[_key23] = arguments[_key23];
            }
            return elementReadOnly(editor, ...args);
        },
        end: function end$1() {
            for(var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++){
                args[_key24] = arguments[_key24];
            }
            return end(editor, ...args);
        },
        first: function first$1() {
            for(var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++){
                args[_key25] = arguments[_key25];
            }
            return first(editor, ...args);
        },
        fragment: function fragment$1() {
            for(var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++){
                args[_key26] = arguments[_key26];
            }
            return fragment(editor, ...args);
        },
        getMarks: function getMarks() {
            for(var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++){
                args[_key27] = arguments[_key27];
            }
            return marks(editor, ...args);
        },
        hasBlocks: function hasBlocks$1() {
            for(var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++){
                args[_key28] = arguments[_key28];
            }
            return hasBlocks(editor, ...args);
        },
        hasInlines: function hasInlines$1() {
            for(var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++){
                args[_key29] = arguments[_key29];
            }
            return hasInlines(editor, ...args);
        },
        hasPath: function hasPath$1() {
            for(var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++){
                args[_key30] = arguments[_key30];
            }
            return hasPath(editor, ...args);
        },
        hasTexts: function hasTexts$1() {
            for(var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++){
                args[_key31] = arguments[_key31];
            }
            return hasTexts(editor, ...args);
        },
        insertNodes: function insertNodes$1() {
            for(var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++){
                args[_key32] = arguments[_key32];
            }
            return insertNodes(editor, ...args);
        },
        isBlock: function isBlock$1() {
            for(var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++){
                args[_key33] = arguments[_key33];
            }
            return isBlock(editor, ...args);
        },
        isEdge: function isEdge$1() {
            for(var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++){
                args[_key34] = arguments[_key34];
            }
            return isEdge(editor, ...args);
        },
        isEmpty: function isEmpty$1() {
            for(var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++){
                args[_key35] = arguments[_key35];
            }
            return isEmpty(editor, ...args);
        },
        isEnd: function isEnd$1() {
            for(var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++){
                args[_key36] = arguments[_key36];
            }
            return isEnd(editor, ...args);
        },
        isNormalizing: function isNormalizing$1() {
            for(var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++){
                args[_key37] = arguments[_key37];
            }
            return isNormalizing(editor, ...args);
        },
        isStart: function isStart$1() {
            for(var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++){
                args[_key38] = arguments[_key38];
            }
            return isStart(editor, ...args);
        },
        last: function last$1() {
            for(var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++){
                args[_key39] = arguments[_key39];
            }
            return last(editor, ...args);
        },
        leaf: function leaf$1() {
            for(var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++){
                args[_key40] = arguments[_key40];
            }
            return leaf(editor, ...args);
        },
        levels: function levels$1() {
            for(var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++){
                args[_key41] = arguments[_key41];
            }
            return levels(editor, ...args);
        },
        liftNodes: function liftNodes$1() {
            for(var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++){
                args[_key42] = arguments[_key42];
            }
            return liftNodes(editor, ...args);
        },
        mergeNodes: function mergeNodes$1() {
            for(var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++){
                args[_key43] = arguments[_key43];
            }
            return mergeNodes(editor, ...args);
        },
        move: function move$1() {
            for(var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++){
                args[_key44] = arguments[_key44];
            }
            return move(editor, ...args);
        },
        moveNodes: function moveNodes$1() {
            for(var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++){
                args[_key45] = arguments[_key45];
            }
            return moveNodes(editor, ...args);
        },
        next: function next$1() {
            for(var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++){
                args[_key46] = arguments[_key46];
            }
            return next(editor, ...args);
        },
        node: function node$1() {
            for(var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++){
                args[_key47] = arguments[_key47];
            }
            return node(editor, ...args);
        },
        nodes: function nodes$1() {
            for(var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++){
                args[_key48] = arguments[_key48];
            }
            return nodes(editor, ...args);
        },
        normalize: function normalize$1() {
            for(var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++){
                args[_key49] = arguments[_key49];
            }
            return normalize(editor, ...args);
        },
        parent: function parent$1() {
            for(var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++){
                args[_key50] = arguments[_key50];
            }
            return parent(editor, ...args);
        },
        path: function path$1() {
            for(var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++){
                args[_key51] = arguments[_key51];
            }
            return path(editor, ...args);
        },
        pathRef: function pathRef$1() {
            for(var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++){
                args[_key52] = arguments[_key52];
            }
            return pathRef(editor, ...args);
        },
        pathRefs: function pathRefs$1() {
            for(var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++){
                args[_key53] = arguments[_key53];
            }
            return pathRefs(editor, ...args);
        },
        point: function point$1() {
            for(var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++){
                args[_key54] = arguments[_key54];
            }
            return point(editor, ...args);
        },
        pointRef: function pointRef$1() {
            for(var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++){
                args[_key55] = arguments[_key55];
            }
            return pointRef(editor, ...args);
        },
        pointRefs: function pointRefs$1() {
            for(var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++){
                args[_key56] = arguments[_key56];
            }
            return pointRefs(editor, ...args);
        },
        positions: function positions$1() {
            for(var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++){
                args[_key57] = arguments[_key57];
            }
            return positions(editor, ...args);
        },
        previous: function previous$1() {
            for(var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++){
                args[_key58] = arguments[_key58];
            }
            return previous(editor, ...args);
        },
        range: function range$1() {
            for(var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++){
                args[_key59] = arguments[_key59];
            }
            return range(editor, ...args);
        },
        rangeRef: function rangeRef$1() {
            for(var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++){
                args[_key60] = arguments[_key60];
            }
            return rangeRef(editor, ...args);
        },
        rangeRefs: function rangeRefs$1() {
            for(var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++){
                args[_key61] = arguments[_key61];
            }
            return rangeRefs(editor, ...args);
        },
        removeNodes: function removeNodes$1() {
            for(var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++){
                args[_key62] = arguments[_key62];
            }
            return removeNodes(editor, ...args);
        },
        select: function select$1() {
            for(var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++){
                args[_key63] = arguments[_key63];
            }
            return select(editor, ...args);
        },
        setNodes: function setNodes$1() {
            for(var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++){
                args[_key64] = arguments[_key64];
            }
            return setNodes(editor, ...args);
        },
        setNormalizing: function setNormalizing$1() {
            for(var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++){
                args[_key65] = arguments[_key65];
            }
            return setNormalizing(editor, ...args);
        },
        setPoint: function setPoint$1() {
            for(var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++){
                args[_key66] = arguments[_key66];
            }
            return setPoint(editor, ...args);
        },
        setSelection: function setSelection$1() {
            for(var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++){
                args[_key67] = arguments[_key67];
            }
            return setSelection(editor, ...args);
        },
        splitNodes: function splitNodes$1() {
            for(var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++){
                args[_key68] = arguments[_key68];
            }
            return splitNodes(editor, ...args);
        },
        start: function start$1() {
            for(var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++){
                args[_key69] = arguments[_key69];
            }
            return start(editor, ...args);
        },
        string: function string$1() {
            for(var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++){
                args[_key70] = arguments[_key70];
            }
            return string(editor, ...args);
        },
        unhangRange: function unhangRange$1() {
            for(var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++){
                args[_key71] = arguments[_key71];
            }
            return unhangRange(editor, ...args);
        },
        unsetNodes: function unsetNodes$1() {
            for(var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++){
                args[_key72] = arguments[_key72];
            }
            return unsetNodes(editor, ...args);
        },
        unwrapNodes: function unwrapNodes$1() {
            for(var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++){
                args[_key73] = arguments[_key73];
            }
            return unwrapNodes(editor, ...args);
        },
        void: function _void() {
            for(var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++){
                args[_key74] = arguments[_key74];
            }
            return getVoid(editor, ...args);
        },
        withoutNormalizing: function withoutNormalizing$1() {
            for(var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++){
                args[_key75] = arguments[_key75];
            }
            return withoutNormalizing(editor, ...args);
        },
        wrapNodes: function wrapNodes$1() {
            for(var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++){
                args[_key76] = arguments[_key76];
            }
            return wrapNodes(editor, ...args);
        },
        shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {
            for(var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++){
                args[_key77] = arguments[_key77];
            }
            return shouldMergeNodesRemovePrevNode(editor, ...args);
        }
    };
    return editor;
};
;
 //# sourceMappingURL=index.es.js.map
}}),
"[project]/node_modules/slate-history/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HISTORY": (()=>HISTORY),
    "History": (()=>History),
    "HistoryEditor": (()=>HistoryEditor),
    "MERGING": (()=>MERGING),
    "SAVING": (()=>SAVING),
    "SPLITTING_ONCE": (()=>SPLITTING_ONCE),
    "withHistory": (()=>withHistory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)");
;
;
// eslint-disable-next-line no-redeclare
var History = {
    /**
   * Check if a value is a `History` object.
   */ isHistory (value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Operation"].isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Operation"].isOperationList(value.undos[0].operations));
    }
};
/**
 * Weakmaps for attaching state to the editor.
 */ var HISTORY = new WeakMap();
var SAVING = new WeakMap();
var MERGING = new WeakMap();
var SPLITTING_ONCE = new WeakMap();
// eslint-disable-next-line no-redeclare
var HistoryEditor = {
    /**
   * Check if a value is a `HistoryEditor` object.
   */ isHistoryEditor (value) {
        return History.isHistory(value.history) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(value);
    },
    /**
   * Get the merge flag's current value.
   */ isMerging (editor) {
        return MERGING.get(editor);
    },
    /**
   * Get the splitting once flag's current value.
   */ isSplittingOnce (editor) {
        return SPLITTING_ONCE.get(editor);
    },
    setSplittingOnce (editor, value) {
        SPLITTING_ONCE.set(editor, value);
    },
    /**
   * Get the saving flag's current value.
   */ isSaving (editor) {
        return SAVING.get(editor);
    },
    /**
   * Redo to the previous saved state.
   */ redo (editor) {
        editor.redo();
    },
    /**
   * Undo to the previous saved state.
   */ undo (editor) {
        editor.undo();
    },
    /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */ withMerging (editor, fn) {
        var prev = HistoryEditor.isMerging(editor);
        MERGING.set(editor, true);
        fn();
        MERGING.set(editor, prev);
    },
    /**
   * Apply a series of changes inside a synchronous `fn`, ensuring that the first
   * operation starts a new batch in the history. Subsequent operations will be
   * merged as usual.
   */ withNewBatch (editor, fn) {
        var prev = HistoryEditor.isMerging(editor);
        MERGING.set(editor, true);
        SPLITTING_ONCE.set(editor, true);
        fn();
        MERGING.set(editor, prev);
        SPLITTING_ONCE.delete(editor);
    },
    /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */ withoutMerging (editor, fn) {
        var prev = HistoryEditor.isMerging(editor);
        MERGING.set(editor, false);
        fn();
        MERGING.set(editor, prev);
    },
    /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */ withoutSaving (editor, fn) {
        var prev = HistoryEditor.isSaving(editor);
        SAVING.set(editor, false);
        fn();
        SAVING.set(editor, prev);
    }
};
/**
 * The `withHistory` plugin keeps track of the operation history of a Slate
 * editor as operations are applied to it, using undo and redo stacks.
 *
 * If you are using TypeScript, you must extend Slate's CustomTypes to use
 * this plugin.
 *
 * See https://docs.slatejs.org/concepts/11-typescript to learn how.
 */ var withHistory = (editor)=>{
    var e = editor;
    var { apply } = e;
    e.history = {
        undos: [],
        redos: []
    };
    e.redo = ()=>{
        var { history } = e;
        var { redos } = history;
        if (redos.length > 0) {
            var batch = redos[redos.length - 1];
            if (batch.selectionBefore) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setSelection(e, batch.selectionBefore);
            }
            HistoryEditor.withoutSaving(e, ()=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(e, ()=>{
                    for (var op of batch.operations){
                        e.apply(op);
                    }
                });
            });
            history.redos.pop();
            e.writeHistory('undos', batch);
        }
    };
    e.undo = ()=>{
        var { history } = e;
        var { undos } = history;
        if (undos.length > 0) {
            var batch = undos[undos.length - 1];
            HistoryEditor.withoutSaving(e, ()=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(e, ()=>{
                    var inverseOps = batch.operations.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Operation"].inverse).reverse();
                    for (var op of inverseOps){
                        e.apply(op);
                    }
                    if (batch.selectionBefore) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setSelection(e, batch.selectionBefore);
                    }
                });
            });
            e.writeHistory('redos', batch);
            history.undos.pop();
        }
    };
    e.apply = (op)=>{
        var { operations, history } = e;
        var { undos } = history;
        var lastBatch = undos[undos.length - 1];
        var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
        var save = HistoryEditor.isSaving(e);
        var merge = HistoryEditor.isMerging(e);
        if (save == null) {
            save = shouldSave(op);
        }
        if (save) {
            if (merge == null) {
                if (lastBatch == null) {
                    merge = false;
                } else if (operations.length !== 0) {
                    merge = true;
                } else {
                    merge = shouldMerge(op, lastOp);
                }
            }
            if (HistoryEditor.isSplittingOnce(e)) {
                merge = false;
                HistoryEditor.setSplittingOnce(e, undefined);
            }
            if (lastBatch && merge) {
                lastBatch.operations.push(op);
            } else {
                var batch = {
                    operations: [
                        op
                    ],
                    selectionBefore: e.selection
                };
                e.writeHistory('undos', batch);
            }
            while(undos.length > 100){
                undos.shift();
            }
            history.redos = [];
        }
        apply(op);
    };
    e.writeHistory = (stack, batch)=>{
        e.history[stack].push(batch);
    };
    return e;
};
/**
 * Check whether to merge an operation into the previous operation.
 */ var shouldMerge = (op, prev)=>{
    if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, prev.path)) {
        return true;
    }
    if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, prev.path)) {
        return true;
    }
    return false;
};
/**
 * Check whether an operation needs to be saved to the history.
 */ var shouldSave = (op, prev)=>{
    if (op.type === 'set_selection') {
        return false;
    }
    return true;
};
;
 //# sourceMappingURL=index.es.js.map
}}),
"[project]/node_modules/is-hotkey/lib/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Constants.
 */ var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var MODIFIERS = {
    alt: 'altKey',
    control: 'ctrlKey',
    meta: 'metaKey',
    shift: 'shiftKey'
};
var ALIASES = {
    add: '+',
    break: 'pause',
    cmd: 'meta',
    command: 'meta',
    ctl: 'control',
    ctrl: 'control',
    del: 'delete',
    down: 'arrowdown',
    esc: 'escape',
    ins: 'insert',
    left: 'arrowleft',
    mod: IS_MAC ? 'meta' : 'control',
    opt: 'alt',
    option: 'alt',
    return: 'enter',
    right: 'arrowright',
    space: ' ',
    spacebar: ' ',
    up: 'arrowup',
    win: 'meta',
    windows: 'meta'
};
var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    ' ': 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222
};
for(var f = 1; f < 20; f++){
    CODES['f' + f] = 111 + f;
}
/**
 * Is hotkey?
 */ function isHotkey(hotkey, options, event) {
    if (options && !('byKey' in options)) {
        event = options;
        options = null;
    }
    if (!Array.isArray(hotkey)) {
        hotkey = [
            hotkey
        ];
    }
    var array = hotkey.map(function(string) {
        return parseHotkey(string, options);
    });
    var check = function check(e) {
        return array.some(function(object) {
            return compareHotkey(object, e);
        });
    };
    var ret = event == null ? check : check(event);
    return ret;
}
function isCodeHotkey(hotkey, event) {
    return isHotkey(hotkey, event);
}
function isKeyHotkey(hotkey, event) {
    return isHotkey(hotkey, {
        byKey: true
    }, event);
}
/**
 * Parse.
 */ function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    // Special case to handle the `+` key since we use it as a separator.
    hotkey = hotkey.replace('++', '+add');
    var values = hotkey.split('+');
    var length = values.length;
    // Ensure that all the modifiers are set to false unless the hotkey has them.
    for(var k in MODIFIERS){
        ret[MODIFIERS[k]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
        for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var value = _step.value;
            var optional = value.endsWith('?') && value.length > 1;
            if (optional) {
                value = value.slice(0, -1);
            }
            var name = toKeyName(value);
            var modifier = MODIFIERS[name];
            if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {
                throw new TypeError('Unknown modifier: "' + value + '"');
            }
            if (length === 1 || !modifier) {
                if (byKey) {
                    ret.key = name;
                } else {
                    ret.which = toKeyCode(value);
                }
            }
            if (modifier) {
                ret[modifier] = optional ? null : true;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return ret;
}
/**
 * Compare.
 */ function compareHotkey(object, event) {
    for(var key in object){
        var expected = object[key];
        var actual = void 0;
        if (expected == null) {
            continue;
        }
        if (key === 'key' && event.key != null) {
            actual = event.key.toLowerCase();
        } else if (key === 'which') {
            actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
            actual = event[key];
        }
        if (actual == null && expected === false) {
            continue;
        }
        if (actual !== expected) {
            return false;
        }
    }
    return true;
}
/**
 * Utils.
 */ function toKeyCode(name) {
    name = toKeyName(name);
    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
    return code;
}
function toKeyName(name) {
    name = name.toLowerCase();
    name = ALIASES[name] || name;
    return name;
}
/**
 * Export.
 */ exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
}}),
"[project]/node_modules/slate-dom/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CAN_USE_DOM": (()=>CAN_USE_DOM),
    "DOMEditor": (()=>DOMEditor),
    "DOMElement": (()=>DOMElement),
    "DOMNode": (()=>DOMNode),
    "DOMRange": (()=>DOMRange),
    "DOMSelection": (()=>DOMSelection),
    "DOMStaticRange": (()=>DOMStaticRange),
    "DOMText": (()=>DOMText),
    "EDITOR_TO_ELEMENT": (()=>EDITOR_TO_ELEMENT),
    "EDITOR_TO_FORCE_RENDER": (()=>EDITOR_TO_FORCE_RENDER),
    "EDITOR_TO_KEY_TO_ELEMENT": (()=>EDITOR_TO_KEY_TO_ELEMENT),
    "EDITOR_TO_ON_CHANGE": (()=>EDITOR_TO_ON_CHANGE),
    "EDITOR_TO_PENDING_ACTION": (()=>EDITOR_TO_PENDING_ACTION),
    "EDITOR_TO_PENDING_DIFFS": (()=>EDITOR_TO_PENDING_DIFFS),
    "EDITOR_TO_PENDING_INSERTION_MARKS": (()=>EDITOR_TO_PENDING_INSERTION_MARKS),
    "EDITOR_TO_PENDING_SELECTION": (()=>EDITOR_TO_PENDING_SELECTION),
    "EDITOR_TO_PLACEHOLDER_ELEMENT": (()=>EDITOR_TO_PLACEHOLDER_ELEMENT),
    "EDITOR_TO_SCHEDULE_FLUSH": (()=>EDITOR_TO_SCHEDULE_FLUSH),
    "EDITOR_TO_USER_MARKS": (()=>EDITOR_TO_USER_MARKS),
    "EDITOR_TO_USER_SELECTION": (()=>EDITOR_TO_USER_SELECTION),
    "EDITOR_TO_WINDOW": (()=>EDITOR_TO_WINDOW),
    "ELEMENT_TO_NODE": (()=>ELEMENT_TO_NODE),
    "HAS_BEFORE_INPUT_SUPPORT": (()=>HAS_BEFORE_INPUT_SUPPORT),
    "Hotkeys": (()=>hotkeys),
    "IS_ANDROID": (()=>IS_ANDROID),
    "IS_CHROME": (()=>IS_CHROME),
    "IS_COMPOSING": (()=>IS_COMPOSING),
    "IS_FIREFOX": (()=>IS_FIREFOX),
    "IS_FIREFOX_LEGACY": (()=>IS_FIREFOX_LEGACY),
    "IS_FOCUSED": (()=>IS_FOCUSED),
    "IS_IOS": (()=>IS_IOS),
    "IS_NODE_MAP_DIRTY": (()=>IS_NODE_MAP_DIRTY),
    "IS_READ_ONLY": (()=>IS_READ_ONLY),
    "IS_UC_MOBILE": (()=>IS_UC_MOBILE),
    "IS_WEBKIT": (()=>IS_WEBKIT),
    "IS_WECHATBROWSER": (()=>IS_WECHATBROWSER),
    "Key": (()=>Key),
    "MARK_PLACEHOLDER_SYMBOL": (()=>MARK_PLACEHOLDER_SYMBOL),
    "NODE_TO_ELEMENT": (()=>NODE_TO_ELEMENT),
    "NODE_TO_INDEX": (()=>NODE_TO_INDEX),
    "NODE_TO_KEY": (()=>NODE_TO_KEY),
    "NODE_TO_PARENT": (()=>NODE_TO_PARENT),
    "PLACEHOLDER_SYMBOL": (()=>PLACEHOLDER_SYMBOL),
    "TRIPLE_CLICK": (()=>TRIPLE_CLICK),
    "applyStringDiff": (()=>applyStringDiff),
    "getActiveElement": (()=>getActiveElement),
    "getDefaultView": (()=>getDefaultView),
    "getSelection": (()=>getSelection),
    "hasShadowRoot": (()=>hasShadowRoot),
    "isAfter": (()=>isAfter),
    "isBefore": (()=>isBefore),
    "isDOMElement": (()=>isDOMElement),
    "isDOMNode": (()=>isDOMNode),
    "isDOMSelection": (()=>isDOMSelection),
    "isElementDecorationsEqual": (()=>isElementDecorationsEqual),
    "isPlainTextOnlyPaste": (()=>isPlainTextOnlyPaste),
    "isTextDecorationsEqual": (()=>isTextDecorationsEqual),
    "isTrackedMutation": (()=>isTrackedMutation),
    "mergeStringDiffs": (()=>mergeStringDiffs),
    "normalizeDOMPoint": (()=>normalizeDOMPoint),
    "normalizePoint": (()=>normalizePoint),
    "normalizeRange": (()=>normalizeRange),
    "normalizeStringDiff": (()=>normalizeStringDiff),
    "targetRange": (()=>targetRange),
    "verifyDiffState": (()=>verifyDiffState),
    "withDOM": (()=>withDOM)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/is-hotkey/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)");
;
;
/**
 * Types.
 */ // COMPAT: This is required to prevent TypeScript aliases from doing some very
// weird things for Slate's types with the same name as globals. (2019/11/27)
// https://github.com/microsoft/TypeScript/issues/35002
var DOMNode = globalThis.Node;
var DOMElement = globalThis.Element;
var DOMText = globalThis.Text;
var DOMRange = globalThis.Range;
var DOMSelection = globalThis.Selection;
var DOMStaticRange = globalThis.StaticRange;
/**
 * Returns the host window of a DOM node
 */ var getDefaultView = (value)=>{
    return value && value.ownerDocument && value.ownerDocument.defaultView || null;
};
/**
 * Check if a DOM node is a comment node.
 */ var isDOMComment = (value)=>{
    return isDOMNode(value) && value.nodeType === 8;
};
/**
 * Check if a DOM node is an element node.
 */ var isDOMElement = (value)=>{
    return isDOMNode(value) && value.nodeType === 1;
};
/**
 * Check if a value is a DOM node.
 */ var isDOMNode = (value)=>{
    var window1 = getDefaultView(value);
    return !!window1 && value instanceof window1.Node;
};
/**
 * Check if a value is a DOM selection.
 */ var isDOMSelection = (value)=>{
    var window1 = value && value.anchorNode && getDefaultView(value.anchorNode);
    return !!window1 && value instanceof window1.Selection;
};
/**
 * Check if a DOM node is an element node.
 */ var isDOMText = (value)=>{
    return isDOMNode(value) && value.nodeType === 3;
};
/**
 * Checks whether a paste event is a plaintext-only event.
 */ var isPlainTextOnlyPaste = (event)=>{
    return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;
};
/**
 * Normalize a DOM point so that it always refers to a text node.
 */ var normalizeDOMPoint = (domPoint)=>{
    var [node, offset] = domPoint;
    // If it's an element node, its offset refers to the index of its children
    // including comment nodes, so try to find the right text child node.
    if (isDOMElement(node) && node.childNodes.length) {
        var isLast = offset === node.childNodes.length;
        var index = isLast ? offset - 1 : offset;
        [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');
        // If the editable child found is in front of input offset, we instead seek to its end
        isLast = index < offset;
        // If the node has children, traverse until we have a leaf node. Leaf nodes
        // can be either text nodes, or other void DOM nodes.
        while(isDOMElement(node) && node.childNodes.length){
            var i = isLast ? node.childNodes.length - 1 : 0;
            node = getEditableChild(node, i, isLast ? 'backward' : 'forward');
        }
        // Determine the new offset inside the text node.
        offset = isLast && node.textContent != null ? node.textContent.length : 0;
    }
    // Return the node and offset.
    return [
        node,
        offset
    ];
};
/**
 * Determines whether the active element is nested within a shadowRoot
 */ var hasShadowRoot = (node)=>{
    var parent = node && node.parentNode;
    while(parent){
        if (parent.toString() === '[object ShadowRoot]') {
            return true;
        }
        parent = parent.parentNode;
    }
    return false;
};
/**
 * Get the nearest editable child and index at `index` in a `parent`, preferring
 * `direction`.
 */ var getEditableChildAndIndex = (parent, index, direction)=>{
    var { childNodes } = parent;
    var child = childNodes[index];
    var i = index;
    var triedForward = false;
    var triedBackward = false;
    // While the child is a comment node, or an element node with no children,
    // keep iterating to find a sibling non-void, non-comment node.
    while(isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false'){
        if (triedForward && triedBackward) {
            break;
        }
        if (i >= childNodes.length) {
            triedForward = true;
            i = index - 1;
            direction = 'backward';
            continue;
        }
        if (i < 0) {
            triedBackward = true;
            i = index + 1;
            direction = 'forward';
            continue;
        }
        child = childNodes[i];
        index = i;
        i += direction === 'forward' ? 1 : -1;
    }
    return [
        child,
        index
    ];
};
/**
 * Get the nearest editable child at `index` in a `parent`, preferring
 * `direction`.
 */ var getEditableChild = (parent, index, direction)=>{
    var [child] = getEditableChildAndIndex(parent, index, direction);
    return child;
};
/**
 * Get a plaintext representation of the content of a node, accounting for block
 * elements which get a newline appended.
 *
 * The domNode must be attached to the DOM.
 */ var getPlainText = (domNode)=>{
    var text = '';
    if (isDOMText(domNode) && domNode.nodeValue) {
        return domNode.nodeValue;
    }
    if (isDOMElement(domNode)) {
        for (var childNode of Array.from(domNode.childNodes)){
            text += getPlainText(childNode);
        }
        var display = getComputedStyle(domNode).getPropertyValue('display');
        if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {
            text += '\n';
        }
    }
    return text;
};
/**
 * Get x-slate-fragment attribute from data-slate-fragment
 */ var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer)=>{
    var htmlData = dataTransfer.getData('text/html');
    var [, fragment] = htmlData.match(catchSlateFragment) || [];
    return fragment;
};
/**
 * Get the dom selection from Shadow Root if possible, otherwise from the document
 */ var getSelection = (root)=>{
    if (root.getSelection != null) {
        return root.getSelection();
    }
    return document.getSelection();
};
/**
 * Check whether a mutation originates from a editable element inside the editor.
 */ var isTrackedMutation = (editor, mutation, batch)=>{
    var { target } = mutation;
    if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
        return false;
    }
    var { document: document1 } = DOMEditor.getWindow(editor);
    if (document1.contains(target)) {
        return DOMEditor.hasDOMNode(editor, target, {
            editable: true
        });
    }
    var parentMutation = batch.find((_ref)=>{
        var { addedNodes, removedNodes } = _ref;
        for (var node of addedNodes){
            if (node === target || node.contains(target)) {
                return true;
            }
        }
        for (var _node of removedNodes){
            if (_node === target || _node.contains(target)) {
                return true;
            }
        }
    });
    if (!parentMutation || parentMutation === mutation) {
        return false;
    }
    // Target add/remove is tracked. Track the mutation if we track the parent mutation.
    return isTrackedMutation(editor, parentMutation, batch);
};
/**
 * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.
 */ var getActiveElement = ()=>{
    var activeElement = document.activeElement;
    while((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement){
        var _activeElement, _activeElement$shadow, _activeElement2;
        activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;
    }
    return activeElement;
};
/**
 * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.
 */ var isBefore = (node, otherNode)=>Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);
/**
 * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.
 */ var isAfter = (node, otherNode)=>Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);
var _navigator$userAgent$, _navigator$userAgent$2;
var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);
// "modern" Edge was released at 79.x
var IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);
// Native `beforeInput` events don't work well with react on Chrome 75
// and older, Chrome 76+ can use `beforeInput` though.
var IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
// Firefox did not support `beforeInput` until `v87`.
var IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
// UC mobile browser
var IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);
// Wechat browser (not including mac wechat)
var IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)
// Check if DOM is available as React does internally.
// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js
var CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
// Check if the browser is Safari and older than 17
typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\/(\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\/(\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);
// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event
// Chrome Legacy doesn't support `beforeinput` correctly
var HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === 'function';
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * An auto-incrementing identifier for keys.
 */ var n = 0;
/**
 * A class that keeps track of a key string. We use a full class here because we
 * want to be able to use them as keys in `WeakMap` objects.
 */ class Key {
    constructor(){
        _defineProperty(this, "id", void 0);
        this.id = "".concat(n++);
    }
}
/**
 * Two weak maps that allow us rebuild a path given a node. They are populated
 * at render time such that after a render occurs we can always backtrack.
 */ var IS_NODE_MAP_DIRTY = new WeakMap();
var NODE_TO_INDEX = new WeakMap();
var NODE_TO_PARENT = new WeakMap();
/**
 * Weak maps that allow us to go between Slate nodes and DOM nodes. These
 * are used to resolve DOM event-related logic into Slate actions.
 */ var EDITOR_TO_WINDOW = new WeakMap();
var EDITOR_TO_ELEMENT = new WeakMap();
var EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();
var ELEMENT_TO_NODE = new WeakMap();
var NODE_TO_ELEMENT = new WeakMap();
var NODE_TO_KEY = new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();
/**
 * Weak maps for storing editor-related state.
 */ var IS_READ_ONLY = new WeakMap();
var IS_FOCUSED = new WeakMap();
var IS_COMPOSING = new WeakMap();
var EDITOR_TO_USER_SELECTION = new WeakMap();
/**
 * Weak map for associating the context `onChange` context with the plugin.
 */ var EDITOR_TO_ON_CHANGE = new WeakMap();
/**
 * Weak maps for saving pending state on composition stage.
 */ var EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();
var EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();
var EDITOR_TO_USER_MARKS = new WeakMap();
/**
 * Android input handling specific weak-maps
 */ var EDITOR_TO_PENDING_DIFFS = new WeakMap();
var EDITOR_TO_PENDING_ACTION = new WeakMap();
var EDITOR_TO_PENDING_SELECTION = new WeakMap();
var EDITOR_TO_FORCE_RENDER = new WeakMap();
/**
 * Symbols.
 */ var PLACEHOLDER_SYMBOL = Symbol('placeholder');
var MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');
// eslint-disable-next-line no-redeclare
var DOMEditor = {
    androidPendingDiffs: (editor)=>EDITOR_TO_PENDING_DIFFS.get(editor),
    androidScheduleFlush: (editor)=>{
        var _EDITOR_TO_SCHEDULE_F;
        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
    },
    blur: (editor)=>{
        var el = DOMEditor.toDOMNode(editor, editor);
        var root = DOMEditor.findDocumentOrShadowRoot(editor);
        IS_FOCUSED.set(editor, false);
        if (root.activeElement === el) {
            el.blur();
        }
    },
    deselect: (editor)=>{
        var { selection } = editor;
        var root = DOMEditor.findDocumentOrShadowRoot(editor);
        var domSelection = getSelection(root);
        if (domSelection && domSelection.rangeCount > 0) {
            domSelection.removeAllRanges();
        }
        if (selection) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
        }
    },
    findDocumentOrShadowRoot: (editor)=>{
        var el = DOMEditor.toDOMNode(editor, editor);
        var root = el.getRootNode();
        if (root instanceof Document || root instanceof ShadowRoot) {
            return root;
        }
        return el.ownerDocument;
    },
    findEventRange: (editor, event)=>{
        if ('nativeEvent' in event) {
            event = event.nativeEvent;
        }
        var { clientX: x, clientY: y, target } = event;
        if (x == null || y == null) {
            throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
        }
        var node = DOMEditor.toSlateNode(editor, event.target);
        var path = DOMEditor.findPath(editor, node);
        // If the drop target is inside a void node, move it into either the
        // next or previous node, depending on which side the `x` and `y`
        // coordinates are closest to.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, node)) {
            var rect = target.getBoundingClientRect();
            var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;
            var edge = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].point(editor, path, {
                edge: isPrev ? 'start' : 'end'
            });
            var point = isPrev ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].before(editor, edge) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].after(editor, edge);
            if (point) {
                var _range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, point);
                return _range;
            }
        }
        // Else resolve a range from the caret position where the drop occured.
        var domRange;
        var { document: document1 } = DOMEditor.getWindow(editor);
        // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)
        if (document1.caretRangeFromPoint) {
            domRange = document1.caretRangeFromPoint(x, y);
        } else {
            var position = document1.caretPositionFromPoint(x, y);
            if (position) {
                domRange = document1.createRange();
                domRange.setStart(position.offsetNode, position.offset);
                domRange.setEnd(position.offsetNode, position.offset);
            }
        }
        if (!domRange) {
            throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
        }
        // Resolve a Slate range from the DOM range.
        var range = DOMEditor.toSlateRange(editor, domRange, {
            exactMatch: false,
            suppressThrow: false
        });
        return range;
    },
    findKey: (editor, node)=>{
        var key = NODE_TO_KEY.get(node);
        if (!key) {
            key = new Key();
            NODE_TO_KEY.set(node, key);
        }
        return key;
    },
    findPath: (editor, node)=>{
        var path = [];
        var child = node;
        while(true){
            var parent = NODE_TO_PARENT.get(child);
            if (parent == null) {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(child)) {
                    return path;
                } else {
                    break;
                }
            }
            var i = NODE_TO_INDEX.get(child);
            if (i == null) {
                break;
            }
            path.unshift(i);
            child = parent;
        }
        throw new Error("Unable to find the path for Slate node: ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scrubber"].stringify(node)));
    },
    focus: function focus(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            retries: 5
        };
        // Return if already focused
        if (IS_FOCUSED.get(editor)) {
            return;
        }
        // Retry setting focus if the editor has pending operations.
        // The DOM (selection) is unstable while changes are applied.
        // Retry until retries are exhausted or editor is focused.
        if (options.retries <= 0) {
            throw new Error('Could not set focus, editor seems stuck with pending operations');
        }
        if (editor.operations.length > 0) {
            setTimeout(()=>{
                DOMEditor.focus(editor, {
                    retries: options.retries - 1
                });
            }, 10);
            return;
        }
        var el = DOMEditor.toDOMNode(editor, editor);
        var root = DOMEditor.findDocumentOrShadowRoot(editor);
        if (root.activeElement !== el) {
            // Ensure that the DOM selection state is set to the editor's selection
            if (editor.selection && root instanceof Document) {
                var domSelection = getSelection(root);
                var domRange = DOMEditor.toDOMRange(editor, editor.selection);
                domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
                domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);
            }
            // Create a new selection in the top of the document if missing
            if (!editor.selection) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, []));
            }
            // IS_FOCUSED should be set before calling el.focus() to ensure that
            // FocusedContext is updated to the correct value
            IS_FOCUSED.set(editor, true);
            el.focus({
                preventScroll: true
            });
        }
    },
    getWindow: (editor)=>{
        var window1 = EDITOR_TO_WINDOW.get(editor);
        if (!window1) {
            throw new Error('Unable to find a host window element for this editor');
        }
        return window1;
    },
    hasDOMNode: function hasDOMNode(editor, target) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var { editable = false } = options;
        var editorEl = DOMEditor.toDOMNode(editor, editor);
        var targetEl;
        // COMPAT: In Firefox, reading `target.nodeType` will throw an error if
        // target is originating from an internal "restricted" element (e.g. a
        // stepper arrow on a number input). (2018/05/04)
        // https://github.com/ianstormtaylor/slate/issues/1819
        try {
            targetEl = isDOMElement(target) ? target : target.parentElement;
        } catch (err) {
            if (err instanceof Error && !err.message.includes('Permission denied to access property "nodeType"')) {
                throw err;
            }
        }
        if (!targetEl) {
            return false;
        }
        return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
        targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));
    },
    hasEditableTarget: (editor, target)=>isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {
            editable: true
        }),
    hasRange: (editor, range)=>{
        var { anchor, focus } = range;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, anchor.path) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, focus.path);
    },
    hasSelectableTarget: (editor, target)=>DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),
    hasTarget: (editor, target)=>isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),
    insertData: (editor, data)=>{
        editor.insertData(data);
    },
    insertFragmentData: (editor, data)=>editor.insertFragmentData(data),
    insertTextData: (editor, data)=>editor.insertTextData(data),
    isComposing: (editor)=>{
        return !!IS_COMPOSING.get(editor);
    },
    isFocused: (editor)=>!!IS_FOCUSED.get(editor),
    isReadOnly: (editor)=>!!IS_READ_ONLY.get(editor),
    isTargetInsideNonReadonlyVoid: (editor, target)=>{
        if (IS_READ_ONLY.get(editor)) return false;
        var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(slateNode) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, slateNode);
    },
    setFragmentData: (editor, data, originEvent)=>editor.setFragmentData(data, originEvent),
    toDOMNode: (editor, node)=>{
        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
        var domNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));
        if (!domNode) {
            throw new Error("Cannot resolve a DOM node from Slate node: ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scrubber"].stringify(node)));
        }
        return domNode;
    },
    toDOMPoint: (editor, point)=>{
        var [node] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, point.path);
        var el = DOMEditor.toDOMNode(editor, node);
        var domPoint;
        // If we're inside a void node, force the offset to 0, otherwise the zero
        // width spacing character will result in an incorrect offset of 1
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
            at: point
        })) {
            point = {
                path: point.path,
                offset: 0
            };
        }
        // For each leaf, we need to isolate its content, which means filtering
        // to its direct text and zero-width spans. (We have to filter out any
        // other siblings that may have been rendered alongside them.)
        var selector = "[data-slate-string], [data-slate-zero-width]";
        var texts = Array.from(el.querySelectorAll(selector));
        var start = 0;
        for(var i = 0; i < texts.length; i++){
            var text = texts[i];
            var domNode = text.childNodes[0];
            if (domNode == null || domNode.textContent == null) {
                continue;
            }
            var { length } = domNode.textContent;
            var attr = text.getAttribute('data-slate-length');
            var trueLength = attr == null ? length : parseInt(attr, 10);
            var end = start + trueLength;
            // Prefer putting the selection inside the mark placeholder to ensure
            // composed text is displayed with the correct marks.
            var nextText = texts[i + 1];
            if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {
                var _nextText$textContent;
                var domText = nextText.childNodes[0];
                domPoint = [
                    // COMPAT: If we don't explicity set the dom point to be on the actual
                    // dom text element, chrome will put the selection behind the actual dom
                    // text element, causing domRange.getBoundingClientRect() calls on a collapsed
                    // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
                    // which will cause issues when scrolling to it.
                    domText instanceof DOMText ? domText : nextText,
                    (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\uFEFF') ? 1 : 0
                ];
                break;
            }
            if (point.offset <= end) {
                var offset = Math.min(length, Math.max(0, point.offset - start));
                domPoint = [
                    domNode,
                    offset
                ];
                break;
            }
            start = end;
        }
        if (!domPoint) {
            throw new Error("Cannot resolve a DOM point from Slate point: ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scrubber"].stringify(point)));
        }
        return domPoint;
    },
    toDOMRange: (editor, range)=>{
        var { anchor, focus } = range;
        var isBackward = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isBackward(range);
        var domAnchor = DOMEditor.toDOMPoint(editor, anchor);
        var domFocus = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);
        var window1 = DOMEditor.getWindow(editor);
        var domRange = window1.document.createRange();
        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
        var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
        // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at
        // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and
        // adjust the offset accordingly.
        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
        var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');
        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
        var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');
        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
        return domRange;
    },
    toSlateNode: (editor, domNode)=>{
        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
        if (domEl && !domEl.hasAttribute('data-slate-node')) {
            domEl = domEl.closest("[data-slate-node]");
        }
        var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
        if (!node) {
            throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
        }
        return node;
    },
    toSlatePoint: (editor, domPoint, options)=>{
        var { exactMatch, suppressThrow, searchDirection = 'backward' } = options;
        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
        var parentNode = nearestNode.parentNode;
        var textNode = null;
        var offset = 0;
        if (parentNode) {
            var _domNode$textContent, _domNode$textContent2;
            var editorEl = DOMEditor.toDOMNode(editor, editor);
            var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
            // Need to ensure that the closest void node is actually a void node
            // within this editor, and not a void node within some parent editor. This can happen
            // if this editor is within a void node of another editor ("nested editors", like in
            // the "Editable Voids" example on the docs site).
            var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
            var potentialNonEditableNode = parentNode.closest('[contenteditable="false"]');
            var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;
            var leafNode = parentNode.closest('[data-slate-leaf]');
            var domNode = null;
            // Calculate how far into the text node the `nearestNode` is, so that we
            // can determine what the offset relative to the text node is.
            if (leafNode) {
                textNode = leafNode.closest('[data-slate-node="text"]');
                if (textNode) {
                    var window1 = DOMEditor.getWindow(editor);
                    var range = window1.document.createRange();
                    range.setStart(textNode, 0);
                    range.setEnd(nearestNode, nearestOffset);
                    var contents = range.cloneContents();
                    var removals = [
                        ...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')),
                        ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))
                    ];
                    removals.forEach((el)=>{
                        // COMPAT: While composing at the start of a text node, some keyboards put
                        // the text content inside the zero width space.
                        if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\uFEFF') {
                            if (el.textContent.startsWith('\uFEFF')) {
                                el.textContent = el.textContent.slice(1);
                            }
                            return;
                        }
                        el.parentNode.removeChild(el);
                    });
                    // COMPAT: Edge has a bug where Range.prototype.toString() will
                    // convert \n into \r\n. The bug causes a loop when slate-dom
                    // attempts to reposition its cursor to match the native position. Use
                    // textContent.length instead.
                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/
                    offset = contents.textContent.length;
                    domNode = textNode;
                }
            } else if (voidNode) {
                // For void nodes, the element with the offset key will be a cousin, not an
                // ancestor, so find it by going down from the nearest void parent and taking the
                // first one that isn't inside a nested editor.
                var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');
                for(var index = 0; index < leafNodes.length; index++){
                    var current = leafNodes[index];
                    if (DOMEditor.hasDOMNode(editor, current)) {
                        leafNode = current;
                        break;
                    }
                }
                // COMPAT: In read-only editors the leaf is not rendered.
                if (!leafNode) {
                    offset = 1;
                } else {
                    textNode = leafNode.closest('[data-slate-node="text"]');
                    domNode = leafNode;
                    offset = domNode.textContent.length;
                    domNode.querySelectorAll('[data-slate-zero-width]').forEach((el)=>{
                        offset -= el.textContent.length;
                    });
                }
            } else if (nonEditableNode) {
                // Find the edge of the nearest leaf in `searchDirection`
                var getLeafNodes = (node)=>node ? node.querySelectorAll(// Exclude leaf nodes in nested editors
                    '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];
                var elementNode = nonEditableNode.closest('[data-slate-node="element"]');
                if (searchDirection === 'forward') {
                    var _leafNodes$find;
                    var _leafNodes = [
                        ...getLeafNodes(elementNode),
                        ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)
                    ];
                    leafNode = (_leafNodes$find = _leafNodes.find((leaf)=>isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;
                } else {
                    var _leafNodes2$findLast;
                    var _leafNodes2 = [
                        ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling),
                        ...getLeafNodes(elementNode)
                    ];
                    leafNode = (_leafNodes2$findLast = _leafNodes2.findLast((leaf)=>isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;
                }
                if (leafNode) {
                    textNode = leafNode.closest('[data-slate-node="text"]');
                    domNode = leafNode;
                    if (searchDirection === 'forward') {
                        offset = 0;
                    } else {
                        offset = domNode.textContent.length;
                        domNode.querySelectorAll('[data-slate-zero-width]').forEach((el)=>{
                            offset -= el.textContent.length;
                        });
                    }
                }
            }
            if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
            // and we don't add it for line-breaks.
            IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\uFEFF') && (// COMPAT: If the parent node is a Slate zero-width space, editor is
            // because the text node should have no characters. However, during IME
            // composition the ASCII characters will be prepended to the zero-width
            // space, so subtract 1 from the offset to account for the zero-width
            // space character.
            parentNode.hasAttribute('data-slate-zero-width') || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
            // when the document ends with a new-line character. This results in the offset
            // length being off by one, so we need to subtract one to account for this.
            IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\n\n'))) {
                offset--;
            }
        }
        if (IS_ANDROID && !textNode && !exactMatch) {
            var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');
            if (node && DOMEditor.hasDOMNode(editor, node, {
                editable: true
            })) {
                var _slateNode = DOMEditor.toSlateNode(editor, node);
                var { path: _path, offset: _offset } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, DOMEditor.findPath(editor, _slateNode));
                if (!node.querySelector('[data-slate-leaf]')) {
                    _offset = nearestOffset;
                }
                return {
                    path: _path,
                    offset: _offset
                };
            }
        }
        if (!textNode) {
            if (suppressThrow) {
                return null;
            }
            throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
        }
        // COMPAT: If someone is clicking from one Slate editor into another,
        // the select event fires twice, once for the old editor's `element`
        // first, and then afterwards for the correct `element`. (2017/03/03)
        var slateNode = DOMEditor.toSlateNode(editor, textNode);
        var path = DOMEditor.findPath(editor, slateNode);
        return {
            path,
            offset
        };
    },
    toSlateRange: (editor, domRange, options)=>{
        var _focusNode$textConten;
        var { exactMatch, suppressThrow } = options;
        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
        var anchorNode;
        var anchorOffset;
        var focusNode;
        var focusOffset;
        var isCollapsed;
        if (el) {
            if (isDOMSelection(domRange)) {
                // COMPAT: In firefox the normal seletion way does not work
                // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)
                if (IS_FIREFOX && domRange.rangeCount > 1) {
                    focusNode = domRange.focusNode; // Focus node works fine
                    var firstRange = domRange.getRangeAt(0);
                    var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);
                    // Here we are in the contenteditable mode of a table in firefox
                    if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {
                        // HTMLElement, becouse Element is a slate element
                        function getLastChildren(element) {
                            if (element.childElementCount > 0) {
                                return getLastChildren(element.children[0]);
                            } else {
                                return element;
                            }
                        }
                        var firstNodeRow = firstRange.startContainer;
                        var lastNodeRow = lastRange.startContainer;
                        // This should never fail as "The HTMLElement interface represents any HTML element."
                        var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);
                        var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);
                        // Zero, as we allways take the right one as the anchor point
                        focusOffset = 0;
                        if (lastNode.childNodes.length > 0) {
                            anchorNode = lastNode.childNodes[0];
                        } else {
                            anchorNode = lastNode;
                        }
                        if (firstNode.childNodes.length > 0) {
                            focusNode = firstNode.childNodes[0];
                        } else {
                            focusNode = firstNode;
                        }
                        if (lastNode instanceof HTMLElement) {
                            anchorOffset = lastNode.innerHTML.length;
                        } else {
                            // Fallback option
                            anchorOffset = 0;
                        }
                    } else {
                        // This is the read only mode of a firefox table
                        // Right to left
                        if (firstRange.startContainer === focusNode) {
                            anchorNode = lastRange.endContainer;
                            anchorOffset = lastRange.endOffset;
                            focusOffset = firstRange.startOffset;
                        } else {
                            // Left to right
                            anchorNode = firstRange.startContainer;
                            anchorOffset = firstRange.endOffset;
                            focusOffset = lastRange.startOffset;
                        }
                    }
                } else {
                    anchorNode = domRange.anchorNode;
                    anchorOffset = domRange.anchorOffset;
                    focusNode = domRange.focusNode;
                    focusOffset = domRange.focusOffset;
                }
                // COMPAT: There's a bug in chrome that always returns `true` for
                // `isCollapsed` for a Selection that comes from a ShadowRoot.
                // (2020/08/08)
                // https://bugs.chromium.org/p/chromium/issues/detail?id=447523
                // IsCollapsed might not work in firefox, but this will
                if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {
                    isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
                } else {
                    isCollapsed = domRange.isCollapsed;
                }
            } else {
                anchorNode = domRange.startContainer;
                anchorOffset = domRange.startOffset;
                focusNode = domRange.endContainer;
                focusOffset = domRange.endOffset;
                isCollapsed = domRange.collapsed;
            }
        }
        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
            throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
        }
        // COMPAT: Firefox sometimes includes an extra \n (rendered by TextString
        // when isTrailing is true) in the focusOffset, resulting in an invalid
        // Slate point. (2023/11/01)
        if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\n\n') && focusOffset === focusNode.textContent.length) {
            focusOffset--;
        }
        var anchor = DOMEditor.toSlatePoint(editor, [
            anchorNode,
            anchorOffset
        ], {
            exactMatch,
            suppressThrow
        });
        if (!anchor) {
            return null;
        }
        var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;
        var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [
            focusNode,
            focusOffset
        ], {
            exactMatch,
            suppressThrow,
            searchDirection: focusBeforeAnchor ? 'forward' : 'backward'
        });
        if (!focus) {
            return null;
        }
        var range = {
            anchor: anchor,
            focus: focus
        };
        // if the selection is a hanging range that ends in a void
        // and the DOM focus is an Element
        // (meaning that the selection ends before the element)
        // unhang the range to avoid mistakenly including the void
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(range) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isForward(range) && isDOMElement(focusNode) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
            at: range.focus,
            mode: 'highest'
        })) {
            range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].unhangRange(editor, range, {
                voids: true
            });
        }
        return range;
    }
};
/**
 * Check whether a text diff was applied in a way we can perform the pending action on /
 * recover the pending selection.
 */ function verifyDiffState(editor, textDiff) {
    var { path, diff } = textDiff;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, path)) {
        return false;
    }
    var node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, path);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(node)) {
        return false;
    }
    if (diff.start !== node.text.length || diff.text.length === 0) {
        return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;
    }
    var nextPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].next(path);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, nextPath)) {
        return false;
    }
    var nextNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, nextPath);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(nextNode) && nextNode.text.startsWith(diff.text);
}
function applyStringDiff(text) {
    for(var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        diffs[_key - 1] = arguments[_key];
    }
    return diffs.reduce((text, diff)=>text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);
}
function longestCommonPrefixLength(str, another) {
    var length = Math.min(str.length, another.length);
    for(var i = 0; i < length; i++){
        if (str.charAt(i) !== another.charAt(i)) {
            return i;
        }
    }
    return length;
}
function longestCommonSuffixLength(str, another, max) {
    var length = Math.min(str.length, another.length, max);
    for(var i = 0; i < length; i++){
        if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {
            return i;
        }
    }
    return length;
}
/**
 * Remove redundant changes from the diff so that it spans the minimal possible range
 */ function normalizeStringDiff(targetText, diff) {
    var { start, end, text } = diff;
    var removedText = targetText.slice(start, end);
    var prefixLength = longestCommonPrefixLength(removedText, text);
    var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);
    var suffixLength = longestCommonSuffixLength(removedText, text, max);
    var normalized = {
        start: start + prefixLength,
        end: end - suffixLength,
        text: text.slice(prefixLength, text.length - suffixLength)
    };
    if (normalized.start === normalized.end && normalized.text.length === 0) {
        return null;
    }
    return normalized;
}
/**
 * Return a string diff that is equivalent to applying b after a spanning the range of
 * both changes
 */ function mergeStringDiffs(targetText, a, b) {
    var start = Math.min(a.start, b.start);
    var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);
    var applied = applyStringDiff(targetText, a, b);
    var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);
    var text = applied.slice(start, sliceEnd);
    var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));
    return normalizeStringDiff(targetText, {
        start,
        end,
        text
    });
}
/**
 * Get the slate range the text diff spans.
 */ function targetRange(textDiff) {
    var { path, diff } = textDiff;
    return {
        anchor: {
            path,
            offset: diff.start
        },
        focus: {
            path,
            offset: diff.end
        }
    };
}
/**
 * Normalize a 'pending point' a.k.a a point based on the dom state before applying
 * the pending diffs. Since the pending diffs might have been inserted with different
 * marks we have to 'walk' the offset from the starting position to ensure we still
 * have a valid point inside the document
 */ function normalizePoint(editor, point) {
    var { path, offset } = point;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, path)) {
        return null;
    }
    var leaf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, path);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(leaf)) {
        return null;
    }
    var parentBlock = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].above(editor, {
        match: (n)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(n) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(editor, n),
        at: path
    });
    if (!parentBlock) {
        return null;
    }
    while(offset > leaf.text.length){
        var entry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].next(editor, {
            at: path,
            match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText
        });
        if (!entry || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isDescendant(entry[1], parentBlock[1])) {
            return null;
        }
        offset -= leaf.text.length;
        leaf = entry[0];
        path = entry[1];
    }
    return {
        path,
        offset
    };
}
/**
 * Normalize a 'pending selection' to ensure it's valid in the current document state.
 */ function normalizeRange(editor, range) {
    var anchor = normalizePoint(editor, range.anchor);
    if (!anchor) {
        return null;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(range)) {
        return {
            anchor,
            focus: anchor
        };
    }
    var focus = normalizePoint(editor, range.focus);
    if (!focus) {
        return null;
    }
    return {
        anchor,
        focus
    };
}
function transformPendingPoint(editor, point, op) {
    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
    var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref)=>{
        var { path } = _ref;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(path, point.path);
    });
    if (!textDiff || point.offset <= textDiff.diff.start) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].transform(point, op, {
            affinity: 'backward'
        });
    }
    var { diff } = textDiff;
    // Point references location inside the diff => transform the point based on the location
    // the diff will be applied to and add the offset inside the diff.
    if (point.offset <= diff.start + diff.text.length) {
        var _anchor = {
            path: point.path,
            offset: diff.start
        };
        var _transformed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].transform(_anchor, op, {
            affinity: 'backward'
        });
        if (!_transformed) {
            return null;
        }
        return {
            path: _transformed.path,
            offset: _transformed.offset + point.offset - diff.start
        };
    }
    // Point references location after the diff
    var anchor = {
        path: point.path,
        offset: point.offset - diff.text.length + diff.end - diff.start
    };
    var transformed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].transform(anchor, op, {
        affinity: 'backward'
    });
    if (!transformed) {
        return null;
    }
    if (op.type === 'split_node' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {
        return transformed;
    }
    return {
        path: transformed.path,
        offset: transformed.offset + diff.text.length - diff.end + diff.start
    };
}
function transformPendingRange(editor, range, op) {
    var anchor = transformPendingPoint(editor, range.anchor, op);
    if (!anchor) {
        return null;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(range)) {
        return {
            anchor,
            focus: anchor
        };
    }
    var focus = transformPendingPoint(editor, range.focus, op);
    if (!focus) {
        return null;
    }
    return {
        anchor,
        focus
    };
}
function transformTextDiff(textDiff, op) {
    var { path, diff, id } = textDiff;
    switch(op.type){
        case 'insert_text':
            {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, path) || op.offset >= diff.end) {
                    return textDiff;
                }
                if (op.offset <= diff.start) {
                    return {
                        diff: {
                            start: op.text.length + diff.start,
                            end: op.text.length + diff.end,
                            text: diff.text
                        },
                        id,
                        path
                    };
                }
                return {
                    diff: {
                        start: diff.start,
                        end: diff.end + op.text.length,
                        text: diff.text
                    },
                    id,
                    path
                };
            }
        case 'remove_text':
            {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, path) || op.offset >= diff.end) {
                    return textDiff;
                }
                if (op.offset + op.text.length <= diff.start) {
                    return {
                        diff: {
                            start: diff.start - op.text.length,
                            end: diff.end - op.text.length,
                            text: diff.text
                        },
                        id,
                        path
                    };
                }
                return {
                    diff: {
                        start: diff.start,
                        end: diff.end - op.text.length,
                        text: diff.text
                    },
                    id,
                    path
                };
            }
        case 'split_node':
            {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, path) || op.position >= diff.end) {
                    return {
                        diff,
                        id,
                        path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, op, {
                            affinity: 'backward'
                        })
                    };
                }
                if (op.position > diff.start) {
                    return {
                        diff: {
                            start: diff.start,
                            end: Math.min(op.position, diff.end),
                            text: diff.text
                        },
                        id,
                        path
                    };
                }
                return {
                    diff: {
                        start: diff.start - op.position,
                        end: diff.end - op.position,
                        text: diff.text
                    },
                    id,
                    path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, op, {
                        affinity: 'forward'
                    })
                };
            }
        case 'merge_node':
            {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, path)) {
                    return {
                        diff,
                        id,
                        path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, op)
                    };
                }
                return {
                    diff: {
                        start: diff.start + op.position,
                        end: diff.end + op.position,
                        text: diff.text
                    },
                    id,
                    path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, op)
                };
            }
    }
    var newPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, op);
    if (!newPath) {
        return null;
    }
    return {
        diff,
        path: newPath,
        id
    };
}
/**
 * Utilities for single-line deletion
 */ var doRectsIntersect = (rect, compareRect)=>{
    var middle = (compareRect.top + compareRect.bottom) / 2;
    return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2)=>{
    var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();
    var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();
    return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
/**
 * A helper utility that returns the end portion of a `Range`
 * which is located on a single line.
 *
 * @param {Editor} editor The editor object to compare against
 * @param {Range} parentRange The parent range to compare against
 * @returns {Range} A valid portion of the parentRange which is one a single line
 */ var findCurrentLineRange = (editor, parentRange)=>{
    var parentRangeBoundary = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].end(parentRange));
    var positions = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].positions(editor, {
        at: parentRange
    }));
    var left = 0;
    var right = positions.length;
    var middle = Math.floor(right / 2);
    if (areRangesSameLine(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, positions[left]), parentRangeBoundary)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, positions[left], parentRangeBoundary);
    }
    if (positions.length < 2) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, positions[positions.length - 1], parentRangeBoundary);
    }
    while(middle !== positions.length && middle !== left){
        if (areRangesSameLine(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, positions[middle]), parentRangeBoundary)) {
            right = middle;
        } else {
            left = middle;
        }
        middle = Math.floor((left + right) / 2);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, positions[right], parentRangeBoundary);
};
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
/**
 * `withDOM` adds DOM specific behaviors to the editor.
 *
 * If you are using TypeScript, you must extend Slate's CustomTypes to use
 * this plugin.
 *
 * See https://docs.slatejs.org/concepts/11-typescript to learn how.
 */ var withDOM = function withDOM(editor) {
    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';
    var e = editor;
    var { apply, onChange, deleteBackward, addMark, removeMark } = e;
    // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to
    // avoid collisions between editors in the DOM that share the same value.
    EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());
    e.addMark = (key, value)=>{
        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();
        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
            // Ensure the current pending diffs originating from changes before the addMark
            // are applied with the current formatting
            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);
        }
        EDITOR_TO_USER_MARKS.delete(e);
        addMark(key, value);
    };
    e.removeMark = (key)=>{
        var _EDITOR_TO_PENDING_DI2;
        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
            // Ensure the current pending diffs originating from changes before the addMark
            // are applied with the current formatting
            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);
        }
        EDITOR_TO_USER_MARKS.delete(e);
        removeMark(key);
    };
    e.deleteBackward = (unit)=>{
        if (unit !== 'line') {
            return deleteBackward(unit);
        }
        if (e.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(e.selection)) {
            var parentBlockEntry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].above(e, {
                match: (n)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(n) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(e, n),
                at: e.selection
            });
            if (parentBlockEntry) {
                var [, parentBlockPath] = parentBlockEntry;
                var parentElementRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(e, parentBlockPath, e.selection.anchor);
                var currentLineRange = findCurrentLineRange(e, parentElementRange);
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(currentLineRange)) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(e, {
                        at: currentLineRange
                    });
                }
            }
        }
    };
    // This attempts to reset the NODE_TO_KEY entry to the correct value
    // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry
    e.apply = (op)=>{
        var matches = [];
        var pathRefMatches = [];
        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);
        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
            var transformed = pendingDiffs.map((textDiff)=>transformTextDiff(textDiff, op)).filter(Boolean);
            EDITOR_TO_PENDING_DIFFS.set(e, transformed);
        }
        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);
        if (pendingSelection) {
            EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));
        }
        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);
        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
            var at = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);
            EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {
                at
            }) : null);
        }
        switch(op.type){
            case 'insert_text':
            case 'remove_text':
            case 'set_node':
            case 'split_node':
                {
                    matches.push(...getMatches(e, op.path));
                    break;
                }
            case 'set_selection':
                {
                    var _EDITOR_TO_USER_SELEC;
                    // Selection was manually set, don't restore the user selection after the change.
                    (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();
                    EDITOR_TO_USER_SELECTION.delete(e);
                    break;
                }
            case 'insert_node':
            case 'remove_node':
                {
                    matches.push(...getMatches(e, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(op.path)));
                    break;
                }
            case 'merge_node':
                {
                    var prevPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].previous(op.path);
                    matches.push(...getMatches(e, prevPath));
                    break;
                }
            case 'move_node':
                {
                    var commonPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].common(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(op.path), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(op.newPath));
                    matches.push(...getMatches(e, commonPath));
                    var changedPath;
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isBefore(op.path, op.newPath)) {
                        matches.push(...getMatches(e, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(op.path)));
                        changedPath = op.newPath;
                    } else {
                        matches.push(...getMatches(e, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(op.newPath)));
                        changedPath = op.path;
                    }
                    var changedNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(changedPath));
                    var changedNodeKey = DOMEditor.findKey(e, changedNode);
                    var changedPathRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].pathRef(e, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(changedPath));
                    pathRefMatches.push([
                        changedPathRef,
                        changedNodeKey
                    ]);
                    break;
                }
        }
        apply(op);
        switch(op.type){
            case 'insert_node':
            case 'remove_node':
            case 'merge_node':
            case 'move_node':
            case 'split_node':
                {
                    IS_NODE_MAP_DIRTY.set(e, true);
                }
        }
        for (var [path, key] of matches){
            var [node] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(e, path);
            NODE_TO_KEY.set(node, key);
        }
        for (var [pathRef, _key] of pathRefMatches){
            if (pathRef.current) {
                var [_node] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(e, pathRef.current);
                NODE_TO_KEY.set(_node, _key);
            }
            pathRef.unref();
        }
    };
    e.setFragmentData = (data)=>{
        var { selection } = e;
        if (!selection) {
            return;
        }
        var [start, end] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].edges(selection);
        var startVoid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(e, {
            at: start.path
        });
        var endVoid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(e, {
            at: end.path
        });
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(selection) && !startVoid) {
            return;
        }
        // Create a fake selection so that we can add a Base64-encoded copy of the
        // fragment to the HTML, to decode on future pastes.
        var domRange = DOMEditor.toDOMRange(e, selection);
        var contents = domRange.cloneContents();
        var attach = contents.childNodes[0];
        // Make sure attach is non-empty, since empty nodes will not get copied.
        contents.childNodes.forEach((node)=>{
            if (node.textContent && node.textContent.trim() !== '') {
                attach = node;
            }
        });
        // COMPAT: If the end node is a void node, we need to move the end of the
        // range from the void node's spacer span, to the end of the void node's
        // content, since the spacer is before void's content in the DOM.
        if (endVoid) {
            var [voidNode] = endVoid;
            var r = domRange.cloneRange();
            var domNode = DOMEditor.toDOMNode(e, voidNode);
            r.setEndAfter(domNode);
            contents = r.cloneContents();
        }
        // COMPAT: If the start node is a void node, we need to attach the encoded
        // fragment to the void node's content node instead of the spacer, because
        // attaching it to empty `<div>/<span>` nodes will end up having it erased by
        // most browsers. (2018/04/27)
        if (startVoid) {
            attach = contents.querySelector('[data-slate-spacer]');
        }
        // Remove any zero-width space spans from the cloned DOM so that they don't
        // show up elsewhere when pasted.
        Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach((zw)=>{
            var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
            zw.textContent = isNewline ? '\n' : '';
        });
        // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
        // in the HTML, and can be used for intra-Slate pasting. If it's a text
        // node, wrap it in a `<span>` so we have something to set an attribute on.
        if (isDOMText(attach)) {
            var span = attach.ownerDocument.createElement('span');
            // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
            // then leading and trailing spaces will be ignored. (2017/09/21)
            span.style.whiteSpace = 'pre';
            span.appendChild(attach);
            contents.appendChild(span);
            attach = span;
        }
        var fragment = e.getFragment();
        var string = JSON.stringify(fragment);
        var encoded = window.btoa(encodeURIComponent(string));
        attach.setAttribute('data-slate-fragment', encoded);
        data.setData("application/".concat(clipboardFormatKey), encoded);
        // Add the content to a <div> so that we can get its inner HTML.
        var div = contents.ownerDocument.createElement('div');
        div.appendChild(contents);
        div.setAttribute('hidden', 'true');
        contents.ownerDocument.body.appendChild(div);
        data.setData('text/html', div.innerHTML);
        data.setData('text/plain', getPlainText(div));
        contents.ownerDocument.body.removeChild(div);
        return data;
    };
    e.insertData = (data)=>{
        if (!e.insertFragmentData(data)) {
            e.insertTextData(data);
        }
    };
    e.insertFragmentData = (data)=>{
        /**
     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment
     */ var fragment = data.getData("application/".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);
        if (fragment) {
            var decoded = decodeURIComponent(window.atob(fragment));
            var parsed = JSON.parse(decoded);
            e.insertFragment(parsed);
            return true;
        }
        return false;
    };
    e.insertTextData = (data)=>{
        var text = data.getData('text/plain');
        if (text) {
            var lines = text.split(/\r\n|\r|\n/);
            var split = false;
            for (var line of lines){
                if (split) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].splitNodes(e, {
                        always: true
                    });
                }
                e.insertText(line);
                split = true;
            }
            return true;
        }
        return false;
    };
    e.onChange = (options)=>{
        var onContextChange = EDITOR_TO_ON_CHANGE.get(e);
        if (onContextChange) {
            onContextChange(options);
        }
        onChange(options);
    };
    return e;
};
var getMatches = (e, path)=>{
    var matches = [];
    for (var [n, p] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].levels(e, {
        at: path
    })){
        var key = DOMEditor.findKey(e, n);
        matches.push([
            p,
            key
        ]);
    }
    return matches;
};
var TRIPLE_CLICK = 3;
/**
 * Hotkey mappings for each platform.
 */ var HOTKEYS = {
    bold: 'mod+b',
    compose: [
        'down',
        'left',
        'right',
        'up',
        'backspace',
        'enter'
    ],
    moveBackward: 'left',
    moveForward: 'right',
    moveWordBackward: 'ctrl+left',
    moveWordForward: 'ctrl+right',
    deleteBackward: 'shift?+backspace',
    deleteForward: 'shift?+delete',
    extendBackward: 'shift+left',
    extendForward: 'shift+right',
    italic: 'mod+i',
    insertSoftBreak: 'shift+enter',
    splitBlock: 'enter',
    undo: 'mod+z'
};
var APPLE_HOTKEYS = {
    moveLineBackward: 'opt+up',
    moveLineForward: 'opt+down',
    moveWordBackward: 'opt+left',
    moveWordForward: 'opt+right',
    deleteBackward: [
        'ctrl+backspace',
        'ctrl+h'
    ],
    deleteForward: [
        'ctrl+delete',
        'ctrl+d'
    ],
    deleteLineBackward: 'cmd+shift?+backspace',
    deleteLineForward: [
        'cmd+shift?+delete',
        'ctrl+k'
    ],
    deleteWordBackward: 'opt+shift?+backspace',
    deleteWordForward: 'opt+shift?+delete',
    extendLineBackward: 'opt+shift+up',
    extendLineForward: 'opt+shift+down',
    redo: 'cmd+shift+z',
    transposeCharacter: 'ctrl+t'
};
var WINDOWS_HOTKEYS = {
    deleteWordBackward: 'ctrl+shift?+backspace',
    deleteWordForward: 'ctrl+shift?+delete',
    redo: [
        'ctrl+y',
        'ctrl+shift+z'
    ]
};
/**
 * Create a platform-aware hotkey checker.
 */ var create = (key)=>{
    var generic = HOTKEYS[key];
    var apple = APPLE_HOTKEYS[key];
    var windows = WINDOWS_HOTKEYS[key];
    var isGeneric = generic && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHotkey"])(generic);
    var isApple = apple && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHotkey"])(apple);
    var isWindows = windows && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHotkey"])(windows);
    return (event)=>{
        if (isGeneric && isGeneric(event)) return true;
        if (IS_APPLE && isApple && isApple(event)) return true;
        if (!IS_APPLE && isWindows && isWindows(event)) return true;
        return false;
    };
};
/**
 * Hotkeys.
 */ var hotkeys = {
    isBold: create('bold'),
    isCompose: create('compose'),
    isMoveBackward: create('moveBackward'),
    isMoveForward: create('moveForward'),
    isDeleteBackward: create('deleteBackward'),
    isDeleteForward: create('deleteForward'),
    isDeleteLineBackward: create('deleteLineBackward'),
    isDeleteLineForward: create('deleteLineForward'),
    isDeleteWordBackward: create('deleteWordBackward'),
    isDeleteWordForward: create('deleteWordForward'),
    isExtendBackward: create('extendBackward'),
    isExtendForward: create('extendForward'),
    isExtendLineBackward: create('extendLineBackward'),
    isExtendLineForward: create('extendLineForward'),
    isItalic: create('italic'),
    isMoveLineBackward: create('moveLineBackward'),
    isMoveLineForward: create('moveLineForward'),
    isMoveWordBackward: create('moveWordBackward'),
    isMoveWordForward: create('moveWordForward'),
    isRedo: create('redo'),
    isSoftBreak: create('insertSoftBreak'),
    isSplitBlock: create('splitBlock'),
    isTransposeCharacter: create('transposeCharacter'),
    isUndo: create('undo')
};
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
var _excluded = [
    "anchor",
    "focus"
], _excluded2 = [
    "anchor",
    "focus"
];
var shallowCompare = (obj1, obj2)=>Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecorationFlagsEqual = (range, other)=>{
    var rangeOwnProps = _objectWithoutProperties(range, _excluded);
    var otherOwnProps = _objectWithoutProperties(other, _excluded2);
    return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
};
/**
 * Check if a list of decorator ranges are equal to another.
 *
 * PERF: this requires the two lists to also have the ranges inside them in the
 * same order, but this is an okay constraint for us since decorations are
 * kept in order, and the odd case where they aren't is okay to re-render for.
 */ var isElementDecorationsEqual = (list, another)=>{
    if (list.length !== another.length) {
        return false;
    }
    for(var i = 0; i < list.length; i++){
        var range = list[i];
        var other = another[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(range, other) || !isDecorationFlagsEqual(range, other)) {
            return false;
        }
    }
    return true;
};
/**
 * Check if a list of decorator ranges are equal to another.
 *
 * PERF: this requires the two lists to also have the ranges inside them in the
 * same order, but this is an okay constraint for us since decorations are
 * kept in order, and the odd case where they aren't is okay to re-render for.
 */ var isTextDecorationsEqual = (list, another)=>{
    if (list.length !== another.length) {
        return false;
    }
    for(var i = 0; i < list.length; i++){
        var range = list[i];
        var other = another[i];
        // compare only offsets because paths doesn't matter for text
        if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {
            return false;
        }
    }
    return true;
};
;
 //# sourceMappingURL=index.es.js.map
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "resizeObservers": (()=>resizeObservers)
});
var resizeObservers = [];
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hasActiveObservations": (()=>hasActiveObservations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
var hasActiveObservations = function() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].some(function(ro) {
        return ro.activeTargets.length > 0;
    });
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hasSkippedObservations": (()=>hasSkippedObservations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
var hasSkippedObservations = function() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].some(function(ro) {
        return ro.skippedTargets.length > 0;
    });
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "deliverResizeLoopError": (()=>deliverResizeLoopError)
});
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function() {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    } else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserverBoxOptions": (()=>ResizeObserverBoxOptions)
});
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "freeze": (()=>freeze)
});
var freeze = function(obj) {
    return Object.freeze(obj);
};
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserverSize": (()=>ResizeObserverSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
var ResizeObserverSize = function() {
    function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])(this);
    }
    return ResizeObserverSize;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DOMRectReadOnly": (()=>DOMRectReadOnly)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
var DOMRectReadOnly = function() {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])(this);
    }
    DOMRectReadOnly.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return {
            x: x,
            y: y,
            top: top,
            right: right,
            bottom: bottom,
            left: left,
            width: width,
            height: height
        };
    };
    DOMRectReadOnly.fromRect = function(rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isElement": (()=>isElement),
    "isHidden": (()=>isHidden),
    "isReplacedElement": (()=>isReplacedElement),
    "isSVG": (()=>isSVG)
});
var isSVG = function(target) {
    return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function(target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
    var _a;
    if (obj instanceof Element) {
        return true;
    }
    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
    switch(target.tagName){
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "global": (()=>global)
});
var global = typeof window !== 'undefined' ? window : {};
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "calculateBoxSize": (()=>calculateBoxSize),
    "calculateBoxSizes": (()=>calculateBoxSizes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)");
;
;
;
;
;
;
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].navigator && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].navigator.userAgent);
var parseDimension = function(pixel) {
    return parseFloat(pixel || '0');
};
var size = function(inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) {
        inlineSize = 0;
    }
    if (blockSize === void 0) {
        blockSize = 0;
    }
    if (switchSizes === void 0) {
        switchSizes = false;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverSize"]((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMRectReadOnly"](0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
    if (forceRecalculation === void 0) {
        forceRecalculation = false;
    }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHidden"])(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSVG"])(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMRectReadOnly"](paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch(observedBox){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserverEntry": (()=>ResizeObserverEntry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
;
var ResizeObserverEntry = function() {
    function ResizeObserverEntry(target) {
        var boxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSizes"])(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.borderBoxSize
        ]);
        this.contentBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.contentBoxSize
        ]);
        this.devicePixelContentBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.devicePixelContentBoxSize
        ]);
    }
    return ResizeObserverEntry;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "calculateDepthForNode": (()=>calculateDepthForNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
var calculateDepthForNode = function(node) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHidden"])(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while(parent){
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "broadcastActiveObservations": (()=>broadcastActiveObservations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverEntry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
;
;
;
;
var broadcastActiveObservations = function() {
    var shallowestDepth = Infinity;
    var callbacks = [];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverEntry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverEntry"](ot.target);
            var targetDepth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateDepthForNode"])(ot.target);
            entries.push(entry);
            ot.lastReportedSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSize"])(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for(var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++){
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "gatherActiveObservationsAtDepth": (()=>gatherActiveObservationsAtDepth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)");
;
;
var gatherActiveObservationsAtDepth = function(depth) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateDepthForNode"])(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                } else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/process.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "process": (()=>process)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasSkippedObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$deliverResizeLoopError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$broadcastActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js [app-client] (ecmascript)");
;
;
;
;
;
var process = function() {
    var depth = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gatherActiveObservationsAtDepth"])(depth);
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasActiveObservations"])()){
        depth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$broadcastActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastActiveObservations"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gatherActiveObservationsAtDepth"])(depth);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasSkippedObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasSkippedObservations"])()) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$deliverResizeLoopError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deliverResizeLoopError"])();
    }
    return depth > 0;
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "queueMicroTask": (()=>queueMicroTask)
});
var trigger;
var callbacks = [];
var notify = function() {
    return callbacks.splice(0).forEach(function(cb) {
        return cb();
    });
};
var queueMicroTask = function(callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = {
            characterData: true
        };
        new MutationObserver(function() {
            return notify();
        }).observe(el_1, config);
        trigger = function() {
            el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
    }
    callbacks.push(callback);
    trigger();
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "queueResizeObserver": (()=>queueResizeObserver)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueMicroTask$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js [app-client] (ecmascript)");
;
var queueResizeObserver = function(cb) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueMicroTask$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["queueMicroTask"])(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/scheduler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "scheduler": (()=>scheduler),
    "updateCount": (()=>updateCount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js [app-client] (ecmascript)");
;
;
;
var watching = 0;
var isWatching = function() {
    return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
    attributes: true,
    characterData: true,
    childList: true,
    subtree: true
};
var events = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function(timeout) {
    if (timeout === void 0) {
        timeout = 0;
    }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
            return _this.schedule();
        };
    }
    Scheduler.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
            timeout = CATCH_PERIOD;
        }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["queueResizeObserver"])(function() {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["process"])();
            } finally{
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                } else if (timeout > 0) {
                    _this.run(timeout);
                } else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function() {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function() {
        var _this = this;
        var cb = function() {
            return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function(name) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].addEventListener(name, _this.listener, true);
            });
        }
    };
    Scheduler.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function(name) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].removeEventListener(name, _this.listener, true);
            });
            this.stopped = true;
        }
    };
    return Scheduler;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObservation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObservation": (()=>ResizeObservation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
;
;
var skipNotifyOnElement = function(target) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSVG"])(target) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReplacedElement"])(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = function() {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function() {
        var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSize"])(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserverDetail": (()=>ResizeObserverDetail)
});
var ResizeObserverDetail = function() {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserverController": (()=>ResizeObserverController)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/scheduler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObservation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObservation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverDetail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
;
;
;
var observerMap = new WeakMap();
var getObservationIndex = function(observationTargets, target) {
    for(var i = 0; i < observationTargets.length; i += 1){
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController = function() {
    function ResizeObserverController() {}
    ResizeObserverController.connect = function(resizeObserver, callback) {
        var detail = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverDetail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverDetail"](resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].push(detail);
            detail.observationTargets.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObservation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObservation"](target, options && options.box));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateCount"])(1);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scheduler"].schedule();
        }
    };
    ResizeObserverController.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].splice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateCount"])(-1);
        }
    };
    ResizeObserverController.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
            return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}();
;
}}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserver.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ResizeObserver": (()=>ResizeObserver)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
;
var ResizeObserver = function() {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].connect(this, callback);
    }
    ResizeObserver.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].disconnect(this);
    };
    ResizeObserver.toString = function() {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}();
;
}}),
"[project]/node_modules/direction/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = direction;
var RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';
var LTR = 'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' + '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' + '\uFE00-\uFE6F\uFEFD-\uFFFF';
var rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']');
var ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']');
function direction(value) {
    value = String(value || '');
    if (rtl.test(value)) {
        return 'rtl';
    }
    if (ltr.test(value)) {
        return 'ltr';
    }
    return 'neutral';
}
}}),
"[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;
}}),
"[project]/node_modules/lodash/_freeGlobal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
}}),
"[project]/node_modules/lodash/_root.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var freeGlobal = __turbopack_require__("[project]/node_modules/lodash/_freeGlobal.js [app-client] (ecmascript)");
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;
}}),
"[project]/node_modules/lodash/now.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var root = __turbopack_require__("[project]/node_modules/lodash/_root.js [app-client] (ecmascript)");
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
module.exports = now;
}}),
"[project]/node_modules/lodash/_trimmedEndIndex.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/** Used to match a single whitespace character. */ var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */ function trimmedEndIndex(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index))){}
    return index;
}
module.exports = trimmedEndIndex;
}}),
"[project]/node_modules/lodash/_baseTrim.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var trimmedEndIndex = __turbopack_require__("[project]/node_modules/lodash/_trimmedEndIndex.js [app-client] (ecmascript)");
/** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */ function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}
module.exports = baseTrim;
}}),
"[project]/node_modules/lodash/_Symbol.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var root = __turbopack_require__("[project]/node_modules/lodash/_root.js [app-client] (ecmascript)");
/** Built-in value references. */ var Symbol = root.Symbol;
module.exports = Symbol;
}}),
"[project]/node_modules/lodash/_getRawTag.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var Symbol = __turbopack_require__("[project]/node_modules/lodash/_Symbol.js [app-client] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if ("TURBOPACK compile-time truthy", 1) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
module.exports = getRawTag;
}}),
"[project]/node_modules/lodash/_objectToString.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;
}}),
"[project]/node_modules/lodash/_baseGetTag.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var Symbol = __turbopack_require__("[project]/node_modules/lodash/_Symbol.js [app-client] (ecmascript)"), getRawTag = __turbopack_require__("[project]/node_modules/lodash/_getRawTag.js [app-client] (ecmascript)"), objectToString = __turbopack_require__("[project]/node_modules/lodash/_objectToString.js [app-client] (ecmascript)");
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;
}}),
"[project]/node_modules/lodash/isObjectLike.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
module.exports = isObjectLike;
}}),
"[project]/node_modules/lodash/isSymbol.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var baseGetTag = __turbopack_require__("[project]/node_modules/lodash/_baseGetTag.js [app-client] (ecmascript)"), isObjectLike = __turbopack_require__("[project]/node_modules/lodash/isObjectLike.js [app-client] (ecmascript)");
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
module.exports = isSymbol;
}}),
"[project]/node_modules/lodash/toNumber.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var baseTrim = __turbopack_require__("[project]/node_modules/lodash/_baseTrim.js [app-client] (ecmascript)"), isObject = __turbopack_require__("[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)"), isSymbol = __turbopack_require__("[project]/node_modules/lodash/isSymbol.js [app-client] (ecmascript)");
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = toNumber;
}}),
"[project]/node_modules/lodash/debounce.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var isObject = __turbopack_require__("[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)"), now = __turbopack_require__("[project]/node_modules/lodash/now.js [app-client] (ecmascript)"), toNumber = __turbopack_require__("[project]/node_modules/lodash/toNumber.js [app-client] (ecmascript)");
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
module.exports = debounce;
}}),
"[project]/node_modules/lodash/throttle.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var debounce = __turbopack_require__("[project]/node_modules/lodash/debounce.js [app-client] (ecmascript)"), isObject = __turbopack_require__("[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)");
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */ function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
    });
}
module.exports = throttle;
}}),
"[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "compute": (()=>r)
});
const t = (t)=>"object" == typeof t && null != t && 1 === t.nodeType, e = (t, e)=>(!e || "hidden" !== t) && "visible" !== t && "clip" !== t, n = (t, n)=>{
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
        const o = getComputedStyle(t, null);
        return e(o.overflowY, n) || e(o.overflowX, n) || ((t)=>{
            const e = ((t)=>{
                if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
                try {
                    return t.ownerDocument.defaultView.frameElement;
                } catch (t) {
                    return null;
                }
            })(t);
            return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
        })(t);
    }
    return !1;
}, o = (t, e, n, o, l, r, i, s)=>r < t && i > e || r > t && i < e ? 0 : r <= t && s <= n || i >= e && s >= n ? r - t - o : i > e && s < n || r < t && s > n ? i - e + l : 0, l = (t)=>{
    const e = t.parentElement;
    return null == e ? t.getRootNode().host || null : e;
}, r = (e, r)=>{
    var i, s, d, h;
    if ("undefined" == typeof document) return [];
    const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r, p = "function" == typeof a ? a : (t)=>t !== a;
    if (!t(e)) throw new TypeError("Invalid target");
    const m = document.scrollingElement || document.documentElement, w = [];
    let W = e;
    for(; t(W) && p(W);){
        if (W = l(W), W === m) {
            w.push(W);
            break;
        }
        null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
    }
    const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t)=>{
        const e = window.getComputedStyle(t);
        return {
            top: parseFloat(e.scrollMarginTop) || 0,
            right: parseFloat(e.scrollMarginRight) || 0,
            bottom: parseFloat(e.scrollMarginBottom) || 0,
            left: parseFloat(e.scrollMarginLeft) || 0
        };
    })(e);
    let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
    const L = [];
    for(let t = 0; t < w.length; t++){
        const e = w[t], { height: n, width: l, top: r, right: i, bottom: s, left: d } = e.getBoundingClientRect();
        if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && x >= r && I <= s && R >= d && C <= i) return L;
        const h = getComputedStyle(e), a = parseInt(h.borderLeftWidth, 10), g = parseInt(h.borderTopWidth, 10), p = parseInt(h.borderRightWidth, 10), W = parseInt(h.borderBottomWidth, 10);
        let T = 0, B = 0;
        const F = "offsetWidth" in e ? e.offsetWidth - e.clientWidth - a - p : 0, V = "offsetHeight" in e ? e.offsetHeight - e.clientHeight - g - W : 0, S = "offsetWidth" in e ? 0 === e.offsetWidth ? 0 : l / e.offsetWidth : 0, X = "offsetHeight" in e ? 0 === e.offsetHeight ? 0 : n / e.offsetHeight : 0;
        if (m === e) T = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, g, W, M + k, M + k + v, v) : k - H / 2, B = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, a, p, y + D, y + D + E, E), T = Math.max(0, T + M), B = Math.max(0, B + y);
        else {
            T = "start" === f ? k - r - g : "end" === f ? k - s + W + V : "nearest" === f ? o(r, s, n, g, W + V, k, k + v, v) : k - (r + n / 2) + V / 2, B = "start" === u ? D - d - a : "center" === u ? D - (d + l / 2) + F / 2 : "end" === u ? D - i + p + F : o(d, i, l, a, p + F, D, D + E, E);
            const { scrollLeft: t, scrollTop: h } = e;
            T = 0 === X ? 0 : Math.max(0, Math.min(h + T / X, e.scrollHeight - n / X + V)), B = 0 === S ? 0 : Math.max(0, Math.min(t + B / S, e.scrollWidth - l / S + F)), k += h - T, D += t - B;
        }
        L.push({
            el: e,
            top: T,
            left: B
        });
    }
    return L;
};
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/scroll-into-view-if-needed/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>e)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)");
;
const o = (t)=>!1 === t ? {
        block: "end",
        inline: "nearest"
    } : ((t)=>t === Object(t) && 0 !== Object.keys(t).length)(t) ? t : {
        block: "start",
        inline: "nearest"
    };
function e(e, r) {
    if (!e.isConnected || !((t)=>{
        let o = t;
        for(; o && o.parentNode;){
            if (o.parentNode === document) return !0;
            o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;
        }
        return !1;
    })(e)) return;
    const n = ((t)=>{
        const o = window.getComputedStyle(t);
        return {
            top: parseFloat(o.scrollMarginTop) || 0,
            right: parseFloat(o.scrollMarginRight) || 0,
            bottom: parseFloat(o.scrollMarginBottom) || 0,
            left: parseFloat(o.scrollMarginLeft) || 0
        };
    })(e);
    if (((t)=>"object" == typeof t && "function" == typeof t.behavior)(r)) return r.behavior((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, r));
    const l = "boolean" == typeof r || null == r ? void 0 : r.behavior;
    for (const { el: a, top: i, left: s } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, o(r))){
        const t = i - n.top + n.bottom, o = s - n.left + n.right;
        a.scroll({
            top: t,
            left: o,
            behavior: l
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/slate-react/dist/index.es.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DefaultElement": (()=>DefaultElement),
    "DefaultLeaf": (()=>DefaultLeaf),
    "DefaultPlaceholder": (()=>DefaultPlaceholder),
    "Editable": (()=>Editable),
    "ReactEditor": (()=>ReactEditor),
    "Slate": (()=>Slate),
    "useComposing": (()=>useComposing),
    "useEditor": (()=>useEditor),
    "useFocused": (()=>useFocused),
    "useReadOnly": (()=>useReadOnly),
    "useSelected": (()=>useSelected),
    "useSlate": (()=>useSlate),
    "useSlateSelection": (()=>useSlateSelection),
    "useSlateSelector": (()=>useSlateSelector),
    "useSlateStatic": (()=>useSlateStatic),
    "useSlateWithV": (()=>useSlateWithV),
    "withReact": (()=>withReact)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/slate-dom/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$direction$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/direction/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/throttle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/debounce.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scroll$2d$into$2d$view$2d$if$2d$needed$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/scroll-into-view-if-needed/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * A React context for sharing the editor object.
 */ var EditorContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */ var useSlateStatic = ()=>{
    var editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorContext);
    if (!editor) {
        throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
    }
    return editor;
};
// eslint-disable-next-line no-redeclare
var ReactEditor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"];
function ownKeys$5(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$5(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41
// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.
var RESOLVE_DELAY = 25;
// Time with no user interaction before the current user action is considered as done.
var FLUSH_DELAY = 200;
// Replace with `const debug = console.log` to debug
var debug = function debug() {};
// Type guard to check if a value is a DataTransfer
var isDataTransfer = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';
function createAndroidInputManager(_ref) {
    var { editor, scheduleOnDOMSelectionChange, onDOMSelectionChange } = _ref;
    var flushing = false;
    var compositionEndTimeoutId = null;
    var flushTimeoutId = null;
    var actionTimeoutId = null;
    var idCounter = 0;
    var insertPositionHint = false;
    var applyPendingSelection = ()=>{
        var pendingSelection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].get(editor);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].delete(editor);
        if (pendingSelection) {
            var { selection } = editor;
            var normalized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeRange"])(editor, pendingSelection);
            if (normalized && (!selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(normalized, selection))) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, normalized);
            }
        }
    };
    var performAction = ()=>{
        var action = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].get(editor);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].delete(editor);
        if (!action) {
            return;
        }
        if (action.at) {
            var target = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].isPoint(action.at) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizePoint"])(editor, action.at) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeRange"])(editor, action.at);
            if (!target) {
                return;
            }
            var _targetRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, target);
            if (!editor.selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(editor.selection, _targetRange)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, target);
            }
        }
        action.run();
    };
    var flush = ()=>{
        if (flushTimeoutId) {
            clearTimeout(flushTimeoutId);
            flushTimeoutId = null;
        }
        if (actionTimeoutId) {
            clearTimeout(actionTimeoutId);
            actionTimeoutId = null;
        }
        if (!hasPendingDiffs() && !hasPendingAction()) {
            applyPendingSelection();
            return;
        }
        if (!flushing) {
            flushing = true;
            setTimeout(()=>flushing = false);
        }
        if (hasPendingAction()) {
            flushing = 'action';
        }
        var selectionRef = editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].rangeRef(editor, editor.selection, {
            affinity: 'forward'
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].set(editor, editor.marks);
        debug('flush', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].get(editor), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor));
        var scheduleSelectionChange = hasPendingDiffs();
        var diff;
        while(diff = (_EDITOR_TO_PENDING_DI = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]){
            var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
            var pendingMarks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].get(editor);
            if (pendingMarks !== undefined) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].delete(editor);
                editor.marks = pendingMarks;
            }
            if (pendingMarks && insertPositionHint === false) {
                insertPositionHint = null;
            }
            var range = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["targetRange"])(diff);
            if (!editor.selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(editor.selection, range)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, range);
            }
            if (diff.diff.text) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, diff.diff.text);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor);
            }
            // Remove diff only after we have applied it to account for it when transforming
            // pending ranges.
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].set(editor, (_EDITOR_TO_PENDING_DI2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2)=>{
                var { id } = _ref2;
                return id !== diff.id;
            }));
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verifyDiffState"])(editor, diff)) {
                scheduleSelectionChange = false;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].delete(editor);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].delete(editor);
                flushing = 'action';
                // Ensure we don't restore the pending user (dom) selection
                // since the document and dom state do not match.
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].delete(editor);
                scheduleOnDOMSelectionChange.cancel();
                onDOMSelectionChange.cancel();
                selectionRef === null || selectionRef === void 0 || selectionRef.unref();
            }
        }
        var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
        if (selection && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].get(editor) && (!editor.selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(selection, editor.selection))) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, selection);
        }
        if (hasPendingAction()) {
            performAction();
            return;
        }
        // COMPAT: The selectionChange event is fired after the action is performed,
        // so we have to manually schedule it to ensure we don't 'throw away' the selection
        // while rendering if we have pending changes.
        if (scheduleSelectionChange) {
            scheduleOnDOMSelectionChange();
        }
        scheduleOnDOMSelectionChange.flush();
        onDOMSelectionChange.flush();
        applyPendingSelection();
        var userMarks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].get(editor);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].delete(editor);
        if (userMarks !== undefined) {
            editor.marks = userMarks;
            editor.onChange();
        }
    };
    var handleCompositionEnd = (_event)=>{
        if (compositionEndTimeoutId) {
            clearTimeout(compositionEndTimeoutId);
        }
        compositionEndTimeoutId = setTimeout(()=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, false);
            flush();
        }, RESOLVE_DELAY);
    };
    var handleCompositionStart = (_event)=>{
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, true);
        if (compositionEndTimeoutId) {
            clearTimeout(compositionEndTimeoutId);
            compositionEndTimeoutId = null;
        }
    };
    var updatePlaceholderVisibility = function updatePlaceholderVisibility() {
        var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var placeholderElement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PLACEHOLDER_ELEMENT"].get(editor);
        if (!placeholderElement) {
            return;
        }
        if (hasPendingDiffs() || forceHide) {
            placeholderElement.style.display = 'none';
            return;
        }
        placeholderElement.style.removeProperty('display');
    };
    var storeDiff = (path, diff)=>{
        var _EDITOR_TO_PENDING_DI3;
        var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].set(editor, pendingDiffs);
        var target = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].leaf(editor, path);
        var idx = pendingDiffs.findIndex((change)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(change.path, path));
        if (idx < 0) {
            var normalized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeStringDiff"])(target.text, diff);
            if (normalized) {
                pendingDiffs.push({
                    path,
                    diff,
                    id: idCounter++
                });
            }
            updatePlaceholderVisibility();
            return;
        }
        var merged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeStringDiffs"])(target.text, pendingDiffs[idx].diff, diff);
        if (!merged) {
            pendingDiffs.splice(idx, 1);
            updatePlaceholderVisibility();
            return;
        }
        pendingDiffs[idx] = _objectSpread$5(_objectSpread$5({}, pendingDiffs[idx]), {}, {
            diff: merged
        });
    };
    var scheduleAction = function scheduleAction(run) {
        var { at } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        insertPositionHint = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        if (hasPendingAction()) {
            flush();
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].set(editor, {
            at,
            run
        });
        // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,
        // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush
        // in this case and thus never actually perform the action.
        actionTimeoutId = setTimeout(flush);
    };
    var handleDOMBeforeInput = (event)=>{
        var _targetRange2;
        if (flushTimeoutId) {
            clearTimeout(flushTimeoutId);
            flushTimeoutId = null;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_NODE_MAP_DIRTY"].get(editor)) {
            return;
        }
        var { inputType: type } = event;
        var targetRange = null;
        var data = event.dataTransfer || event.data || undefined;
        if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {
            insertPositionHint = false;
        }
        var [nativeTargetRange] = event.getTargetRanges();
        if (nativeTargetRange) {
            targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {
                exactMatch: false,
                suppressThrow: true
            });
        }
        // COMPAT: SelectionChange event is fired after the action is performed, so we
        // have to manually get the selection here to ensure it's up-to-date.
        var window1 = ReactEditor.getWindow(editor);
        var domSelection = window1.getSelection();
        if (!targetRange && domSelection) {
            nativeTargetRange = domSelection;
            targetRange = ReactEditor.toSlateRange(editor, domSelection, {
                exactMatch: false,
                suppressThrow: true
            });
        }
        targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
        if (!targetRange) {
            return;
        }
        // By default, the input manager tries to store text diffs so that we can
        // defer flushing them at a later point in time. We don't want to flush
        // for every input event as this can be expensive. However, there are some
        // scenarios where we cannot safely store the text diff and must instead
        // schedule an action to let Slate normalize the editor state.
        var canStoreDiff = true;
        if (type.startsWith('delete')) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(targetRange)) {
                var [_start, _end] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].edges(targetRange);
                var _leaf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].leaf(editor, _start.path);
                if (_leaf.text.length === _start.offset && _end.offset === 0) {
                    var next = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].next(editor, {
                        at: _start.path,
                        match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText
                    });
                    if (next && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(next[1], _end.path)) {
                        targetRange = {
                            anchor: _end,
                            focus: _end
                        };
                    }
                }
            }
            var direction = type.endsWith('Backward') ? 'backward' : 'forward';
            var [start, end] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].edges(targetRange);
            var [leaf, path] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].leaf(editor, start.path);
            var diff = {
                text: '',
                start: start.offset,
                end: end.offset
            };
            var pendingDiffs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor);
            var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(change.path, path));
            var diffs = relevantPendingDiffs ? [
                relevantPendingDiffs.diff,
                diff
            ] : [
                diff
            ];
            var text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyStringDiff"])(leaf.text, ...diffs);
            if (text.length === 0) {
                // Text leaf will be removed, so we need to schedule an
                // action to remove it so that Slate can normalize instead
                // of storing as a diff
                canStoreDiff = false;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(targetRange)) {
                if (canStoreDiff && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(targetRange.anchor.path, targetRange.focus.path)) {
                    var point = {
                        path: targetRange.anchor.path,
                        offset: start.offset
                    };
                    var range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, point, point);
                    handleUserSelect(range);
                    return storeDiff(targetRange.anchor.path, {
                        text: '',
                        end: end.offset,
                        start: start.offset
                    });
                }
                return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                        direction
                    }), {
                    at: targetRange
                });
            }
        }
        switch(type){
            case 'deleteByComposition':
            case 'deleteByCut':
            case 'deleteByDrag':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor), {
                        at: targetRange
                    });
                }
            case 'deleteContent':
            case 'deleteContentForward':
                {
                    var { anchor } = targetRange;
                    if (canStoreDiff && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(targetRange)) {
                        var targetNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].leaf(editor, anchor.path);
                        if (anchor.offset < targetNode.text.length) {
                            return storeDiff(anchor.path, {
                                text: '',
                                start: anchor.offset,
                                end: anchor.offset + 1
                            });
                        }
                    }
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor), {
                        at: targetRange
                    });
                }
            case 'deleteContentBackward':
                {
                    var _nativeTargetRange;
                    var { anchor: _anchor } = targetRange;
                    // If we have a mismatch between the native and slate selection being collapsed
                    // we are most likely deleting a zero-width placeholder and thus should perform it
                    // as an action to ensure correct behavior (mostly happens with mark placeholders)
                    var nativeCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMSelection"])(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
                    if (canStoreDiff && nativeCollapsed && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(targetRange) && _anchor.offset > 0) {
                        return storeDiff(_anchor.path, {
                            text: '',
                            start: _anchor.offset - 1,
                            end: _anchor.offset
                        });
                    }
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor), {
                        at: targetRange
                    });
                }
            case 'deleteEntireSoftLine':
                {
                    return scheduleAction(()=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                            unit: 'line'
                        });
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                            unit: 'line'
                        });
                    }, {
                        at: targetRange
                    });
                }
            case 'deleteHardLineBackward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                            unit: 'block'
                        }), {
                        at: targetRange
                    });
                }
            case 'deleteSoftLineBackward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                            unit: 'line'
                        }), {
                        at: targetRange
                    });
                }
            case 'deleteHardLineForward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                            unit: 'block'
                        }), {
                        at: targetRange
                    });
                }
            case 'deleteSoftLineForward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                            unit: 'line'
                        }), {
                        at: targetRange
                    });
                }
            case 'deleteWordBackward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                            unit: 'word'
                        }), {
                        at: targetRange
                    });
                }
            case 'deleteWordForward':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                            unit: 'word'
                        }), {
                        at: targetRange
                    });
                }
            case 'insertLineBreak':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertSoftBreak(editor), {
                        at: targetRange
                    });
                }
            case 'insertParagraph':
                {
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertBreak(editor), {
                        at: targetRange
                    });
                }
            case 'insertCompositionText':
            case 'deleteCompositionText':
            case 'insertFromComposition':
            case 'insertFromDrop':
            case 'insertFromPaste':
            case 'insertFromYank':
            case 'insertReplacementText':
            case 'insertText':
                {
                    if (isDataTransfer(data)) {
                        return scheduleAction(()=>ReactEditor.insertData(editor, data), {
                            at: targetRange
                        });
                    }
                    var _text = data !== null && data !== void 0 ? data : '';
                    // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside
                    // the placeholder itself and thus includes the zero-width space inside edit events.
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].get(editor)) {
                        _text = _text.replace('\uFEFF', '');
                    }
                    // Pastes from the Android clipboard will generate `insertText` events.
                    // If the copied text contains any newlines, Android will append an
                    // extra newline to the end of the copied text.
                    if (type === 'insertText' && /.*\n.*\n$/.test(_text)) {
                        _text = _text.slice(0, -1);
                    }
                    // If the text includes a newline, split it at newlines and paste each component
                    // string, with soft breaks in between each.
                    if (_text.includes('\n')) {
                        return scheduleAction(()=>{
                            var parts = _text.split('\n');
                            parts.forEach((line, i)=>{
                                if (line) {
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, line);
                                }
                                if (i !== parts.length - 1) {
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertSoftBreak(editor);
                                }
                            });
                        }, {
                            at: targetRange
                        });
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(targetRange.anchor.path, targetRange.focus.path)) {
                        var [_start2, _end2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].edges(targetRange);
                        var _diff = {
                            start: _start2.offset,
                            end: _end2.offset,
                            text: _text
                        };
                        // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word
                        // inserted after a mark placeholder is inserted with an anchor offset off by 1.
                        // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert
                        // text events are fired with the correct target ranges, only the final 'insertComposition'
                        // isn't, so we can adjust the target range start offset if we are confident this is the
                        // swiftkey insert causing the issue.
                        if (_text && insertPositionHint && type === 'insertCompositionText') {
                            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
                            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
                            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
                                _diff.start -= 1;
                                insertPositionHint = null;
                                scheduleFlush();
                            } else {
                                insertPositionHint = false;
                            }
                        } else if (type === 'insertText') {
                            if (insertPositionHint === null) {
                                insertPositionHint = _diff;
                            } else if (insertPositionHint && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
                                insertPositionHint = _objectSpread$5(_objectSpread$5({}, insertPositionHint), {}, {
                                    text: insertPositionHint.text + _text
                                });
                            } else {
                                insertPositionHint = false;
                            }
                        } else {
                            insertPositionHint = false;
                        }
                        if (canStoreDiff) {
                            storeDiff(_start2.path, _diff);
                            return;
                        }
                    }
                    return scheduleAction(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, _text), {
                        at: targetRange
                    });
                }
        }
    };
    var hasPendingAction = ()=>{
        return !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_ACTION"].get(editor);
    };
    var hasPendingDiffs = ()=>{
        var _EDITOR_TO_PENDING_DI4;
        return !!((_EDITOR_TO_PENDING_DI4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_DIFFS"].get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
    };
    var hasPendingChanges = ()=>{
        return hasPendingAction() || hasPendingDiffs();
    };
    var isFlushing = ()=>{
        return flushing;
    };
    var handleUserSelect = (range)=>{
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_SELECTION"].set(editor, range);
        if (flushTimeoutId) {
            clearTimeout(flushTimeoutId);
            flushTimeoutId = null;
        }
        var { selection } = editor;
        if (!range) {
            return;
        }
        var pathChanged = !selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(selection.anchor.path, range.anchor.path);
        var parentPathChanged = !selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));
        if (pathChanged && insertPositionHint || parentPathChanged) {
            insertPositionHint = false;
        }
        if (pathChanged || hasPendingDiffs()) {
            flushTimeoutId = setTimeout(flush, FLUSH_DELAY);
        }
    };
    var handleInput = ()=>{
        if (hasPendingAction() || !hasPendingDiffs()) {
            flush();
        }
    };
    var handleKeyDown = (_)=>{
        // COMPAT: Swiftkey closes the keyboard when typing inside a empty node
        // directly next to a non-contenteditable element (= the placeholder).
        // The only event fired soon enough for us to allow hiding the placeholder
        // without swiftkey picking it up is the keydown event, so we have to hide it
        // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535
        if (!hasPendingDiffs()) {
            updatePlaceholderVisibility(true);
            setTimeout(updatePlaceholderVisibility);
        }
    };
    var scheduleFlush = ()=>{
        if (!hasPendingAction()) {
            actionTimeoutId = setTimeout(flush);
        }
    };
    var handleDomMutations = (mutations)=>{
        if (hasPendingDiffs() || hasPendingAction()) {
            return;
        }
        if (mutations.some((mutation)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTrackedMutation"])(editor, mutation, mutations))) {
            var _EDITOR_TO_FORCE_REND;
            // Cause a re-render to restore the dom state if we encounter tracked mutations without
            // a corresponding pending action.
            (_EDITOR_TO_FORCE_REND = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_FORCE_RENDER"].get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();
        }
    };
    return {
        flush,
        scheduleFlush,
        hasPendingDiffs,
        hasPendingAction,
        hasPendingChanges,
        isFlushing,
        handleUserSelect,
        handleCompositionEnd,
        handleCompositionStart,
        handleDOMBeforeInput,
        handleKeyDown,
        handleDomMutations,
        handleInput
    };
}
function useIsMounted() {
    var isMountedRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useIsMounted.useEffect": ()=>{
            isMountedRef.current = true;
            return ({
                "useIsMounted.useEffect": ()=>{
                    isMountedRef.current = false;
                }
            })["useIsMounted.useEffect"];
        }
    }["useIsMounted.useEffect"], []);
    return isMountedRef.current;
}
/**
 * Prevent warning on SSR by falling back to useEffect when DOM isn't available
 */ var useIsomorphicLayoutEffect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CAN_USE_DOM"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
function useMutationObserver(node, callback, options) {
    var [mutationObserver] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useMutationObserver.useState": ()=>new MutationObserver(callback)
    }["useMutationObserver.useState"]);
    useIsomorphicLayoutEffect({
        "useMutationObserver.useIsomorphicLayoutEffect": ()=>{
            // Discard mutations caused during render phase. This works due to react calling
            // useLayoutEffect synchronously after the render phase before the next tick.
            mutationObserver.takeRecords();
        }
    }["useMutationObserver.useIsomorphicLayoutEffect"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useMutationObserver.useEffect": ()=>{
            if (!node.current) {
                throw new Error('Failed to attach MutationObserver, `node` is undefined');
            }
            mutationObserver.observe(node.current, options);
            return ({
                "useMutationObserver.useEffect": ()=>mutationObserver.disconnect()
            })["useMutationObserver.useEffect"];
        }
    }["useMutationObserver.useEffect"], [
        mutationObserver,
        node,
        options
    ]);
}
var _excluded$2 = [
    "node"
];
function ownKeys$4(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$4(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var MUTATION_OBSERVER_CONFIG$1 = {
    subtree: true,
    childList: true,
    characterData: true
};
var useAndroidInputManager = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] ? ()=>null : (_ref)=>{
    var { node } = _ref, options = _objectWithoutProperties(_ref, _excluded$2);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"]) {
        return null;
    }
    var editor = useSlateStatic();
    var isMounted = useIsMounted();
    var [inputManager] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(()=>createAndroidInputManager(_objectSpread$4({
            editor
        }, options)));
    useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_SCHEDULE_FLUSH"].set(editor, inputManager.scheduleFlush);
    if (isMounted) {
        inputManager.flush();
    }
    return inputManager;
};
function ownKeys$3(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$3(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
/**
 * Leaf content strings.
 */ var String$1 = (props)=>{
    var { isLast, leaf, parent, text } = props;
    var editor = useSlateStatic();
    var path = ReactEditor.findPath(editor, text);
    var parentPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(path);
    var isMarkPlaceholder = Boolean(leaf[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MARK_PLACEHOLDER_SYMBOL"]]);
    // COMPAT: Render text inside void nodes with a zero-width space.
    // So the node can contain selection but the text is not visible.
    if (editor.isVoid(parent)) {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ZeroWidthString, {
            length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].string(parent).length
        });
    }
    // COMPAT: If this is the last text node in an empty block, render a zero-
    // width space that will convert into a line break when copying and pasting
    // to support expected plain text.
    if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].string(editor, parentPath) === '') {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ZeroWidthString, {
            isLineBreak: true,
            isMarkPlaceholder: isMarkPlaceholder
        });
    }
    // COMPAT: If the text is empty, it's because it's on the edge of an inline
    // node, so we render a zero-width space so that the selection can be
    // inserted next to it still.
    if (leaf.text === '') {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ZeroWidthString, {
            isMarkPlaceholder: isMarkPlaceholder
        });
    }
    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,
    // so we need to add an extra trailing new lines to prevent that.
    if (isLast && leaf.text.slice(-1) === '\n') {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(TextString, {
            isTrailing: true,
            text: leaf.text
        });
    }
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(TextString, {
        text: leaf.text
    });
};
/**
 * Leaf strings with text in them.
 */ var TextString = (props)=>{
    var { text, isTrailing = false } = props;
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var getTextContent = ()=>{
        return "".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\n' : '');
    };
    var [initialText] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(getTextContent);
    // This is the actual text rendering boundary where we interface with the DOM
    // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,
    // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing
    // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content
    // exactly if and only if its current content does not match our current virtual DOM.
    // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,
    // eg makes native spellcheck opt out from checking the text node.
    // useLayoutEffect: updating our span before browser paint
    useIsomorphicLayoutEffect({
        "TextString.useIsomorphicLayoutEffect": ()=>{
            // null coalescing text to make sure we're not outputing "null" as a string in the extreme case it is nullish at runtime
            var textWithTrailing = getTextContent();
            if (ref.current && ref.current.textContent !== textWithTrailing) {
                ref.current.textContent = textWithTrailing;
            }
        // intentionally not specifying dependencies, so that this effect runs on every render
        // as this effectively replaces "specifying the text in the virtual DOM under the <span> below" on each render
        }
    }["TextString.useIsomorphicLayoutEffect"]);
    // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.
    // We defer to the layout effect above to update the `textContent` of the span element when needed.
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(MemoizedText$1, {
        ref: ref
    }, initialText);
};
var MemoizedText$1 = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])((props, ref)=>{
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        "data-slate-string": true,
        ref: ref
    }, props.children);
}));
/**
 * Leaf strings without text, render as zero-width strings.
 */ var ZeroWidthString = (props)=>{
    var { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props;
    var attributes = {
        'data-slate-zero-width': isLineBreak ? 'n' : 'z',
        'data-slate-length': length
    };
    if (isMarkPlaceholder) {
        attributes['data-slate-mark-placeholder'] = true;
    }
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", _objectSpread$3({}, attributes), !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_IOS"]) || !isLineBreak ? '\uFEFF' : null, isLineBreak ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("br", null) : null);
};
function ownKeys$2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$2(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
// Delay the placeholder on Android to prevent the keyboard from closing.
// (https://github.com/ianstormtaylor/slate/pull/5368)
var PLACEHOLDER_DELAY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] ? 300 : 0;
function disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {
    if (placeholderResizeObserver.current) {
        placeholderResizeObserver.current.disconnect();
        if (releaseObserver) {
            placeholderResizeObserver.current = null;
        }
    }
}
function clearTimeoutRef(timeoutRef) {
    if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
    }
}
/**
 * Individual leaves in a text node with unique formatting.
 */ var Leaf = (props)=>{
    var { leaf, isLast, text, parent, renderPlaceholder, renderLeaf = (props)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(DefaultLeaf, _objectSpread$2({}, props)) } = props;
    var editor = useSlateStatic();
    var placeholderResizeObserver = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var placeholderRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var [showPlaceholder, setShowPlaceholder] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    var showPlaceholderTimeoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var callbackPlaceholderRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Leaf.useCallback[callbackPlaceholderRef]": (placeholderEl)=>{
            disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);
            if (placeholderEl == null) {
                var _leaf$onPlaceholderRe;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PLACEHOLDER_ELEMENT"].delete(editor);
                (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf, null);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PLACEHOLDER_ELEMENT"].set(editor, placeholderEl);
                if (!placeholderResizeObserver.current) {
                    // Create a new observer and observe the placeholder element.
                    var ResizeObserver$1 = window.ResizeObserver || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserver"];
                    placeholderResizeObserver.current = new ResizeObserver$1({
                        "Leaf.useCallback[callbackPlaceholderRef]": ()=>{
                            var _leaf$onPlaceholderRe2;
                            (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf, placeholderEl);
                        }
                    }["Leaf.useCallback[callbackPlaceholderRef]"]);
                }
                placeholderResizeObserver.current.observe(placeholderEl);
                placeholderRef.current = placeholderEl;
            }
        }
    }["Leaf.useCallback[callbackPlaceholderRef]"], [
        placeholderRef,
        leaf,
        editor
    ]);
    var children = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(String$1, {
        isLast: isLast,
        leaf: leaf,
        parent: parent,
        text: text
    });
    var leafIsPlaceholder = Boolean(leaf[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLACEHOLDER_SYMBOL"]]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Leaf.useEffect": ()=>{
            if (leafIsPlaceholder) {
                if (!showPlaceholderTimeoutRef.current) {
                    // Delay the placeholder, so it will not render in a selection
                    showPlaceholderTimeoutRef.current = setTimeout({
                        "Leaf.useEffect": ()=>{
                            setShowPlaceholder(true);
                            showPlaceholderTimeoutRef.current = null;
                        }
                    }["Leaf.useEffect"], PLACEHOLDER_DELAY);
                }
            } else {
                clearTimeoutRef(showPlaceholderTimeoutRef);
                setShowPlaceholder(false);
            }
            return ({
                "Leaf.useEffect": ()=>clearTimeoutRef(showPlaceholderTimeoutRef)
            })["Leaf.useEffect"];
        }
    }["Leaf.useEffect"], [
        leafIsPlaceholder,
        setShowPlaceholder
    ]);
    if (leafIsPlaceholder && showPlaceholder) {
        var placeholderProps = {
            children: leaf.placeholder,
            attributes: {
                'data-slate-placeholder': true,
                style: {
                    position: 'absolute',
                    top: 0,
                    pointerEvents: 'none',
                    width: '100%',
                    maxWidth: '100%',
                    display: 'block',
                    opacity: '0.333',
                    userSelect: 'none',
                    textDecoration: 'none',
                    // Fixes https://github.com/udecode/plate/issues/2315
                    WebkitUserModify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"] ? 'inherit' : undefined
                },
                contentEditable: false,
                ref: callbackPlaceholderRef
            }
        };
        children = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, renderPlaceholder(placeholderProps), children);
    }
    // COMPAT: Having the `data-` attributes on these leaf elements ensures that
    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by
    // contenteditable behaviors. (2019/05/08)
    var attributes = {
        'data-slate-leaf': true
    };
    return renderLeaf({
        attributes,
        children,
        leaf,
        text
    });
};
var MemoizedLeaf = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(Leaf, (prev, next)=>{
    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].equals(next.leaf, prev.leaf) && next.leaf[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLACEHOLDER_SYMBOL"]] === prev.leaf[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLACEHOLDER_SYMBOL"]];
});
var DefaultLeaf = (props)=>{
    var { attributes, children } = props;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", _objectSpread$2({}, attributes), children);
};
/**
 * Text.
 */ var Text = (props)=>{
    var { decorations, isLast, parent, renderPlaceholder, renderLeaf, text } = props;
    var editor = useSlateStatic();
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var leaves = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].decorations(text, decorations);
    var key = ReactEditor.findKey(editor, text);
    var children = [];
    for(var i = 0; i < leaves.length; i++){
        var leaf = leaves[i];
        children.push(/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(MemoizedLeaf, {
            isLast: isLast && i === leaves.length - 1,
            key: "".concat(key.id, "-").concat(i),
            renderPlaceholder: renderPlaceholder,
            leaf: leaf,
            text: text,
            parent: parent,
            renderLeaf: renderLeaf
        }));
    }
    // Update element-related weak maps with the DOM element ref.
    var callbackRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Text.useCallback[callbackRef]": (span)=>{
            var KEY_TO_ELEMENT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_KEY_TO_ELEMENT"].get(editor);
            if (span) {
                KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].set(text, span);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_TO_NODE"].set(span, text);
            } else {
                KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].delete(text);
                if (ref.current) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_TO_NODE"].delete(ref.current);
                }
            }
            ref.current = span;
        }
    }["Text.useCallback[callbackRef]"], [
        ref,
        editor,
        key,
        text
    ]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        "data-slate-node": "text",
        ref: callbackRef
    }, children);
};
var MemoizedText = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(Text, (prev, next)=>{
    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextDecorationsEqual"])(next.decorations, prev.decorations);
});
function ownKeys$1(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$1(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
/**
 * Element.
 */ var Element = (props)=>{
    var { decorations, element, renderElement = (p)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(DefaultElement, _objectSpread$1({}, p)), renderPlaceholder, renderLeaf, selection } = props;
    var editor = useSlateStatic();
    var readOnly = useReadOnly();
    var isInline = editor.isInline(element);
    var key = ReactEditor.findKey(editor, element);
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Element.useCallback[ref]": (ref)=>{
            // Update element-related weak maps with the DOM element ref.
            var KEY_TO_ELEMENT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_KEY_TO_ELEMENT"].get(editor);
            if (ref) {
                KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].set(element, ref);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_TO_NODE"].set(ref, element);
            } else {
                KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].delete(element);
            }
        }
    }["Element.useCallback[ref]"], [
        editor,
        key,
        element
    ]);
    var children = useChildren({
        decorations,
        node: element,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection
    });
    // Attributes that the developer must mix into the element in their
    // custom node renderer component.
    var attributes = {
        'data-slate-node': 'element',
        ref
    };
    if (isInline) {
        attributes['data-slate-inline'] = true;
    }
    // If it's a block node with inline children, add the proper `dir` attribute
    // for text direction.
    if (!isInline && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasInlines(editor, element)) {
        var text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].string(element);
        var dir = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$direction$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(text);
        if (dir === 'rtl') {
            attributes.dir = dir;
        }
    }
    // If it's a void node, wrap the children in extra void-specific elements.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, element)) {
        attributes['data-slate-void'] = true;
        if (!readOnly && isInline) {
            attributes.contentEditable = false;
        }
        var Tag = isInline ? 'span' : 'div';
        var [[_text]] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].texts(element);
        children = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, {
            "data-slate-spacer": true,
            style: {
                height: '0',
                color: 'transparent',
                outline: 'none',
                position: 'absolute'
            }
        }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(MemoizedText, {
            renderPlaceholder: renderPlaceholder,
            decorations: [],
            isLast: false,
            parent: element,
            text: _text
        }));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_INDEX"].set(_text, 0);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_PARENT"].set(_text, element);
    }
    return renderElement({
        attributes,
        children,
        element
    });
};
var MemoizedElement = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(Element, (prev, next)=>{
    return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElementDecorationsEqual"])(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(prev.selection, next.selection));
});
/**
 * The default element renderer.
 */ var DefaultElement = (props)=>{
    var { attributes, children, element } = props;
    var editor = useSlateStatic();
    var Tag = editor.isInline(element) ? 'span' : 'div';
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, _objectSpread$1(_objectSpread$1({}, attributes), {}, {
        style: {
            position: 'relative'
        }
    }), children);
};
/**
 * A React context for sharing the `decorate` prop of the editable.
 */ var DecorateContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(()=>[]);
/**
 * Get the current `decorate` prop of the editable.
 */ var useDecorate = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(DecorateContext);
};
/**
 * A React context for sharing the `selected` state of an element.
 */ var SelectedContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
/**
 * Get the current `selected` state of an element.
 */ var useSelected = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(SelectedContext);
};
/**
 * Children.
 */ var useChildren = (props)=>{
    var { decorations, node, renderElement, renderPlaceholder, renderLeaf, selection } = props;
    var decorate = useDecorate();
    var editor = useSlateStatic();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_NODE_MAP_DIRTY"].set(editor, false);
    var path = ReactEditor.findPath(editor, node);
    var children = [];
    var isLeafBlock = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && !editor.isInline(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasInlines(editor, node);
    for(var i = 0; i < node.children.length; i++){
        var p = path.concat(i);
        var n = node.children[i];
        var key = ReactEditor.findKey(editor, n);
        var range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, p);
        var sel = selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].intersection(range, selection);
        var ds = decorate([
            n,
            p
        ]);
        for (var dec of decorations){
            var d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].intersection(dec, range);
            if (d) {
                ds.push(d);
            }
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(n)) {
            children.push(/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SelectedContext.Provider, {
                key: "provider-".concat(key.id),
                value: !!sel
            }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(MemoizedElement, {
                decorations: ds,
                element: n,
                key: key.id,
                renderElement: renderElement,
                renderPlaceholder: renderPlaceholder,
                renderLeaf: renderLeaf,
                selection: sel
            })));
        } else {
            children.push(/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(MemoizedText, {
                decorations: ds,
                key: key.id,
                isLast: isLeafBlock && i === node.children.length - 1,
                parent: node,
                renderPlaceholder: renderPlaceholder,
                renderLeaf: renderLeaf,
                text: n
            }));
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_INDEX"].set(n, i);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_PARENT"].set(n, node);
    }
    return children;
};
/**
 * A React context for sharing the `readOnly` state of the editor.
 */ var ReadOnlyContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
/**
 * Get the current `readOnly` state of the editor.
 */ var useReadOnly = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ReadOnlyContext);
};
var SlateContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
/**
 * Get the current editor object from the React context.
 */ var useSlate = ()=>{
    var context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(SlateContext);
    if (!context) {
        throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
    }
    var { editor } = context;
    return editor;
};
var useSlateWithV = ()=>{
    var context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(SlateContext);
    if (!context) {
        throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
    }
    return context;
};
function useTrackUserInput() {
    var editor = useSlateStatic();
    var receivedUserInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    var animationFrameIdRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(0);
    var onUserInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTrackUserInput.useCallback[onUserInput]": ()=>{
            if (receivedUserInput.current) {
                return;
            }
            receivedUserInput.current = true;
            var window1 = ReactEditor.getWindow(editor);
            window1.cancelAnimationFrame(animationFrameIdRef.current);
            animationFrameIdRef.current = window1.requestAnimationFrame({
                "useTrackUserInput.useCallback[onUserInput]": ()=>{
                    receivedUserInput.current = false;
                }
            }["useTrackUserInput.useCallback[onUserInput]"]);
        }
    }["useTrackUserInput.useCallback[onUserInput]"], [
        editor
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTrackUserInput.useEffect": ()=>({
                "useTrackUserInput.useEffect": ()=>cancelAnimationFrame(animationFrameIdRef.current)
            })["useTrackUserInput.useEffect"]
    }["useTrackUserInput.useEffect"], []);
    return {
        receivedUserInput,
        onUserInput
    };
}
var createRestoreDomManager = (editor, receivedUserInput)=>{
    var bufferedMutations = [];
    var clear = ()=>{
        bufferedMutations = [];
    };
    var registerMutations = (mutations)=>{
        if (!receivedUserInput.current) {
            return;
        }
        var trackedMutations = mutations.filter((mutation)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTrackedMutation"])(editor, mutation, mutations));
        bufferedMutations.push(...trackedMutations);
    };
    function restoreDOM() {
        if (bufferedMutations.length > 0) {
            bufferedMutations.reverse().forEach((mutation)=>{
                if (mutation.type === 'characterData') {
                    // We don't want to restore the DOM for characterData mutations
                    // because this interrupts the composition.
                    return;
                }
                mutation.removedNodes.forEach((node)=>{
                    mutation.target.insertBefore(node, mutation.nextSibling);
                });
                mutation.addedNodes.forEach((node)=>{
                    mutation.target.removeChild(node);
                });
            });
            // Clear buffered mutations to ensure we don't undo them twice
            clear();
        }
    }
    return {
        registerMutations,
        restoreDOM,
        clear
    };
};
var MUTATION_OBSERVER_CONFIG = {
    subtree: true,
    childList: true,
    characterData: true,
    characterDataOldValue: true
};
// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent
// to run code synchronously immediately before react commits the component update to the DOM.
class RestoreDOMComponent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Component"] {
    constructor(){
        super(...arguments);
        _defineProperty(this, "context", null);
        _defineProperty(this, "manager", null);
        _defineProperty(this, "mutationObserver", null);
    }
    observe() {
        var _this$mutationObserve;
        var { node } = this.props;
        if (!node.current) {
            throw new Error('Failed to attach MutationObserver, `node` is undefined');
        }
        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);
    }
    componentDidMount() {
        var { receivedUserInput } = this.props;
        var editor = this.context;
        this.manager = createRestoreDomManager(editor, receivedUserInput);
        this.mutationObserver = new MutationObserver(this.manager.registerMutations);
        this.observe();
    }
    getSnapshotBeforeUpdate() {
        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
            var _this$manager;
            (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);
        }
        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();
        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();
        return null;
    }
    componentDidUpdate() {
        var _this$manager3;
        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();
        this.observe();
    }
    componentWillUnmount() {
        var _this$mutationObserve4;
        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();
    }
    render() {
        return this.props.children;
    }
}
_defineProperty(RestoreDOMComponent, "contextType", EditorContext);
var RestoreDOM = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] ? RestoreDOMComponent : (_ref)=>{
    var { children } = _ref;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, children);
};
/**
 * A React context for sharing the `composing` state of the editor.
 */ var ComposingContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
/**
 * Get the current `composing` state of the editor.
 */ var useComposing = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ComposingContext);
};
var _excluded$1 = [
    "autoFocus",
    "decorate",
    "onDOMBeforeInput",
    "placeholder",
    "readOnly",
    "renderElement",
    "renderLeaf",
    "renderPlaceholder",
    "scrollSelectionIntoView",
    "style",
    "as",
    "disableDefaultStyles"
], _excluded2 = [
    "text"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
var Children = (props)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, useChildren(props));
/**
 * Editable.
 */ var Editable = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])((props, forwardedRef)=>{
    var defaultRenderPlaceholder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Editable.useCallback[defaultRenderPlaceholder]": (props)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(DefaultPlaceholder, _objectSpread({}, props))
    }["Editable.useCallback[defaultRenderPlaceholder]"], []);
    var { autoFocus, decorate = defaultDecorate, onDOMBeforeInput: propsOnDOMBeforeInput, placeholder, readOnly = false, renderElement, renderLeaf, renderPlaceholder = defaultRenderPlaceholder, scrollSelectionIntoView = defaultScrollSelectionIntoView, style: userStyle = {}, as: Component = 'div', disableDefaultStyles = false } = props, attributes = _objectWithoutProperties(props, _excluded$1);
    var editor = useSlate();
    // Rerender editor when composition status changed
    var [isComposing, setIsComposing] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var deferredOperations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])([]);
    var [placeholderHeight, setPlaceholderHeight] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])();
    var processing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    var { onUserInput, receivedUserInput } = useTrackUserInput();
    var [, forceRender] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])({
        "Editable.useReducer": (s)=>s + 1
    }["Editable.useReducer"], 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_FORCE_RENDER"].set(editor, forceRender);
    // Update internal state on each render.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_READ_ONLY"].set(editor, readOnly);
    // Keep track of some state for the event handler logic.
    var state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Editable.useMemo[state]": ()=>({
                isDraggingInternally: false,
                isUpdatingSelection: false,
                latestElement: null,
                hasMarkPlaceholder: false
            })
    }["Editable.useMemo[state]"], []);
    // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it
    // needs to be manually focused.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Editable.useEffect": ()=>{
            if (ref.current && autoFocus) {
                ref.current.focus();
            }
        }
    }["Editable.useEffect"], [
        autoFocus
    ]);
    /**
   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange
   *
   * It is defined as a reference to simplify hook dependencies and clarify that
   * it needs to be initialized.
   */ var androidInputManagerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    // Listen on the native `selectionchange` event to be able to update any time
    // the selection changes. This is required because React's `onSelect` is leaky
    // and non-standard so it doesn't fire until after a selection has been
    // released. This causes issues in situations where another change happens
    // while a selection is being dragged.
    var onDOMSelectionChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Editable.useMemo[onDOMSelectionChange]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
                "Editable.useMemo[onDOMSelectionChange]": ()=>{
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_NODE_MAP_DIRTY"].get(editor)) {
                        onDOMSelectionChange();
                        return;
                    }
                    var el = ReactEditor.toDOMNode(editor, editor);
                    var root = el.getRootNode();
                    if (!processing.current && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"] && root instanceof ShadowRoot) {
                        processing.current = true;
                        var active = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveElement"])();
                        if (active) {
                            document.execCommand('indent');
                        } else {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
                        }
                        processing.current = false;
                        return;
                    }
                    var androidInputManager = androidInputManagerRef.current;
                    if ((__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
                        var _root = ReactEditor.findDocumentOrShadowRoot(editor);
                        var { activeElement } = _root;
                        var _el = ReactEditor.toDOMNode(editor, editor);
                        var domSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelection"])(_root);
                        if (activeElement === _el) {
                            state.latestElement = activeElement;
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FOCUSED"].set(editor, true);
                        } else {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FOCUSED"].delete(editor);
                        }
                        if (!domSelection) {
                            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
                        }
                        var { anchorNode, focusNode } = domSelection;
                        var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
                        var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);
                        if (anchorNodeSelectable && focusNodeInEditor) {
                            var range = ReactEditor.toSlateRange(editor, domSelection, {
                                exactMatch: false,
                                suppressThrow: true
                            });
                            if (range) {
                                if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, range);
                                } else {
                                    androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range);
                                }
                            }
                        }
                        // Deselect the editor if the dom selection is not selectable in readonly mode
                        if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
                        }
                    }
                }
            }["Editable.useMemo[onDOMSelectionChange]"], 100)
    }["Editable.useMemo[onDOMSelectionChange]"], [
        editor,
        readOnly,
        state
    ]);
    var scheduleOnDOMSelectionChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Editable.useMemo[scheduleOnDOMSelectionChange]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(onDOMSelectionChange, 0)
    }["Editable.useMemo[scheduleOnDOMSelectionChange]"], [
        onDOMSelectionChange
    ]);
    androidInputManagerRef.current = useAndroidInputManager({
        node: ref,
        onDOMSelectionChange,
        scheduleOnDOMSelectionChange
    });
    useIsomorphicLayoutEffect({
        "Editable.useIsomorphicLayoutEffect": ()=>{
            var _androidInputManagerR, _androidInputManagerR2;
            // Update element-related weak maps with the DOM element ref.
            var window1;
            if (ref.current && (window1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultView"])(ref.current))) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_WINDOW"].set(editor, window1);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_ELEMENT"].set(editor, ref.current);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].set(editor, ref.current);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_TO_NODE"].set(ref.current, editor);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].delete(editor);
            }
            // Make sure the DOM selection state is in sync.
            var { selection } = editor;
            var root = ReactEditor.findDocumentOrShadowRoot(editor);
            var domSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelection"])(root);
            if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {
                return;
            }
            var setDomSelection = {
                "Editable.useIsomorphicLayoutEffect.setDomSelection": (forceChange)=>{
                    var hasDomSelection = domSelection.type !== 'None';
                    // If the DOM selection is properly unset, we're done.
                    if (!selection && !hasDomSelection) {
                        return;
                    }
                    // Get anchorNode and focusNode
                    var focusNode = domSelection.focusNode;
                    var anchorNode;
                    // COMPAT: In firefox the normal selection way does not work
                    // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FIREFOX"] && domSelection.rangeCount > 1) {
                        var firstRange = domSelection.getRangeAt(0);
                        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);
                        // Right to left
                        if (firstRange.startContainer === focusNode) {
                            anchorNode = lastRange.endContainer;
                        } else {
                            // Left to right
                            anchorNode = firstRange.startContainer;
                        }
                    } else {
                        anchorNode = domSelection.anchorNode;
                    }
                    // verify that the dom selection is in the editor
                    var editorElement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_ELEMENT"].get(editor);
                    var hasDomSelectionInEditor = false;
                    if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {
                        hasDomSelectionInEditor = true;
                    }
                    // If the DOM selection is in the editor and the editor selection is already correct, we're done.
                    if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
                        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
                            exactMatch: true,
                            // domSelection is not necessarily a valid Slate range
                            // (e.g. when clicking on contentEditable:false element)
                            suppressThrow: true
                        });
                        if (slateRange && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(slateRange, selection)) {
                            var _anchorNode;
                            if (!state.hasMarkPlaceholder) {
                                return;
                            }
                            // Ensure selection is inside the mark placeholder
                            if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute('data-slate-mark-placeholder')) {
                                return;
                            }
                        }
                    }
                    // when <Editable/> is being controlled through external value
                    // then its children might just change - DOM responds to it on its own
                    // but Slate's value is not being updated through any operation
                    // and thus it doesn't transform selection on its own
                    if (selection && !ReactEditor.hasRange(editor, selection)) {
                        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
                            exactMatch: false,
                            suppressThrow: true
                        });
                        return;
                    }
                    // Otherwise the DOM selection is out of sync, so update it.
                    state.isUpdatingSelection = true;
                    var newDomRange = null;
                    try {
                        newDomRange = selection && ReactEditor.toDOMRange(editor, selection);
                    } catch (e) {
                    // Ignore, dom and state might be out of sync
                    }
                    if (newDomRange) {
                        if (ReactEditor.isComposing(editor) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"]) {
                            domSelection.collapseToEnd();
                        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isBackward(selection)) {
                            domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
                        } else {
                            domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
                        }
                        scrollSelectionIntoView(editor, newDomRange);
                    } else {
                        domSelection.removeAllRanges();
                    }
                    return newDomRange;
                }
            }["Editable.useIsomorphicLayoutEffect.setDomSelection"];
            // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table
            if (domSelection.rangeCount <= 1) {
                setDomSelection();
            }
            var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] || !ensureSelection) {
                setTimeout({
                    "Editable.useIsomorphicLayoutEffect": ()=>{
                        state.isUpdatingSelection = false;
                    }
                }["Editable.useIsomorphicLayoutEffect"]);
                return;
            }
            var timeoutId = null;
            var animationFrameId = requestAnimationFrame({
                "Editable.useIsomorphicLayoutEffect.animationFrameId": ()=>{
                    if (ensureSelection) {
                        var ensureDomSelection = {
                            "Editable.useIsomorphicLayoutEffect.animationFrameId.ensureDomSelection": (forceChange)=>{
                                try {
                                    var el = ReactEditor.toDOMNode(editor, editor);
                                    el.focus();
                                    setDomSelection(forceChange);
                                } catch (e) {
                                // Ignore, dom and state might be out of sync
                                }
                            }
                        }["Editable.useIsomorphicLayoutEffect.animationFrameId.ensureDomSelection"];
                        // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.
                        // This essentially would make setting the slate selection during an update meaningless, so we force it
                        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a
                        // visible flicker.
                        ensureDomSelection();
                        timeoutId = setTimeout({
                            "Editable.useIsomorphicLayoutEffect.animationFrameId": ()=>{
                                // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,
                                // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after
                                // the animation frame to ensure it displays the correct state.
                                ensureDomSelection(true);
                                state.isUpdatingSelection = false;
                            }
                        }["Editable.useIsomorphicLayoutEffect.animationFrameId"]);
                    }
                }
            }["Editable.useIsomorphicLayoutEffect.animationFrameId"]);
            return ({
                "Editable.useIsomorphicLayoutEffect": ()=>{
                    cancelAnimationFrame(animationFrameId);
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                }
            })["Editable.useIsomorphicLayoutEffect"];
        }
    }["Editable.useIsomorphicLayoutEffect"]);
    // Listen on the native `beforeinput` event to get real "Level 2" events. This
    // is required because React's `beforeinput` is fake and never really attaches
    // to the real event sadly. (2019/11/01)
    // https://github.com/facebook/react/issues/11211
    var onDOMBeforeInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Editable.useCallback[onDOMBeforeInput]": (event)=>{
            var el = ReactEditor.toDOMNode(editor, editor);
            var root = el.getRootNode();
            if (processing !== null && processing !== void 0 && processing.current && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"] && root instanceof ShadowRoot) {
                var ranges = event.getTargetRanges();
                var range = ranges[0];
                var newRange = new window.Range();
                newRange.setStart(range.startContainer, range.startOffset);
                newRange.setEnd(range.endContainer, range.endOffset);
                // Translate the DOM Range into a Slate Range
                var slateRange = ReactEditor.toSlateRange(editor, newRange, {
                    exactMatch: false,
                    suppressThrow: false
                });
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, slateRange);
                event.preventDefault();
                event.stopImmediatePropagation();
                return;
            }
            onUserInput();
            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
                var _EDITOR_TO_USER_SELEC;
                // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.
                if (androidInputManagerRef.current) {
                    return androidInputManagerRef.current.handleDOMBeforeInput(event);
                }
                // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before
                // triggering a `beforeinput` expecting the change to be applied to the immediately before
                // set selection.
                scheduleOnDOMSelectionChange.flush();
                onDOMSelectionChange.flush();
                var { selection } = editor;
                var { inputType: type } = event;
                var data = event.dataTransfer || event.data || undefined;
                var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText';
                // COMPAT: use composition change events as a hint to where we should insert
                // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038
                if (isCompositionChange && ReactEditor.isComposing(editor)) {
                    return;
                }
                var native = false;
                if (type === 'insertText' && selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
                // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
                // causes duplicate inserts.
                event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
                // When there is an inline element, e.g. a link, and you select
                // right after it (the start of the next node).
                selection.anchor.offset !== 0) {
                    native = true;
                    // Skip native if there are marks, as
                    // `insertText` will insert a node, not just text.
                    if (editor.marks) {
                        native = false;
                    }
                    // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint)
                    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_NODE_MAP_DIRTY"].get(editor)) {
                        var _node$parentElement, _window$getComputedSt;
                        // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100
                        // Therefore we don't allow native events to insert text at the end of anchor nodes.
                        var { anchor } = selection;
                        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);
                        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');
                        var _window = ReactEditor.getWindow(editor);
                        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
                            var _lastText$textContent;
                            // Find the last text node inside the anchor.
                            var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
                            if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {
                                native = false;
                            }
                        }
                        // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'
                        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139
                        if (native && node.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {
                            var block = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].above(editor, {
                                at: anchor.path,
                                match: {
                                    "Editable.useCallback[onDOMBeforeInput].block": (n)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(n) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(editor, n)
                                }["Editable.useCallback[onDOMBeforeInput].block"]
                            });
                            if (block && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].string(block[0]).includes('\t')) {
                                native = false;
                            }
                        }
                    }
                }
                // COMPAT: For the deleting forward/backward input types we don't want
                // to change the selection because it is the range that will be deleted,
                // and those commands determine that for themselves.
                // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint via ReactEditor.toSlateRange)
                if ((!type.startsWith('delete') || type.startsWith('deleteBy')) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_NODE_MAP_DIRTY"].get(editor)) {
                    var [targetRange] = event.getTargetRanges();
                    if (targetRange) {
                        var _range = ReactEditor.toSlateRange(editor, targetRange, {
                            exactMatch: false,
                            suppressThrow: false
                        });
                        if (!selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(selection, _range)) {
                            native = false;
                            var selectionRef = !isCompositionChange && editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].rangeRef(editor, editor.selection);
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, _range);
                            if (selectionRef) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_SELECTION"].set(editor, selectionRef);
                            }
                        }
                    }
                }
                // Composition change types occur while a user is composing text and can't be
                // cancelled. Let them through and wait for the composition to end.
                if (isCompositionChange) {
                    return;
                }
                if (!native) {
                    event.preventDefault();
                }
                // COMPAT: If the selection is expanded, even if the command seems like
                // a delete forward/backward command it should delete the selection.
                if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection) && type.startsWith('delete')) {
                    var direction = type.endsWith('Backward') ? 'backward' : 'forward';
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                        direction
                    });
                    return;
                }
                switch(type){
                    case 'deleteByComposition':
                    case 'deleteByCut':
                    case 'deleteByDrag':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor);
                            break;
                        }
                    case 'deleteContent':
                    case 'deleteContentForward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor);
                            break;
                        }
                    case 'deleteContentBackward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor);
                            break;
                        }
                    case 'deleteEntireSoftLine':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                unit: 'line'
                            });
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                unit: 'line'
                            });
                            break;
                        }
                    case 'deleteHardLineBackward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                unit: 'block'
                            });
                            break;
                        }
                    case 'deleteSoftLineBackward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                unit: 'line'
                            });
                            break;
                        }
                    case 'deleteHardLineForward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                unit: 'block'
                            });
                            break;
                        }
                    case 'deleteSoftLineForward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                unit: 'line'
                            });
                            break;
                        }
                    case 'deleteWordBackward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                unit: 'word'
                            });
                            break;
                        }
                    case 'deleteWordForward':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                unit: 'word'
                            });
                            break;
                        }
                    case 'insertLineBreak':
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertSoftBreak(editor);
                        break;
                    case 'insertParagraph':
                        {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertBreak(editor);
                            break;
                        }
                    case 'insertFromComposition':
                    case 'insertFromDrop':
                    case 'insertFromPaste':
                    case 'insertFromYank':
                    case 'insertReplacementText':
                    case 'insertText':
                        {
                            if (type === 'insertFromComposition') {
                                // COMPAT: in Safari, `compositionend` is dispatched after the
                                // `beforeinput` for "insertFromComposition". But if we wait for it
                                // then we will abort because we're still composing and the selection
                                // won't be updated properly.
                                // https://www.w3.org/TR/input-events-2/
                                if (ReactEditor.isComposing(editor)) {
                                    setIsComposing(false);
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, false);
                                }
                            }
                            // use a weak comparison instead of 'instanceof' to allow
                            // programmatic access of paste events coming from external windows
                            // like cypress where cy.window does not work realibly
                            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {
                                ReactEditor.insertData(editor, data);
                            } else if (typeof data === 'string') {
                                // Only insertText operations use the native functionality, for now.
                                // Potentially expand to single character deletes, as well.
                                if (native) {
                                    deferredOperations.current.push({
                                        "Editable.useCallback[onDOMBeforeInput]": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, data)
                                    }["Editable.useCallback[onDOMBeforeInput]"]);
                                } else {
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, data);
                                }
                            }
                            break;
                        }
                }
                // Restore the actual user section if nothing manually set it.
                var toRestore = (_EDITOR_TO_USER_SELEC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_SELECTION"].get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_SELECTION"].delete(editor);
                if (toRestore && (!editor.selection || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(editor.selection, toRestore))) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, toRestore);
                }
            }
        }
    }["Editable.useCallback[onDOMBeforeInput]"], [
        editor,
        onDOMSelectionChange,
        onUserInput,
        propsOnDOMBeforeInput,
        readOnly,
        scheduleOnDOMSelectionChange
    ]);
    var callbackRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Editable.useCallback[callbackRef]": (node)=>{
            if (node == null) {
                onDOMSelectionChange.cancel();
                scheduleOnDOMSelectionChange.cancel();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_ELEMENT"].delete(editor);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_TO_ELEMENT"].delete(editor);
                if (ref.current && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"]) {
                    // @ts-ignore The `beforeinput` event isn't recognized.
                    ref.current.removeEventListener('beforeinput', onDOMBeforeInput);
                }
            } else {
                // Attach a native DOM event handler for `beforeinput` events, because React's
                // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose
                // real `beforeinput` events sadly... (2019/11/04)
                // https://github.com/facebook/react/issues/11211
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"]) {
                    // @ts-ignore The `beforeinput` event isn't recognized.
                    node.addEventListener('beforeinput', onDOMBeforeInput);
                }
            }
            ref.current = node;
            if (typeof forwardedRef === 'function') {
                forwardedRef(node);
            } else if (forwardedRef) {
                forwardedRef.current = node;
            }
        }
    }["Editable.useCallback[callbackRef]"], [
        onDOMSelectionChange,
        scheduleOnDOMSelectionChange,
        editor,
        onDOMBeforeInput,
        forwardedRef
    ]);
    useIsomorphicLayoutEffect({
        "Editable.useIsomorphicLayoutEffect": ()=>{
            var window1 = ReactEditor.getWindow(editor);
            // Attach a native DOM event handler for `selectionchange`, because React's
            // built-in `onSelect` handler doesn't fire for all selection changes. It's
            // a leaky polyfill that only fires on keypresses or clicks. Instead, we
            // want to fire for any change to the selection inside the editor.
            // (2019/11/04) https://github.com/facebook/react/issues/5785
            window1.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);
            // Listen for dragend and drop globally. In Firefox, if a drop handler
            // initiates an operation that causes the originally dragged element to
            // unmount, that element will not emit a dragend event. (2024/06/21)
            var stoppedDragging = {
                "Editable.useIsomorphicLayoutEffect.stoppedDragging": ()=>{
                    state.isDraggingInternally = false;
                }
            }["Editable.useIsomorphicLayoutEffect.stoppedDragging"];
            window1.document.addEventListener('dragend', stoppedDragging);
            window1.document.addEventListener('drop', stoppedDragging);
            return ({
                "Editable.useIsomorphicLayoutEffect": ()=>{
                    window1.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);
                    window1.document.removeEventListener('dragend', stoppedDragging);
                    window1.document.removeEventListener('drop', stoppedDragging);
                }
            })["Editable.useIsomorphicLayoutEffect"];
        }
    }["Editable.useIsomorphicLayoutEffect"], [
        scheduleOnDOMSelectionChange,
        state
    ]);
    var decorations = decorate([
        editor,
        []
    ]);
    var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].texts(editor)).length === 1 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].string(editor) === '' && !isComposing;
    var placeHolderResizeHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Editable.useCallback[placeHolderResizeHandler]": (placeholderEl)=>{
            if (placeholderEl && showPlaceholder) {
                var _placeholderEl$getBou;
                setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);
            } else {
                setPlaceholderHeight(undefined);
            }
        }
    }["Editable.useCallback[placeHolderResizeHandler]"], [
        showPlaceholder
    ]);
    if (showPlaceholder) {
        var start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, []);
        decorations.push({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLACEHOLDER_SYMBOL"]]: true,
            placeholder,
            onPlaceholderResize: placeHolderResizeHandler,
            anchor: start,
            focus: start
        });
    }
    var { marks } = editor;
    state.hasMarkPlaceholder = false;
    if (editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection) && marks) {
        var { anchor } = editor.selection;
        var leaf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].leaf(editor, anchor.path);
        var rest = _objectWithoutProperties(leaf, _excluded2);
        // While marks isn't a 'complete' text, we can still use loose Text.equals
        // here which only compares marks anyway.
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].equals(leaf, marks, {
            loose: true
        })) {
            state.hasMarkPlaceholder = true;
            var unset = Object.fromEntries(Object.keys(rest).map((mark)=>[
                    mark,
                    null
                ]));
            decorations.push(_objectSpread(_objectSpread(_objectSpread({
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MARK_PLACEHOLDER_SYMBOL"]]: true
            }, unset), marks), {}, {
                anchor,
                focus: anchor
            }));
        }
    }
    // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it
    // before we receive the composition end event.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Editable.useEffect": ()=>{
            setTimeout({
                "Editable.useEffect": ()=>{
                    var { selection } = editor;
                    if (selection) {
                        var { anchor: _anchor } = selection;
                        var _text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].leaf(editor, _anchor.path);
                        // While marks isn't a 'complete' text, we can still use loose Text.equals
                        // here which only compares marks anyway.
                        if (marks && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].equals(_text, marks, {
                            loose: true
                        })) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].set(editor, marks);
                            return;
                        }
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].delete(editor);
                }
            }["Editable.useEffect"]);
        }
    }["Editable.useEffect"]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ReadOnlyContext.Provider, {
        value: readOnly
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ComposingContext.Provider, {
        value: isComposing
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(DecorateContext.Provider, {
        value: decorate
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(RestoreDOM, {
        node: ref,
        receivedUserInput: receivedUserInput
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Component, _objectSpread(_objectSpread({
        role: readOnly ? undefined : 'textbox',
        "aria-multiline": readOnly ? undefined : true
    }, attributes), {}, {
        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
        // have to use hacks to make these replacement-based features work.
        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
        // mismatch warning app moves to browser. Pass-through consumer props when
        // not CAN_USE_DOM (SSR) and default to falsy value
        spellCheck: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"] || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CAN_USE_DOM"] ? attributes.spellCheck : false,
        autoCorrect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"] || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CAN_USE_DOM"] ? attributes.autoCorrect : 'false',
        autoCapitalize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"] || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CAN_USE_DOM"] ? attributes.autoCapitalize : 'false',
        "data-slate-editor": true,
        "data-slate-node": "value",
        // explicitly set this
        contentEditable: !readOnly,
        // in some cases, a decoration needs access to the range / selection to decorate a text node,
        // then you will select the whole text node when you select part the of text
        // this magic zIndex="-1" will fix it
        zindex: -1,
        suppressContentEditableWarning: true,
        ref: callbackRef,
        style: _objectSpread(_objectSpread({}, disableDefaultStyles ? {} : _objectSpread({
            // Allow positioning relative to the editable element.
            position: 'relative',
            // Preserve adjacent whitespace and new lines.
            whiteSpace: 'pre-wrap',
            // Allow words to break if they are too long.
            wordWrap: 'break-word'
        }, placeholderHeight ? {
            minHeight: placeholderHeight
        } : {})), userStyle),
        onBeforeInput: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                // COMPAT: Certain browsers don't support the `beforeinput` event, so we
                // fall back to React's leaky polyfill instead just for it. It
                // only works for the `insertText` input type.
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"] && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
                    event.preventDefault();
                    if (!ReactEditor.isComposing(editor)) {
                        var _text2 = event.data;
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, _text2);
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onBeforeInput,
            editor,
            readOnly
        ]),
        onInput: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (isEventHandled(event, attributes.onInput)) {
                    return;
                }
                if (androidInputManagerRef.current) {
                    androidInputManagerRef.current.handleInput();
                    return;
                }
                // Flush native operations, as native events will have propogated
                // and we can correctly compare DOM text values in components
                // to stop rendering, so that browser functions like autocorrect
                // and spellcheck work as expected.
                for (var op of deferredOperations.current){
                    op();
                }
                deferredOperations.current = [];
                // COMPAT: Since `beforeinput` doesn't fully `preventDefault`,
                // there's a chance that content might be placed in the browser's undo stack.
                // This means undo can be triggered even when the div is not focused,
                // and it only triggers the input event for the node. (2024/10/09)
                if (!ReactEditor.isFocused(editor)) {
                    var native = event.nativeEvent;
                    var maybeHistoryEditor = editor;
                    if (native.inputType === 'historyUndo' && typeof maybeHistoryEditor.undo === 'function') {
                        maybeHistoryEditor.undo();
                        return;
                    }
                    if (native.inputType === 'historyRedo' && typeof maybeHistoryEditor.redo === 'function') {
                        maybeHistoryEditor.redo();
                        return;
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onInput,
            editor
        ]),
        onBlur: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
                    return;
                }
                // COMPAT: If the current `activeElement` is still the previous
                // one, this is due to the window being blurred when the tab
                // itself becomes unfocused, so we want to abort early to allow to
                // editor to stay focused when the tab becomes focused again.
                var root = ReactEditor.findDocumentOrShadowRoot(editor);
                if (state.latestElement === root.activeElement) {
                    return;
                }
                var { relatedTarget } = event;
                var el = ReactEditor.toDOMNode(editor, editor);
                // COMPAT: The event should be ignored if the focus is returning
                // to the editor from an embedded editable element (eg. an <input>
                // element inside a void node).
                if (relatedTarget === el) {
                    return;
                }
                // COMPAT: The event should be ignored if the focus is moving from
                // the editor to inside a void node's spacer element.
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMElement"])(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {
                    return;
                }
                // COMPAT: The event should be ignored if the focus is moving to a
                // non- editable section of an element that isn't a void node (eg.
                // a list item of the check list example).
                if (relatedTarget != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMNode"])(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
                    var node = ReactEditor.toSlateNode(editor, relatedTarget);
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && !editor.isVoid(node)) {
                        return;
                    }
                }
                // COMPAT: Safari doesn't always remove the selection even if the content-
                // editable element no longer has focus. Refer to:
                // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"]) {
                    var domSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelection"])(root);
                    domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FOCUSED"].delete(editor);
            }
        }["Editable.useCallback"], [
            readOnly,
            state.isUpdatingSelection,
            state.latestElement,
            editor,
            attributes.onBlur
        ]),
        onClick: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMNode"])(event.target)) {
                    var node = ReactEditor.toSlateNode(editor, event.target);
                    var path = ReactEditor.findPath(editor, node);
                    // At this time, the Slate document may be arbitrarily different,
                    // because onClick handlers can change the document before we get here.
                    // Therefore we must check that this path actually exists,
                    // and that it still refers to the same node.
                    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].hasPath(editor, path) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, path) !== node) {
                        return;
                    }
                    if (event.detail === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRIPLE_CLICK"] && path.length >= 1) {
                        var blockPath = path;
                        if (!(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(editor, node))) {
                            var _block$;
                            var block = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].above(editor, {
                                match: {
                                    "Editable.useCallback.block": (n)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(n) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(editor, n)
                                }["Editable.useCallback.block"],
                                at: path
                            });
                            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);
                        }
                        var range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, blockPath);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, range);
                        return;
                    }
                    if (readOnly) {
                        return;
                    }
                    var _start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, path);
                    var end = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, path);
                    var startVoid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
                        at: _start
                    });
                    var endVoid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
                        at: end
                    });
                    if (startVoid && endVoid && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(startVoid[1], endVoid[1])) {
                        var _range2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, _start);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, _range2);
                    }
                }
            }
        }["Editable.useCallback"], [
            editor,
            attributes.onClick,
            readOnly
        ]),
        onCompositionEnd: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasSelectableTarget(editor, event.target)) {
                    var _androidInputManagerR3;
                    if (ReactEditor.isComposing(editor)) {
                        Promise.resolve().then({
                            "Editable.useCallback": ()=>{
                                setIsComposing(false);
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, false);
                            }
                        }["Editable.useCallback"]);
                    }
                    (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);
                    if (isEventHandled(event, attributes.onCompositionEnd) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"]) {
                        return;
                    }
                    // COMPAT: In Chrome, `beforeinput` events for compositions
                    // aren't correct and never fire the "insertFromComposition"
                    // type that we need. So instead, insert whenever a composition
                    // ends since it will already have been committed to the DOM.
                    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FIREFOX_LEGACY"] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_IOS"] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WECHATBROWSER"] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_UC_MOBILE"] && event.data) {
                        var placeholderMarks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].get(editor);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_PENDING_INSERTION_MARKS"].delete(editor);
                        // Ensure we insert text with the marks the user was actually seeing
                        if (placeholderMarks !== undefined) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].set(editor, editor.marks);
                            editor.marks = placeholderMarks;
                        }
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertText(editor, event.data);
                        var userMarks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].get(editor);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_USER_MARKS"].delete(editor);
                        if (userMarks !== undefined) {
                            editor.marks = userMarks;
                        }
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onCompositionEnd,
            editor
        ]),
        onCompositionUpdate: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
                    if (!ReactEditor.isComposing(editor)) {
                        setIsComposing(true);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, true);
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onCompositionUpdate,
            editor
        ]),
        onCompositionStart: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasSelectableTarget(editor, event.target)) {
                    var _androidInputManagerR4;
                    (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);
                    if (isEventHandled(event, attributes.onCompositionStart) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"]) {
                        return;
                    }
                    setIsComposing(true);
                    var { selection } = editor;
                    if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor);
                        return;
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onCompositionStart,
            editor
        ]),
        onCopy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {
                    event.preventDefault();
                    ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');
                }
            }
        }["Editable.useCallback"], [
            attributes.onCopy,
            editor
        ]),
        onCut: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {
                    event.preventDefault();
                    ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');
                    var { selection } = editor;
                    if (selection) {
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor);
                        } else {
                            var node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].parent(editor, selection.anchor.path);
                            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, node)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(editor);
                            }
                        }
                    }
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            editor,
            attributes.onCut
        ]),
        onDragOver: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
                    // Only when the target is void, call `preventDefault` to signal
                    // that drops are allowed. Editable content is droppable by
                    // default, and calling `preventDefault` hides the cursor.
                    var node = ReactEditor.toSlateNode(editor, event.target);
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, node)) {
                        event.preventDefault();
                    }
                }
            }
        }["Editable.useCallback"], [
            attributes.onDragOver,
            editor
        ]),
        onDragStart: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
                    var node = ReactEditor.toSlateNode(editor, event.target);
                    var path = ReactEditor.findPath(editor, node);
                    var voidMatch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, node) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
                        at: path,
                        voids: true
                    });
                    // If starting a drag on a void node, make sure it is selected
                    // so that it shows up in the selection's fragment.
                    if (voidMatch) {
                        var range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, path);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, range);
                    }
                    state.isDraggingInternally = true;
                    ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            editor,
            attributes.onDragStart,
            state
        ]),
        onDrop: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
                    event.preventDefault();
                    // Keep a reference to the dragged range before updating selection
                    var draggedRange = editor.selection;
                    // Find the range where the drop happened
                    var range = ReactEditor.findEventRange(editor, event);
                    var data = event.dataTransfer;
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, range);
                    if (state.isDraggingInternally) {
                        if (draggedRange && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(draggedRange, range) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].void(editor, {
                            at: range,
                            voids: true
                        })) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(editor, {
                                at: draggedRange
                            });
                        }
                    }
                    ReactEditor.insertData(editor, data);
                    // When dragging from another source into the editor, it's possible
                    // that the current editor does not have focus.
                    if (!ReactEditor.isFocused(editor)) {
                        ReactEditor.focus(editor);
                    }
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            editor,
            attributes.onDrop,
            state
        ]),
        onDragEnd: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
                    attributes.onDragEnd(event);
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            state,
            attributes,
            editor
        ]),
        onFocus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
                    var el = ReactEditor.toDOMNode(editor, editor);
                    var root = ReactEditor.findDocumentOrShadowRoot(editor);
                    state.latestElement = root.activeElement;
                    // COMPAT: If the editor has nested editable elements, the focus
                    // can go to them. In Firefox, this must be prevented because it
                    // results in issues with keyboard navigation. (2017/03/30)
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FIREFOX"] && event.target !== el) {
                        el.focus();
                        return;
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FOCUSED"].set(editor, true);
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            state,
            editor,
            attributes.onFocus
        ]),
        onKeyDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {
                    var _androidInputManagerR5;
                    (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);
                    var { nativeEvent } = event;
                    // COMPAT: The composition end event isn't fired reliably in all browsers,
                    // so we sometimes might end up stuck in a composition state even though we
                    // aren't composing any more.
                    if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_COMPOSING"].set(editor, false);
                        setIsComposing(false);
                    }
                    if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
                        return;
                    }
                    var { selection } = editor;
                    var element = editor.children[selection !== null ? selection.focus.path[0] : 0];
                    var isRTL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$direction$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].string(element)) === 'rtl';
                    // COMPAT: Since we prevent the default behavior on
                    // `beforeinput` events, the browser doesn't think there's ever
                    // any history stack to undo or redo, so we have to manage these
                    // hotkeys ourselves. (2019/11/06)
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isRedo(nativeEvent)) {
                        event.preventDefault();
                        var maybeHistoryEditor = editor;
                        if (typeof maybeHistoryEditor.redo === 'function') {
                            maybeHistoryEditor.redo();
                        }
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isUndo(nativeEvent)) {
                        event.preventDefault();
                        var _maybeHistoryEditor = editor;
                        if (typeof _maybeHistoryEditor.undo === 'function') {
                            _maybeHistoryEditor.undo();
                        }
                        return;
                    }
                    // COMPAT: Certain browsers don't handle the selection updates
                    // properly. In Chrome, the selection isn't properly extended.
                    // And in Firefox, the selection isn't properly collapsed.
                    // (2017/10/17)
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveLineBackward(nativeEvent)) {
                        event.preventDefault();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'line',
                            reverse: true
                        });
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveLineForward(nativeEvent)) {
                        event.preventDefault();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'line'
                        });
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isExtendLineBackward(nativeEvent)) {
                        event.preventDefault();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'line',
                            edge: 'focus',
                            reverse: true
                        });
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isExtendLineForward(nativeEvent)) {
                        event.preventDefault();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'line',
                            edge: 'focus'
                        });
                        return;
                    }
                    // COMPAT: If a void node is selected, or a zero-width text node
                    // adjacent to an inline is selected, we need to handle these
                    // hotkeys manually because browsers won't be able to skip over
                    // the void node with the zero-width space not being an empty
                    // string.
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveBackward(nativeEvent)) {
                        event.preventDefault();
                        if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(selection)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                                reverse: !isRTL
                            });
                        } else {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].collapse(editor, {
                                edge: isRTL ? 'end' : 'start'
                            });
                        }
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveForward(nativeEvent)) {
                        event.preventDefault();
                        if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(selection)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                                reverse: isRTL
                            });
                        } else {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].collapse(editor, {
                                edge: isRTL ? 'start' : 'end'
                            });
                        }
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveWordBackward(nativeEvent)) {
                        event.preventDefault();
                        if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].collapse(editor, {
                                edge: 'focus'
                            });
                        }
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'word',
                            reverse: !isRTL
                        });
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isMoveWordForward(nativeEvent)) {
                        event.preventDefault();
                        if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].collapse(editor, {
                                edge: 'focus'
                            });
                        }
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(editor, {
                            unit: 'word',
                            reverse: isRTL
                        });
                        return;
                    }
                    // COMPAT: Certain browsers don't support the `beforeinput` event, so we
                    // fall back to guessing at the input intention for hotkeys.
                    // COMPAT: In iOS, some of these hotkeys are handled in the
                    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"]) {
                        // We don't have a core behavior for these, but they change the
                        // DOM if we don't prevent them, so we have to.
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isBold(nativeEvent) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isItalic(nativeEvent) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isTransposeCharacter(nativeEvent)) {
                            event.preventDefault();
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isSoftBreak(nativeEvent)) {
                            event.preventDefault();
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertSoftBreak(editor);
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isSplitBlock(nativeEvent)) {
                            event.preventDefault();
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertBreak(editor);
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteBackward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'backward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor);
                            }
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteForward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'forward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor);
                            }
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteLineBackward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'backward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                    unit: 'line'
                                });
                            }
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteLineForward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'forward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                    unit: 'line'
                                });
                            }
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteWordBackward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'backward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                    unit: 'word'
                                });
                            }
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteWordForward(nativeEvent)) {
                            event.preventDefault();
                            if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteFragment(editor, {
                                    direction: 'forward'
                                });
                            } else {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteForward(editor, {
                                    unit: 'word'
                                });
                            }
                            return;
                        }
                    } else {
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_CHROME"] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"]) {
                            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire
                            // an event when deleting backwards in a selected void inline node
                            if (selection && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteBackward(nativeEvent) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotkeys"].isDeleteForward(nativeEvent)) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(selection)) {
                                var currentNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].parent(editor, selection.anchor.path);
                                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(currentNode) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isVoid(editor, currentNode) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isInline(editor, currentNode) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isBlock(editor, currentNode))) {
                                    event.preventDefault();
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].deleteBackward(editor, {
                                        unit: 'block'
                                    });
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            editor,
            attributes.onKeyDown
        ]),
        onPaste: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "Editable.useCallback": (event)=>{
                if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
                    // COMPAT: Certain browsers don't support the `beforeinput` event, so we
                    // fall back to React's `onPaste` here instead.
                    // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events
                    // when "paste without formatting" is used, so fallback. (2020/02/20)
                    // COMPAT: Safari InputEvents generated by pasting won't include
                    // application/x-slate-fragment items, so use the
                    // ClipboardEvent here. (2023/03/15)
                    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_BEFORE_INPUT_SUPPORT"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainTextOnlyPaste"])(event.nativeEvent) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBKIT"]) {
                        event.preventDefault();
                        ReactEditor.insertData(editor, event.clipboardData);
                    }
                }
            }
        }["Editable.useCallback"], [
            readOnly,
            editor,
            attributes.onPaste
        ])
    }), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Children, {
        decorations: decorations,
        node: editor,
        renderElement: renderElement,
        renderPlaceholder: renderPlaceholder,
        renderLeaf: renderLeaf,
        selection: editor.selection
    }))))));
});
/**
 * The default placeholder element
 */ var DefaultPlaceholder = (_ref)=>{
    var { attributes, children } = _ref;
    return(/*#__PURE__*/ // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", _objectSpread({}, attributes), children, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_ANDROID"] && /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("br", null)));
};
/**
 * A default memoized decorate function.
 */ var defaultDecorate = ()=>[];
/**
 * A default implement to scroll dom range into view.
 */ var defaultScrollSelectionIntoView = (editor, domRange)=>{
    // This was affecting the selection of multiple blocks and dragging behavior,
    // so enabled only if the selection has been collapsed.
    if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection))) {
        var leafEl = domRange.startContainer.parentElement;
        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scroll$2d$into$2d$view$2d$if$2d$needed$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(leafEl, {
            scrollMode: 'if-needed'
        });
        // @ts-expect-error an unorthodox delete D:
        delete leafEl.getBoundingClientRect;
    }
};
/**
 * Check if an event is overrided by a handler.
 */ var isEventHandled = (event, handler)=>{
    if (!handler) {
        return false;
    }
    // The custom event handler may return a boolean to specify whether the event
    // shall be treated as being handled or not.
    var shouldTreatEventAsHandled = handler(event);
    if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
    }
    return event.isDefaultPrevented() || event.isPropagationStopped();
};
/**
 * Check if the event's target is an input element
 */ var isDOMEventTargetInput = (event)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMNode"])(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);
};
/**
 * Check if a DOM event is overrided by a handler.
 */ var isDOMEventHandled = (event, handler)=>{
    if (!handler) {
        return false;
    }
    // The custom event handler may return a boolean to specify whether the event
    // shall be treated as being handled or not.
    var shouldTreatEventAsHandled = handler(event);
    if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
    }
    return event.defaultPrevented;
};
/**
 * A React context for sharing the `focused` state of the editor.
 */ var FocusedContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
/**
 * Get the current `focused` state of the editor.
 */ var useFocused = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(FocusedContext);
};
function isError(error) {
    return error instanceof Error;
}
/**
 * A React context for sharing the editor selector context in a way to control rerenders
 */ var SlateSelectorContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({});
var refEquality = (a, b)=>a === b;
/**
 * use redux style selectors to prevent rerendering on every keystroke.
 * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.
 *
 * Example:
 * ```
 *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));
 * ```
 */ function useSlateSelector(selector) {
    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;
    var [, forceRender] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])({
        "useSlateSelector.useReducer": (s)=>s + 1
    }["useSlateSelector.useReducer"], 0);
    var context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(SlateSelectorContext);
    if (!context) {
        throw new Error("The `useSlateSelector` hook must be used inside the <Slate> component's context.");
    }
    var { getSlate, addEventListener } = context;
    var latestSubscriptionCallbackError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    var latestSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        "useSlateSelector.useRef[latestSelector]": ()=>null
    }["useSlateSelector.useRef[latestSelector]"]);
    var latestSelectedState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var selectedState;
    try {
        if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {
            selectedState = selector(getSlate());
        } else {
            selectedState = latestSelectedState.current;
        }
    } catch (err) {
        if (latestSubscriptionCallbackError.current && isError(err)) {
            err.message += "\nThe error may be correlated with this previous error:\n".concat(latestSubscriptionCallbackError.current.stack, "\n\n");
        }
        throw err;
    }
    useIsomorphicLayoutEffect({
        "useSlateSelector.useIsomorphicLayoutEffect": ()=>{
            latestSelector.current = selector;
            latestSelectedState.current = selectedState;
            latestSubscriptionCallbackError.current = undefined;
        }
    }["useSlateSelector.useIsomorphicLayoutEffect"]);
    useIsomorphicLayoutEffect({
        "useSlateSelector.useIsomorphicLayoutEffect": ()=>{
            function checkForUpdates() {
                try {
                    var newSelectedState = latestSelector.current(getSlate());
                    if (equalityFn(newSelectedState, latestSelectedState.current)) {
                        return;
                    }
                    latestSelectedState.current = newSelectedState;
                } catch (err) {
                    // we ignore all errors here, since when the component
                    // is re-rendered, the selectors are called again, and
                    // will throw again, if neither props nor store state
                    // changed
                    if (err instanceof Error) {
                        latestSubscriptionCallbackError.current = err;
                    } else {
                        latestSubscriptionCallbackError.current = new Error(String(err));
                    }
                }
                forceRender();
            }
            var unsubscribe = addEventListener(checkForUpdates);
            checkForUpdates();
            return ({
                "useSlateSelector.useIsomorphicLayoutEffect": ()=>unsubscribe()
            })["useSlateSelector.useIsomorphicLayoutEffect"];
        }
    }["useSlateSelector.useIsomorphicLayoutEffect"], // don't rerender on equalityFn change since we want to be able to define it inline
    [
        addEventListener,
        getSlate
    ]);
    return selectedState;
}
/**
 * Create selector context with editor updating on every editor change
 */ function useSelectorContext(editor) {
    var eventListeners = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])([]).current;
    var slateRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        editor
    }).current;
    var onChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSelectorContext.useCallback[onChange]": (editor)=>{
            slateRef.editor = editor;
            eventListeners.forEach({
                "useSelectorContext.useCallback[onChange]": (listener)=>listener(editor)
            }["useSelectorContext.useCallback[onChange]"]);
        }
    }["useSelectorContext.useCallback[onChange]"], [
        eventListeners,
        slateRef
    ]);
    var selectorContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSelectorContext.useMemo[selectorContext]": ()=>{
            return {
                getSlate: ({
                    "useSelectorContext.useMemo[selectorContext]": ()=>slateRef.editor
                })["useSelectorContext.useMemo[selectorContext]"],
                addEventListener: ({
                    "useSelectorContext.useMemo[selectorContext]": (callback)=>{
                        eventListeners.push(callback);
                        return ({
                            "useSelectorContext.useMemo[selectorContext]": ()=>{
                                eventListeners.splice(eventListeners.indexOf(callback), 1);
                            }
                        })["useSelectorContext.useMemo[selectorContext]"];
                    }
                })["useSelectorContext.useMemo[selectorContext]"]
            };
        }
    }["useSelectorContext.useMemo[selectorContext]"], [
        eventListeners,
        slateRef
    ]);
    return {
        selectorContext,
        onChange
    };
}
var REACT_MAJOR_VERSION = parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version.split('.')[0], 10);
var _excluded = [
    "editor",
    "children",
    "onChange",
    "onSelectionChange",
    "onValueChange",
    "initialValue"
];
/**
 * A wrapper around the provider to handle `onChange` events, because the editor
 * is a mutable singleton so it won't ever register as "changed" otherwise.
 */ var Slate = (props)=>{
    var { editor, children, onChange, onSelectionChange, onValueChange, initialValue } = props, rest = _objectWithoutProperties(props, _excluded);
    var [context, setContext] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState({
        "Slate.useState": ()=>{
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].isNodeList(initialValue)) {
                throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scrubber"].stringify(initialValue)));
            }
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(editor)) {
                throw new Error("[Slate] editor is invalid! You passed: ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scrubber"].stringify(editor)));
            }
            editor.children = initialValue;
            Object.assign(editor, rest);
            return {
                v: 0,
                editor
            };
        }
    }["Slate.useState"]);
    var { selectorContext, onChange: handleSelectorChange } = useSelectorContext(editor);
    var onContextChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "Slate.useCallback[onContextChange]": (options)=>{
            var _options$operation;
            if (onChange) {
                onChange(editor.children);
            }
            switch(options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type){
                case 'set_selection':
                    onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);
                    break;
                default:
                    onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);
            }
            setContext({
                "Slate.useCallback[onContextChange]": (prevContext)=>({
                        v: prevContext.v + 1,
                        editor
                    })
            }["Slate.useCallback[onContextChange]"]);
            handleSelectorChange(editor);
        }
    }["Slate.useCallback[onContextChange]"], [
        editor,
        handleSelectorChange,
        onChange,
        onSelectionChange,
        onValueChange
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Slate.useEffect": ()=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_ON_CHANGE"].set(editor, onContextChange);
            return ({
                "Slate.useEffect": ()=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDITOR_TO_ON_CHANGE"].set(editor, {
                        "Slate.useEffect": ()=>{}
                    }["Slate.useEffect"]);
                }
            })["Slate.useEffect"];
        }
    }["Slate.useEffect"], [
        editor,
        onContextChange
    ]);
    var [isFocused, setIsFocused] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(ReactEditor.isFocused(editor));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Slate.useEffect": ()=>{
            setIsFocused(ReactEditor.isFocused(editor));
        }
    }["Slate.useEffect"], [
        editor
    ]);
    useIsomorphicLayoutEffect({
        "Slate.useIsomorphicLayoutEffect": ()=>{
            var fn = {
                "Slate.useIsomorphicLayoutEffect.fn": ()=>setIsFocused(ReactEditor.isFocused(editor))
            }["Slate.useIsomorphicLayoutEffect.fn"];
            if (REACT_MAJOR_VERSION >= 17) {
                // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.
                // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)
                // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.
                document.addEventListener('focusin', fn);
                document.addEventListener('focusout', fn);
                return ({
                    "Slate.useIsomorphicLayoutEffect": ()=>{
                        document.removeEventListener('focusin', fn);
                        document.removeEventListener('focusout', fn);
                    }
                })["Slate.useIsomorphicLayoutEffect"];
            } else {
                document.addEventListener('focus', fn, true);
                document.addEventListener('blur', fn, true);
                return ({
                    "Slate.useIsomorphicLayoutEffect": ()=>{
                        document.removeEventListener('focus', fn, true);
                        document.removeEventListener('blur', fn, true);
                    }
                })["Slate.useIsomorphicLayoutEffect"];
            }
        }
    }["Slate.useIsomorphicLayoutEffect"], []);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SlateSelectorContext.Provider, {
        value: selectorContext
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SlateContext.Provider, {
        value: context
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(EditorContext.Provider, {
        value: context.editor
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(FocusedContext.Provider, {
        value: isFocused
    }, children))));
};
/**
 * Get the current editor object from the React context.
 * @deprecated Use useSlateStatic instead.
 */ var useEditor = ()=>{
    var editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorContext);
    if (!editor) {
        throw new Error("The `useEditor` hook must be used inside the <Slate> component's context.");
    }
    return editor;
};
/**
 * Get the current slate selection.
 * Only triggers a rerender when the selection actually changes
 */ var useSlateSelection = ()=>{
    return useSlateSelector({
        "useSlateSelection.useSlateSelector": (editor)=>editor.selection
    }["useSlateSelection.useSlateSelector"], isSelectionEqual);
};
var isSelectionEqual = (a, b)=>{
    if (!a && !b) return true;
    if (!a || !b) return false;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].equals(a, b);
};
/**
 * `withReact` adds React and DOM specific behaviors to the editor.
 *
 * If you are using TypeScript, you must extend Slate's CustomTypes to use
 * this plugin.
 *
 * See https://docs.slatejs.org/concepts/11-typescript to learn how.
 */ var withReact = function withReact(editor) {
    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';
    var e = editor;
    e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDOM"])(e, clipboardFormatKey);
    var { onChange } = e;
    e.onChange = (options)=>{
        // COMPAT: React < 18 doesn't batch `setState` hook calls, which means
        // that the children and selection can get out of sync for one render
        // pass. So we have to use this unstable API to ensure it batches them.
        // (2019/12/03)
        // https://github.com/facebook/react/issues/14259#issuecomment-439702367
        var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].unstable_batchedUpdates : (callback)=>callback();
        maybeBatchUpdates(()=>{
            onChange(options);
        });
    };
    return e;
};
;
 //# sourceMappingURL=index.es.js.map
}}),
}]);

//# sourceMappingURL=node_modules_abe012._.js.map